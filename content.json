{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/XQ.github.io/"},"pages":[{"title":"书单","date":"2021-03-26T05:18:31.979Z","updated":"2020-12-08T11:59:04.000Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-03-26T05:18:31.980Z","updated":"2020-12-08T11:59:04.000Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-03-26T05:18:31.981Z","updated":"2020-12-08T11:59:04.000Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-03-26T05:18:31.982Z","updated":"2020-12-08T11:59:04.000Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-03-26T06:19:27.056Z","updated":"2020-12-08T11:59:04.000Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2021-03-26T06:18:59.132Z","updated":"2020-12-08T11:59:04.000Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"关于","date":"2021-03-26T05:18:31.978Z","updated":"2020-12-08T11:59:04.000Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍"}],"posts":[{"title":"graphics pipeline - 图形管线","slug":"graphics1","date":"2021-03-26T11:18:01.301Z","updated":"2021-03-26T11:19:39.576Z","comments":true,"path":"2021/03/26/graphics1/","link":"","permalink":"http://example.com/2021/03/26/graphics1/","excerpt":"","text":"¶graphics pipeline - 图形管线 标准图形系统的实施流程通常称为图形管线。&rdquo;管线&ldquo;一词在这里指从数学模型到生成屏幕上像素的过程，它包含多个步骤。在经典的体系结构中，这些步骤是按序执行的，即一个阶段的结果输出给下一个阶段，前面阶段随即开始处理新的多边形。 管线简化示意图： 在许多情况下，管线的实现细节并非关注点，这时可以把它看成一个黑盒，通过黑盒，场景几何模型被转换为场景多边形的光栅透视投影（这里暂时忽略平行投影情况）图像。 纹理映射与近似 图形管线中的一个标准模块是纹理映射(texture map)，纹理映射通过查表的方式将纹理图像的颜色映射到一个或多个多边形上。这个过程就像在表面上刻写图案或是将一张花纹纸粘贴到物体上，扫描到系统中的图像，相机拍摄的照片，或者绘图软件制作的图像都是纹理图像，你可以把纹理图案想象成一张有图案的橡胶片，而纹理坐标描述了为了使这张橡胶片能够准确覆盖物体的某些部位，以及橡胶片是如何进行拉伸和变形的。 个人理解： 如上图，就是通过纹理坐标将纹理图案进行一系列拉伸和变形准确覆盖到物体上的对应位置。 通过纹理映射来指定图像上每个点的颜色仅仅是纹理映射的众多应用之一。例如，一个物体的外观部分取决于表面的法向量，计算光从表面的反射时就涉及法向量，由于表面通常采用多边形网格表示，所以通常在各多边形的顶点处计算表面的法向量，多边形内部各点的法向量则通过插值获得，从而使该物体表面呈现平滑的外观效果。 上述提到，管线结构能够让我们并行处理很多任务，管线上的每一阶段针对一部分数据执行某个任务，然后将处理结果传送给下一阶段，接着这一阶段立即开始处理下一部分数据，如果管线设计合理，则大大提高处理能力。当然，随着管线所含阶段数的增多，从输入数据到生成最终结果所需的时间总量也将增加。对于交互性要求很高的系统来说，这种滞后或者潜在滞后可能会造成严重影响。 图形管线包括4个主要部分：顶点几何处理和变换，三角形处理（光栅化）和片段（fragment)生成、纹理映射和光照以及用来组装最终图像的片段组合操作。 在这个更大的管线里，应用程序提供显示所需的数据，而图形管线则生成最终的图像，但在此期间用户可能会输入信息对应用程序进行控制（例如对所显示的图像有所影响），还有从图形管线中返回的信息，他们组合起来，用于计算下一帧画面。 持续补充。","categories":[{"name":"图形学","slug":"图形学","permalink":"http://example.com/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"概念知识","slug":"概念知识","permalink":"http://example.com/tags/%E6%A6%82%E5%BF%B5%E7%9F%A5%E8%AF%86/"}]},{"title":"Eigen:Matrix and Vector arithmetic","slug":"Eigen2","date":"2021-03-26T11:12:15.866Z","updated":"2021-03-26T11:16:57.459Z","comments":true,"path":"2021/03/26/Eigen2/","link":"","permalink":"http://example.com/2021/03/26/Eigen2/","excerpt":"","text":"¶Eigen:Matrix and Vector arithmetic Eigen库 有重载关于Matrix与Vector的计算符，这样我们可以很方便的得到矩阵运算后的结果。 一些基本运算符：+,-,*,/,+=,-=,*=,/= 普通的矩阵加减法运算： 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;Eigen/Dense&gt;using namespace Eigen;int main()&#123;Matrix2d a;a &lt;&lt; 1, 2,3, 4;MatrixXd b(2,2);b &lt;&lt; 2, 3,1, 4;std::cout &lt;&lt; &quot;a + b =\\n&quot; &lt;&lt; a + b &lt;&lt; std::endl;std::cout &lt;&lt; &quot;a - b =\\n&quot; &lt;&lt; a - b &lt;&lt; std::endl;std::cout &lt;&lt; &quot;Doing a += b;&quot; &lt;&lt; std::endl;a += b;std::cout &lt;&lt; &quot;Now a =\\n&quot; &lt;&lt; a &lt;&lt; std::endl;Vector3d v(1,2,3);Vector3d w(1,0,0);std::cout &lt;&lt; &quot;-v + w - v =\\n&quot; &lt;&lt; -v + w - v &lt;&lt; std::endl;&#125; Output: 1234567891011121314a + b =3 54 8a - b =-1 -1 2 0Doing a += b;Now a =3 54 8-v + w - v =-1-4-6 乘法运算： 12345678910111213141516#include &lt;iostream&gt;#include &lt;Eigen/Dense&gt;using namespace Eigen;int main()&#123;Matrix2d a;a &lt;&lt; 1, 2,3, 4;Vector3d v(1,2,3);std::cout &lt;&lt; &quot;a * 2.5 =\\n&quot; &lt;&lt; a * 2.5 &lt;&lt; std::endl;std::cout &lt;&lt; &quot;0.1 * v =\\n&quot; &lt;&lt; 0.1 * v &lt;&lt; std::endl;std::cout &lt;&lt; &quot;Doing v = 2;&quot; &lt;&lt; std::endl;v = 2;std::cout &lt;&lt; &quot;Now v =\\n&quot; &lt;&lt; v &lt;&lt; std::endl;&#125; Output: 123456789101112a * 2.5 =2.5 57.5 100.1 * v =0.10.20.3Doing v *= 2;Now v =246 除此之外，Eigen库关于运算还有个很人性化的地方比如，VectorXf a(50),b(50),c(50),d(50);...a = 3 * b + 4 * c + 5 * d;会自动编译为：for(int i = 0 ; i &lt; 50 ; i++){ a[i] = 3*b[i] + 4*c[i] + 5*d[i];} 注意：如果你看了上面一段关于表达式模板的内容，担心做m=m*m会引起别名问题，暂时放心。Eigen将矩阵乘法作为一种特殊情况处理，并注意在这里引入一个临时的，所以它将把m=m*m编译为： temp = m*m; m = temp; 然后是一些特殊的计算函数，十分便利： 123456789sum() //矩阵内元素和prod() //元素积mean() //元素平均minCoeff() //最小元素maxCoeff() //最大元素trace() //对角线和transpose() //转置conjugate() //共轭adjoint() //共轭转置 普通计算函数示例代码： 123456789101112131415#include &lt;iostream&gt;#include &lt;Eigen/Dense&gt;using namespace std;int main()&#123;Eigen::Matrix2d mat;mat &lt;&lt; 1, 2,3, 4;cout &lt;&lt; &quot;Here is mat.sum(): &quot; &lt;&lt; mat.sum() &lt;&lt; endl;cout &lt;&lt; &quot;Here is mat.prod(): &quot; &lt;&lt; mat.prod() &lt;&lt; endl;cout &lt;&lt; &quot;Here is mat.mean(): &quot; &lt;&lt; mat.mean() &lt;&lt; endl;cout &lt;&lt; &quot;Here is mat.minCoeff(): &quot; &lt;&lt; mat.minCoeff() &lt;&lt; endl;cout &lt;&lt; &quot;Here is mat.maxCoeff(): &quot; &lt;&lt; mat.maxCoeff() &lt;&lt; endl;cout &lt;&lt; &quot;Here is mat.trace(): &quot; &lt;&lt; mat.trace() &lt;&lt; endl;&#125; Output: 123456Here is mat.sum(): 10Here is mat.prod(): 24Here is mat.mean(): 2.5Here is mat.minCoeff(): 1Here is mat.maxCoeff(): 4Here is mat.trace(): 5 并且minCoeff()与maxCoeff()能够得到相应元素的下标，可使用如下方法实现： int i,j; minCoeff(&amp;i,&amp;j); maxCoeff(&amp;i,&amp;j); 得到的i,j就是相应元素的横纵坐标。 转置，共轭，共轭转置示例代码： MatrixXcf a = MatrixXcf::Random(2,2); //随机2x2矩阵 cout &lt;&lt; \"Here is the matrix a\\n\" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; “Here is the matrix a^T\\n” &lt;&lt; a.transpose() &lt;&lt; endl; cout &lt;&lt; “Here is the conjugate of a\\n” &lt;&lt; a.conjugate() &lt;&lt; endl; cout &lt;&lt; “Here is the matrix a^*\\n” &lt;&lt; a.adjoint() &lt;&lt; endl; Output: 123456789101112Here is the matrix a (-1,-0.737) (0.0655,-0.562)(0.511,-0.0827) (-0.906,0.358)Here is the matrix a^T (-1,-0.737) (0.511,-0.0827)(0.0655,-0.562) (-0.906,0.358)Here is the conjugate of a (-1,0.737) (0.0655,0.562) (0.511,0.0827) (-0.906,-0.358)Here is the matrix a^* (-1,0.737) (0.511,0.0827) (0.0655,0.562) (-0.906,-0.358) 注意：至于基本的算术运算符，transpose()和 adjoint()只是返回一个代理对象，而不进行实际的转置。如果你做b = a.transpose()，那么在将结果写入b的同时就会对transpose进行评估。如果执行a = a.transpose()，那么在转置的评估完成之前，Eigen就开始将结果写入a中。因此，指令a = a.transpose()并不像人们所期望的那样，用它的转置替换a。 还有两个函数差点忘记说了，分别是dot()与cross()，一个是计算点积，一个是计算叉积，非常实用的两个函数！ 补充两个编译时容易出现的错误：（官方文档详细说明） Eigen&nbsp;checks the validity of the operations that you perform. When possible, it checks them at compile time, producing compilation errors. These error messages can be long and ugly, but&nbsp;Eigen&nbsp;writes the important message in UPPERCASE_LETTERS_SO_IT_STANDS_OUT. For example:（Eigen会检查你所执行的操作的有效性，在可能的情况下，它会在编译时检查它们，产生编译错误。在可能的情况下，它在编译时检查它们，产生编译错误。这些错误信息可能又长又丑，但Eigen会把重要的信息用UPPERCASE_LETTERS_SO_IT_STANDS_OUT写出来，如下：） 123Matrix3f m;Vector4f v;v = m*v; // Compile-time error: YOU_MIXED_MATRICES_OF_DIFFERENT_SIZES Of course, in many cases, for example when checking dynamic sizes, the check cannot be performed at compile time.&nbsp;Eigenthen uses runtime assertions. This means that the program will abort with an error message when executing an illegal operation if it is run in \"debug mode\", and it will probably crash if assertions are turned off（当然，在很多情况下，比如检查动态大小时，不能在编译时进行检查。Eigen就会使用运行时断点。这意味着，如果在 \"debug模式 \"下运行，程序在执行非法操作时，会以错误信息中止，如果断点被关闭，程序很可能会崩溃）. &nbsp; 123MatrixXf m(3,3);VectorXf v(4);v = m * v; // Run-time assertion failure here: &quot;invalid matrix product&quot; 解释：第一个就是两种不同类型的矩阵相乘会出现SIZE报错，这是理所当然的，第二个就是检查动态大小时，不能在编译时进行检查！ 有些内容暂时用不到，以后补充。","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"Eigen","slug":"Eigen","permalink":"http://example.com/tags/Eigen/"}]},{"title":"Eigen:The Matrix Class","slug":"Eigen1","date":"2021-03-26T11:05:43.527Z","updated":"2021-03-26T11:11:24.254Z","comments":true,"path":"2021/03/26/Eigen1/","link":"","permalink":"http://example.com/2021/03/26/Eigen1/","excerpt":"","text":"¶The Matrix Class Eigen库 矩阵类的使用： （本文根据官方文档加上自己的一些理解修改制成） 首先关于Matrix的定义：&nbsp; Matrix&lt;typename scalar, int RowsAtCompileTime, int ColsAtCompileTime&gt; 这是常用的模板，一般为三个参数，也就是Matrix&lt;矩阵变量类型，行数，列数&gt;. 1234567891011 Matrix&lt;typename Scalar, //标量类型 int RowsAtCompileTime, //行数 int ColsAtCompileTime,//列数 int Options = 0,//位域 int MaxRowsAtCompileTime = RowsAtCompileTime,//最大行数 int MaxColsAtCompileTime = ColsAtCompileTime&gt; //最大列数 使用Eigen库定义一个矩阵: Matrix&lt;int,2,2&gt; 这是一个int类型的2x2矩阵 Matrix&lt;float,3,3&gt;这是一个float类型的3x3矩阵 Eigen库中简化了部分以上定义的过程，一般用于固定尺寸的矩阵的定义。 例如：&nbsp; Matrix2f,Matrix3f,Matrix4f&nbsp; float类型的2x2,3x3,4x4的矩阵(可见结尾部分为f） &nbsp; &nbsp; &nbsp;同理Matrix2d,Matrix3d,Matrix4d,Matrix2i,Matrix3i,Matrix4i,只需要看最后结尾的字母，即可明白变量类型(double,int) Eigen还有个常用的概念，向量，向量是矩阵中的特殊情况，表现为有一行或一列，也就是行向量和列向量，最常见的情况是只有一列，表现方式有： &nbsp; typedef Matrix&lt;float, 3, 1&gt; Vector3f;&nbsp; //列向量 &nbsp; typedef Matrix&lt;int, 1, 2&gt; RowVector2i; //行向量 接下来说明它们各自的赋值方式以及特殊情况： 静态矩阵下有如下的初始化方式:&nbsp; Vector2i myvector(1,2);&nbsp; 表示初始化一个列向量为&nbsp;或者 Vector2f myvector(1.0,2.0); 表示初始化一个列向量为 向量能这样初始化，但Matrix就不行了，比如Matrix3f a(3,3)虽然编译能够通过，不会报错，但是这样的传递参数是无效的， 在官方文档有解释：In order to offer a uniform API across fixed-size and dynamic-size matrices, it is legal to use these constructors on fixed-size matrices, even if passing the sizes is useless in this case. 意思是：为了在固定大小和动态大小的矩阵上提供统一的API，在固定大小的矩阵上使用这些构造函数是合法的，即使在这种情况下传递大小是无用的。 所以只能使用规定的输入方法： Matrix3f a; a&lt;&lt;1,2,3, &nbsp; &nbsp; &nbsp; &nbsp;4,5,6, 7,8,9; 说完静态矩阵，接下来说动态矩阵：typedef Matrix &lt;double,Dynamic,Dynamic&gt; MatrixXd; 看如下对比即可明白： 一般Matrix4f mymatrix; 等价于 float mymatrix[16];一般MatrixXf mymatrix(rows,columns); 等价于 float *mymatrix = new float[rows*columns]; 所以有 MatrixXf a(2,2) 即定义一个2x2的矩阵，而且Eigen库有访问矩阵中值的特定方式。 如，&nbsp; 访问第一行第一个元素 即 a(0,1) ,也可 a(0,1) = x 为第一行第一个元素赋值。 如： 123456789101112131415161718#include &lt;iostream&gt;#include &lt;Eigen/Dense&gt;using namespace Eigen;int main()&#123;MatrixXd m(2,2);m(0,0) = 3;m(1,0) = 2.5;m(0,1) = -1;m(1,1) = m(1,0) + m(0,1);std::cout &lt;&lt; &quot;Here is the matrix m:\\n&quot; &lt;&lt; m &lt;&lt; std::endl;VectorXd v(2);v(0) = 4;v(1) = v(0) - 1;std::cout &lt;&lt; &quot;Here is the vector v:\\n&quot; &lt;&lt; v &lt;&lt; std::endl;&#125; Output: 123456Here is the matrix m: 3 -12.5 1.5Here is the vector v:43 像这类动态分配大小的矩阵，有 resize()方法，可以重新定义大小，这篇代码写的很清楚： 1234567891011121314151617#include &lt;iostream&gt;#include &lt;Eigen/Dense&gt;using namespace Eigen;int main()&#123;MatrixXd m(2,5);m.resize(4,3);std::cout &lt;&lt; &quot;The matrix m is of size &quot;&lt;&lt; m.rows() &lt;&lt; &quot;x&quot; &lt;&lt; m.cols() &lt;&lt; std::endl;std::cout &lt;&lt; &quot;It has &quot; &lt;&lt; m.size() &lt;&lt; &quot; coefficients&quot; &lt;&lt; std::endl;VectorXd v(2);v.resize(5);std::cout &lt;&lt; &quot;The vector v is of size &quot; &lt;&lt; v.size() &lt;&lt; std::endl;std::cout &lt;&lt; &quot;As a matrix, v is of size &quot;&lt;&lt; v.rows() &lt;&lt; &quot;x&quot; &lt;&lt; v.cols() &lt;&lt; std::endl;&#125; Output: 1234The matrix m is of size 4x3It has 12 coefficientsThe vector v is of size 5As a matrix, v is of size 5x1 &nbsp;然后说明一下固定尺寸与动态尺寸的选择问题，也就是什么时候静态分配最好，什么时候动态分配最好。 &nbsp;对于非常小的尺寸，尽可能使用Fixed（一般定义为小于等于16），这种情况下使用Fixed尺寸性能更加优越,因为它可以让Eigen避免动态内存分配和展开循环，对于较大尺寸的话就使用dynamic尺寸， &nbsp;当然，使用固定大小的局限性在于，只有在编译时知道大小时才有可能。另外，对于足够大的尺寸，比如说大于或等于32的尺寸，使用固定尺寸的性能优势就变得微不足道了。更糟糕的是，如果试图在函数中使用固定大小创建一个非常大&nbsp; &nbsp;的矩阵，可能会导致堆栈溢出，因为Eigen会尝试将数组作为一个局部变量自动分配，而这通常是在堆栈中完成的。最后，根据不同的情况，当使用动态大小时，Eigen还可以更积极地尝试矢量化（使用SIMD指令）。 &nbsp;最后解释一下上面说过的可选参数模板 123456Matrix&lt;typename Scalar, int RowsAtCompileTime, int ColsAtCompileTime, int Options = 0, int MaxRowsAtCompileTime = RowsAtCompileTime, int MaxColsAtCompileTime = ColsAtCompileTime&gt; 从参数的定义名即可看出来其大概意思。 分析：Matrix&lt;float,Dynamic,Dynamic,0,3,4&gt;&nbsp; 一个不知道大小，但最大行数为3，最大列数为4的矩阵。从官方文档对于Matrix Optional template parameters 的定义来看，这是一个确定了上限的固定内存矩阵，如果在编译时不知道矩阵的确切大小，但在编译时可以知道一个固定的上限，这样做可以避免动态内存分配。 第三个参数是什么意思呢，在我看来是一个优先级的参数，比如一个矩阵是行优先还是列优先就是使用这个参数，0一般是默认值，不设置任何优先。 比如：Matrix&lt;float,3,3,RowMajor&gt; 就是一个行优先的矩阵。 补充Eigen便利类型定义： Eigen&nbsp;defines the following&nbsp;Matrix&nbsp;typedefs: MatrixNt for Matrix&lt;type, N, N&gt;. For example, MatrixXi for Matrix&lt;int, Dynamic, Dynamic&gt;. VectorNt for Matrix&lt;type, N, 1&gt;. For example, Vector2f for Matrix&lt;float, 2, 1&gt;. RowVectorNt for Matrix&lt;type, 1, N&gt;. For example, RowVector3d for Matrix&lt;double, 1, 3&gt;. Where: N can be any one of&nbsp;2,&nbsp;3,&nbsp;4, or&nbsp;X&nbsp;(meaning&nbsp;Dynamic). t can be any one of&nbsp;i&nbsp;(meaning int),&nbsp;f&nbsp;(meaning float),&nbsp;d&nbsp;(meaning double),&nbsp;cf&nbsp;(meaning complex&lt;float&gt;), or&nbsp;cd(meaning complex&lt;double&gt;). The fact that typedefs are only defined for these five types doesn't mean that they are the only supported scalar types. For example, all standard integer types are supported, see&nbsp;Scalar types.","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"Eigen","slug":"Eigen","permalink":"http://example.com/tags/Eigen/"}]},{"title":"线性代数及其应用(二)","slug":"lial2","date":"2021-03-26T11:00:38.711Z","updated":"2021-03-26T11:05:08.478Z","comments":true,"path":"2021/03/26/lial2/","link":"","permalink":"http://example.com/2021/03/26/lial2/","excerpt":"","text":"¶线性代数及其应用(二) 向量方程 线性方程组的重要性质都可用向量概念与符号来描述。 R2中的向量: 仅含一列的矩阵称为列向量，或简称向量，包含两个元素的向量如下： &nbsp; &nbsp; 其中w1和w2是任意实数，所有两个元素的向量集记为R2，R表示向量中的元素是实数，而指数2表示每个向量包含两个元素.&nbsp; 给定R2中两个向量u和v，它们的和u+v是把u和v对应元素相加所得的向量，如 \\begin{bmatrix} 1\\\\ -2\\\\ \\end{bmatrix} + \\begin{bmatrix} 2\\\\ 5\\\\ \\end{bmatrix} = \\begin{bmatrix} 1+2\\\\ -2+5\\\\ \\end{bmatrix} = \\begin{bmatrix} 3\\\\ 3\\\\ \\end{bmatrix} 给定向量u和实数c,u与c的标量乘法（或数乘）是把u的每个元素乘以c,所得向量记为cu，例如： 若;, c = 5,则 &nbsp; &nbsp; &nbsp; &nbsp; cu = 5\\begin{bmatrix} 3\\\\ -1\\\\ \\end{bmatrix} = \\begin{bmatrix} 15\\\\ -5\\\\ \\end{bmatrix} &nbsp;R2的几何表示 考虑平面上的直角坐标系，因为平面上每个点由实数的有序对确定，所以可把几何点(a,b) 与列向量等同，因此我们可把R2看作平面上所有点的集合 &nbsp;&nbsp; &nbsp; 两个向量的和的几何意义 R3中的向量 Rn中的代数性质 （对Rn中一切向量u,v,w以及标量c和d）： 1. u + v = v + u 2.(u+v)+w = u+(v+w) 3.(u+0)=0+u=u 4.u+(-u) = -u+u =0 5.c(u+v)=cu+cv 6.(c+d)u=cu+du 7.c(du)=(cd)u 8.1u=u 线性代数的一个主要思想是研究可以表示为某一个固定向量集合{v1,v2,....vp}的线性组合的所有向量 Span{v} 与 Span{u,v}的几何解释 设v是R3中的向量，那么Span{v}就是v的所有标量倍数的集合，也就是R3中通过v和0的直线上所有点的集合 &nbsp; 若u和v是R3中的非零向量，v不是u的倍数，则Span{u,v}是R3中包含u,v和0的平面，特别地，Span{u,v}包含R3中通过u与0的直线，也包含通过v与0的直线，反正就是确定了一个平面。 &nbsp; &nbsp; 蓝色范围在概念上无限扩充。 &nbsp;","categories":[{"name":"数学","slug":"数学","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"线性代数","slug":"线性代数","permalink":"http://example.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"}]},{"title":"线性代数及其应用(一)","slug":"lial1","date":"2021-03-26T10:58:34.458Z","updated":"2021-03-26T11:00:26.140Z","comments":true,"path":"2021/03/26/lial1/","link":"","permalink":"http://example.com/2021/03/26/lial1/","excerpt":"","text":"¶线性代数及其应用(一) 线性方程组： 包含变量x1,x2，&hellip;&hellip;，xn的线性方程是形如 a1x2 +a2x2+...+a3x3&nbsp; = b&nbsp; 的方程，其中b与系数a1&nbsp; &nbsp;，a2&nbsp;&nbsp;，&hellip;&hellip; ，an是实数或者复数，通常是已知数，下标n可以是任意正整数。 线性方程组的解有下列三种情况： ①无解 ②有唯一解 ③有无穷多解 若一个线性方程组有一个解或无穷多个解，则称它是相容的，若它无解，则称它是不相容的。 初等行变换： ①（倍加变换）把某一行换成它本身与另一行的倍数的和 ②（对换变换）把两行对换 ③（倍乘对换）把某一行的所有元素乘以同一个非零数 行变换可以施与任何矩阵，不仅仅是对于线性方程组的增广矩阵，若其中一个矩阵可以经过一系列初等行变换变换成另外一个矩阵，则我们称这两个矩阵是等价的。 若两个线性方程组的增广矩阵是行等价的，则它们具有相同的解集。 行简化与阶梯形矩阵 定义：一个矩阵称为阶梯形（或行阶梯形），则它有已下三个性质： ①每一非零行都在每一零行之上 ②某一行的先导元素所在的列位于前一行先导元素的右边 ③某一先导元素所在列下方元素都是零 一个矩阵称为简化阶梯形，则它满足以下性质： ①每一非零行的先导元素是1 ②每一先导元素1是该元素所在列的唯一非零元素 通常将矩阵变换成简化阶梯形矩阵的过程称为高斯消元法。（计算机程序通常选择一列中绝对值最大的元素作为主元，可以减少舍入误差） 但某些条件下高斯消元法不适用，使用的是部分主元法（列主元高斯消元法） 原因： &nbsp; &nbsp; &nbsp;图片来自：https://www.zhihu.com/question/33862337 部分主元法思想：在进行第k(k=1,2,3...n-1)步消元时，从第k列的akk及其以下的各元素中选取绝对值最大的元素，然后通过行变换将它交换到主元素akk的位置上，再进行消元。","categories":[{"name":"数学","slug":"数学","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"线性代数","slug":"线性代数","permalink":"http://example.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"}]},{"title":"C++关于数据和函数","slug":"C++datafuc","date":"2021-03-26T10:51:03.688Z","updated":"2021-03-26T10:55:26.225Z","comments":true,"path":"2021/03/26/C++datafuc/","link":"","permalink":"http://example.com/2021/03/26/C++datafuc/","excerpt":"","text":"¶C++关于数据和函数 C++关于数据和函数 C语言在设计程序的时候会准备一些数据和函数，函数用来处理你创造的数据，这样会有一些缺点，由于语言没有提供足够的关键字，所以这些数据一定是全局的，所以所有的函数都可以处理这些数据，在后期会造成很大的影响的，所以面向对象语言C++出现了，基本思想是把数据和处理这些数据的函数包装在一起，也就是&ldquo;类&rdquo;，类其实和结构体是差不多的。 类是否涉及指针，一定要特别注意 Class 的 两个经典分类： &middot;Class without pointer member(s) &middot;Class with pointer member(s) C++ program 代码基本形式 &nbsp; &nbsp;.h 头文件 与 .cpp 代码程序 用#include的方法使用头文件，标准库也是类似。 使用自己的写的头文件使用双引号\"\",默认库使用尖括号&lt;&gt; 延伸文件名不一定是.h或.cpp 也可能是.hpp甚至是无延伸名 在不同的平台上可能不同。 Header头文件中的防卫式声明 #ifndef _XXX_&nbsp; &nbsp; &nbsp; &nbsp;//if not define 如果没有被定义（引用）过 #define _XXX_&nbsp; &nbsp; &nbsp; //则执行下列代码直到#endif ... ... #endif&nbsp; //若第一行判定被定义过，则直接跳到#endif 作用是避免多重调用,出现重定义错误！ 比如 我在 Main.cpp 中&nbsp; #include\"op1.h\" #include\"op2.h\" ... ... ... 而在op2.h中 #include\"op1.h\" ... ... ... &nbsp;这样就形成了多重调用，因为op2.h中包含了op1.h，而在Main.cpp中既调用了op2.h也调用了op1.h。 &nbsp;所以要养成写任何一个头文件都要使用#ifndef来避免重定义的习惯。 既然有 #ifndef ，所以也有#ifdef 当在不同平台下编写代码时，由于环境不同，所以要使用的头文件也会不同，这时就可以用到#ifdef 123456#ifdef OS_Win#include &lt;windows.h&gt;#endif#ifdef OS_Linux#include &lt;linux.h&gt;#endif 这样就实现了windows环境下调用windows.h 而Linux环境下则调用linux.h。 Class 的声明（拿complex来举例）： 1234567891011121314class complex&#123;public: complex (double r = 0 , double i = 0 ) //构造函数 : re(r),im(i) &#123;&#125; complex&amp; operator += (const complex&amp;); //重载+= double real() const&#123;return re;&#125; double imag() const&#123;return im;&#125;private: double re,im;&#125;; public: 下的函数或者数据都是可以直接给外界访问的，而private：下的函数或数据只能内部访问。实现数据与函数封装。 class template(模板） 当你使用大量同一种数据类型的变量的时候，突然想改变这些变量的数据类型，那么一条一条代码去改是很难实现的，就比如上面有变量re和im，我想同时改变它们两个的数据类型，首先是变量声明那改成另一种数据类型，但是还有相关函数呢，返回的也是double类型，也需要更改，而且构造函数中传入的参数也是double类型，几乎所有地方都要修改，这样就显得极其麻烦，而且如果想通过不同的情况随时更改无法实现，灵活性也极差。 那么就使用到了&ldquo;模板&rdquo; 12345678910111213141516171819202122template&lt;typename T&gt;class complex&#123;public: complex (T r = 0 , T = 0 ) //构造函数 : re(r),im(i) &#123;&#125; complex&amp; operator += (const complex&amp;); //重载+= T real() const&#123;return re;&#125; T imag() const&#123;return im;&#125;private: T re; T im;&#125;;...主函数...&#123; complex&lt;double&gt; c1(2.5,1.5); complex&lt;int&gt; c1(1,2); ... &#125; 这样就想使用double类型就用double模板，使用int类型就用int模板。灵活性强。 关于 避免头文件重定义的补充： 我们已经知道一种方法 #ifndef 还有一种方法是 #pragma once 那么这两种方法有什么区别呢？ #ifndef 因为要定义宏名，如果出现两个头文件定义的宏名相同的话，可能会导致使用该头文件，但编译器找不到。 #pragma once则由编译器提供保证：同一个文件不会被包含多次。且这个文件是物理上的文件，缺点是如果物理文件被拷贝多次会导致无法避免重定义，且不支持跨平台。 所以两种方法的使用需要根据情况来把握。","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++学习","slug":"C-学习","permalink":"http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"}]},{"title":"C++ 重载","slug":"C++opcz","date":"2021-03-26T10:46:25.415Z","updated":"2021-03-26T10:50:22.917Z","comments":true,"path":"2021/03/26/C++opcz/","link":"","permalink":"http://example.com/2021/03/26/C++opcz/","excerpt":"","text":"¶C++ 重载 操作符就是一种函数，是可以让你重新定义的比如说相加，与其自己写个相加函数 plus(u,v); 将u,v相加，用 \"+\" 号 显得更为方便，可读性更高，所以C++就出现了重载运算符这个功能。并且可以实现将各种你需要的属性相加。 一般来说，重载操作符的对象会有接收者和传递者 1234inline complex&amp;complex::operator += (this,const complex&amp; r)&#123;return __doapl(this,r);&#125; 上面那个this,是不需要写的 比如 complex c1,c2;c1 += c2;c1就是this。代表操作对象中的接收者。所以一般会这么写 1234inline complex&amp;complex::operator += (const complex&amp; r)&#123; //省略了thisreturn __doapl(this,r);&#125; return by reference语法分析传递者无需知道接收者是以什么形式接收 12345678inline complex&amp; __doapl(complex * ths,const complex&amp; r)&#123;...return *ths;&#125;inline complex&amp;complex::operator += (const complex&amp; r)&#123;return __doapl(this,r);&#125; 可以看到 第一个函数明明是 complex&amp; __doapl(...)返回的却是一个value,return *ths, 这里是没有错误的，因为C++有个特性，就是return by reference,一般来说返回一个引用，会比返回一个值快很多，接收者与其接收其值，不如接收它的引用（也就是地址），而且传递者也不需要知道接收者如何接收，这样下来整个程序会快很多，避免了很多转换。complex::operator += (const complex&amp; r) 也是一样，接收的是 c2 的引用，而不需要接收c2的值，直接通过引用去得到它的值，比起创建一个临时空间去转换去获取它的值要快的多。 temp object(临时对象) typename();刚刚说到了return by reference 比传value快，但下面这些情况，是一定不能return by reference的。 1234567&#123;complex c1(2,1);complex c2;c2 = c1 + c2;c2 = c1 + 5;c2 = 7 + c1;&#125; 1234567891011121314151617//对应 c1 + c2inline complexoperator + (const complex&amp; x,const complex&amp; y)&#123;return complex (real(x) + real(y) , imag(x) + imag(y));&#125;//对应 c1 + 5inline complexoperator + (const complex&amp; x,double y)&#123;return complex (real(x) + y , imag(x));&#125;//对应 5 + c1inline complexoperator + (double x,const complex&amp; y)&#123;return complex (x + real(y) , imag(y));&#125; 这里也看出来 + 操作也分很多种不同情况。为什么这里不能传引用呢，可以跟刚才的对比一下，因为刚才我们传引用之后进行 += 操作之后，是将结果直接传给了C1，而现在我们没有一个地方存放结果，如果传引用，函数一结束，直接死亡，就等于什么也没做，所以我们需要一个临时complex对象，去存放结果，再将临时对象的结果返回到 c2 , 这样才是正确的，然后销毁临时对象。 注：typename() 就等于是创建临时变量，像上面的 complex( ... , ... )，也可以是int(7),double(3.65)等等... 最后是关于返回类型的注意事项比如说： 123456789inline complex&amp;complex::operator += (const complex&amp; r)&#123;return __doapl(this,r);&#125;改成：inline voidcomplex::operator += (const complex&amp; r)&#123;return __doapl(this,r);&#125; 会引起什么问题呢如果说是 c1+=c2; 这样依然不会有任何问题，因为c2赋值到c1上（也就是执行__doapl()之后就完成了）不用再管接下来返回的是什么类型了，所以改成void是没有问题的。但如果是 c3 += c2 += c1;呢，当c1 赋值到 c2 上后，c2必须还要以 complex 类型 加到c3身上，如果返回的是void类型，那么是无法加到c3上面的，所以设计上考虑周全一点，还是会以第一种形式设计重载。","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++学习","slug":"C-学习","permalink":"http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"}]},{"title":"C++ stack与heap","slug":"C++stackheap","date":"2021-03-26T09:09:14.141Z","updated":"2021-03-26T09:13:39.539Z","comments":true,"path":"2021/03/26/C++stackheap/","link":"","permalink":"http://example.com/2021/03/26/C++stackheap/","excerpt":"","text":"¶C++ stack与heap stack(栈) heap(堆)Stack,是存在于某作用域(scope)的一块内存空间(memory space).例如当你调用函数，函数本身即会形成一个stack用来放置它所接收的参数，以及返回地址。 在函数本身(function body)内声明的任何变量，其所使用的内存块都取自于上述stack. Heap，或者说system heap,是指由操作系统提供的一块global内存空间，程序可动态分配(dynamic allocated)从中获得若干区块(blocks) 1234567class Complex &#123;...&#125;;...&#123;Complex c1(1,2);// c1所占用的空间来自stackComplex * p = new Complex(3); //Complex(3)是个临时对象，其所占用的空间是以new自heap动态分配而得，并由p指向&#125; stack objects 的生命周期 12345class Complex&#123;...&#125;;...&#123;Complex c1(1,2);&#125; c1便是所谓stack object,其生命在作用域(scope)结束时结束。这种作用域内的object,又称为auto object,因为它会被自动释放。 static local objects 的生命周期 12345class Complex&#123;...&#125;;...&#123;static Complex c2(1,2);&#125; c2便是所谓static object,其生命在作用域(scope)结束时仍然存在，直到整个程序结束. 1234567class Complex&#123;...&#125;;...Complex c3(1,2);int main()&#123;...&#125; c3就是global object,其生命在整个程序结束之后才结束，也可以把它视为一种static object,其作用域是整个程序. heap objects 的生命周期 1234567class Complex&#123;...&#125;;...&#123;Complex* p = new Complex;...delete p;&#125; p所指的是heap object,其生命在它被deleted时结束。 class Complex{...}; ... { Complex* p = new Complex; } 以上出现内存泄露(memory leak)，因为当作用域结束，p所指的heap object仍然存在，但指针p的生命却结束了，作用域之外再也看不到p(也就没机会delete p)了。尽可能避免这种情况。 new:先分配memory，再调用ctor Complex * pc = new Complex(1,2); 三个步骤。编译器转化为： 12345Complex * pc;// operator new是C++中的一个特殊函数，其本质也是调用了malloc分配内存1.void * mem = operator new(sizeof(Complex));2.pc = static_cast&lt;Complex*&gt;(mem); //将mem指针转为Complex类型的指针3.pc-&gt;Complex::Complex(1,2); //构造函数 本质 Complex::Complex(pc,1,2); 这里的pc相当于this,是不可见的 delete: 先调用 dtor,再释放memory 123String * ps = new String(&quot;Hello&quot;);...delete ps; 12String::~String(ps); //析构函数operator delete(ps); //释放内存，operator delete()是C++中的一个特殊函数其内部调用free(ps) array new 一定要搭配 array delete 1234567String * p = new String[3];...delete[] p; //唤起3次dtorString * p = new String[3];...delete p; //唤起1次dtor &nbsp;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++学习","slug":"C-学习","permalink":"http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"}]},{"title":"C++引用小结","slug":"C++refer","date":"2021-03-26T09:05:54.114Z","updated":"2021-03-26T09:08:38.497Z","comments":true,"path":"2021/03/26/C++refer/","link":"","permalink":"http://example.com/2021/03/26/C++refer/","excerpt":"","text":"¶C++引用小结 从之前的博客中有提到，C++有两种特性 return by value&nbsp; &nbsp;and&nbsp; &nbsp;return by reference 一种是返回值，一种是返回引用 并且，在一般情况下，传引用比传值效率更高。 先说说引用是什么，引用用的是&amp;符号，&amp;符号既可以用来当引用，也可以用来当取地址符，只不过使用方法不同。 引用的本质是别名。 引用的基本使用方法是 12int b = 1;int &amp; a = b; 此时a就是b的引用，也就是b的别名，那可能会发现一个问题，我为什么不直接用b，而去特意创建一个别名去使用b呢。 这里去思考一下typedef的作用就知道了。 我们可以用它来接收返回值，并且创建引用 12345678inline complex&amp;__doaml (complex* ths, const complex&amp; r)&#123; double f = ths-&gt;re * r.re - ths-&gt;im * r.im; ths-&gt;im = ths-&gt;re * r.im + ths-&gt;im * r.re; ths-&gt;re = f; return *ths;&#125; 传递者是*ths，是一个&ldquo;实体&rdquo;，而接收者是 complex&amp; , 也就是一个引用，其实这里也可以直接接收值，但如果之后还要使用*ths,这里的用引用接收之后使用，效率会快上很多。 （可以把这整个函数想象成返回了一个 *ths 的引用） 引用和指针是差不多的，因为 T&amp; ... = T* const ...&nbsp; 指针无法改变 const T&amp; ... = const T* const ... 指针无法改变，指针指向的值也无法改变 所以引用就是一个不能改变指向的指针，传递的也是地址。 并且引用能够解决 派生类切割问题。 比如说有两个类 1234567891011121314151617181920212223class person &#123;public: string name; int age;&#125;;class student: public person &#123;public: string classid;//班级名&#125;;...void printattribute(person p)&#123; cout &lt;&lt; p.name; cout &lt;&lt; p.classid;&#125;...//假设student s;printattribute(s); 当派生类对象s 传入到 printattribute()里去后，会切割掉自己原本有的属性，变成一个原原本本的基类，此时将没有classid这个属性。 如果传的是引用，则可以解决这个问题。 12345void printattribute(const person&amp; p)&#123; cout &lt;&lt; p.name; cout &lt;&lt; p.classid;&#125; 这样 p 的行为就和传入到函数的真实类型一致了。","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++学习","slug":"C-学习","permalink":"http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"}]},{"title":"C++组合与继承","slug":"C++zuhejicheng","date":"2021-03-26T08:55:49.033Z","updated":"2021-03-26T08:59:18.739Z","comments":true,"path":"2021/03/26/C++zuhejicheng/","link":"","permalink":"http://example.com/2021/03/26/C++zuhejicheng/","excerpt":"","text":"¶C++组合与继承 组合与继承 Composition(复合)，表示has-a复合关系简单来说，就是一个类中有另外一个类，A类中需要实现的东西，完全可以由B类中的方法来实现的话，就不需要在A类中去写，而直接去调用B类中的方法就行了。 12345678910111213template &lt;class T, class Sequence = deque&lt;T&gt;&gt;class queue&#123;...protected:sequence c; //底层容器public:bool empty() const &#123;return c.empty();&#125;size_type size() const &#123;return c.size();&#125;reference front() &#123;return c.front();&#125;reference back() &#123;return c.back();&#125;void push(const value_type&amp; x) &#123;c.push_back(x);&#125;void pop() &#123;c.pop_front();&#125;&#125;; 因为单向队列类queue中的一些操作完全可以由双端队列类deque中的方法去实现，所以可以在queue类中直接加入底层容器去调用deque中的方法，而不是自己实现，这就是复合。 内存关系： 123456789101112131415161718192021222324template &lt;class T&gt;class queue&#123;protected:deque&lt;T&gt; c;...&#125;;template &lt;class T&gt;class deque&#123;protected:Itr&lt;T&gt; start;Itr&lt;T&gt; finish;T** map;unsigned int map_size;&#125;template &lt;class T&gt;struct Itr&#123;T* cur;T* first;T* last;T** node;....&#125;; 算内存，由内而外，首先看结构体Itr，一个指针4字节，所以sizeof(Itr) = 4*4 =16然后在 class deque中，有两个Itr结构体 加一个指针变量一个整形变量，所以sizeof(deque) = 16 * 2 + 4 + 4 = 40;同理，所以sizeof(queue) = 40; Composition(复合)关系下的构造和析构 构造由内而外Container 的构造函数首先调用 Component 的 default 构造函数，然后才执行自己。 Container::Container(...): Component() {...}; //因为Component的构造函数可能不止一个，编译器不知道调用哪个，所以只会调用缺省构造函数，除非自己指定参数。 析构由外而内Container 的析构函数首先执行自己，然后才调用Component的析构函数 Container::~Container(...){... ~Component()}; 组装都是由内而外的，拆开肯定只能由外而内。 Delegation(委托).Composition by reference;委托其实跟复合很像，说实在点也就是定义上有点区别。不过委托就是Composition(复合) by reference，看这个应该就能明白了。 ¶12345678910111213//file String.hppclass StringRep;class String&#123;public:String();String(const char * s);String(const String&amp; s);String &amp;operator = (const String&amp; s);~String();....private:StringRep * rep; &#125;; 1234567891011121314//file String.cpp#include&quot;String.hpp&quot;namespace &#123;class StringRep&#123;friend class String;StringRep(const char * s);~StringRep();int count;char * rep;&#125;;&#125;String::String()&#123;...&#125;... 通过调用 StringRep指针来获取到字符串\"Hello\"，通过下图就很明显能够看出。 &nbsp; &nbsp; &nbsp; 这种模式的优点就是无论你怎么修改StringRep 对客户所需要看到的Hello都不影响，甚至可以更换委托对象。维护和更新起来特别方便。可以说这两者之间就是 Handle 与 Body 的关系。 Inheritance(继承) ,表示is-a struct _List_node_base { _List_node_base* _M_next; _List_node_base* _M_prev; }; template&lt;typename _Tp&gt; struct _List_node :public _List_node_base { _Tp _M_data; }; 语法上继承有3种方法，最常用的就是 :public ...其实struct和class是非常相似的，所以这里拿struct举例，继承是is-a的关系继承在面向对象中的概念来说，就是父类与子类，比如说人类分男人，女人，人类是父类，男人与女人是子类。拥有父类-人类的属性的同时，多了自己的属性。 构造由内而外 Derived 的构造函数首先调用Base的 default 构造函数，然后才执行自己。 Deruved::Derived(...) : Base() {...}; 析构由外而内Derived 的析构函数首先执行自己，然后才调用Base的析构函数。 Derived::~Derived(...){...~Base()}; 注意：base class 的 dtor必须是virtual,否则会出现 undefined behaviod养成习惯，每当创建的类有可能会作为基类衍生子类时，最好把这个类的析构函数设为虚函数(virtual)","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++学习","slug":"C-学习","permalink":"http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"}]},{"title":"C++虚函数与多态","slug":"C++vir2","date":"2021-03-26T08:52:43.991Z","updated":"2021-03-26T08:55:21.783Z","comments":true,"path":"2021/03/26/C++vir2/","link":"","permalink":"http://example.com/2021/03/26/C++vir2/","excerpt":"","text":"¶C++虚函数与多态 C++ 虚函数与多态 Inheritance(继承)with virtual functions(虚函数) non-virtual函数：你不希望derived class 重新定义(override,覆写)它它已有默认定义。 pure virtual函数：你希望derived class 一定要重新定义(override,覆写)它，你对他没有默认定义。 1234567891011class Shape&#123;public:virtual void draw() const = 0; // pure virtualvirtual void error(const std::string&amp; msg); // impure virtualint objectID() const; // non-virtual...&#125;;class Rectangle:public Shape&#123;...&#125;;class Ellipse:public Shape&#123;...&#125;; 形状为基类，子类为矩形，椭圆形，error()是打印错误信息的函数，那么设为虚函数的意义是，也许在子类中，我们不同的形状需要打印不同的错误信息，更为精确的错误信息的话，那么我们就可以在子类中去覆写error()函数，这样，在调用error()函数的时候调用的就是对应子类中的error()函数，那么draw()与error()有什么区别呢，可以看到 error()中是有默认操作的， const std::string&amp; msg , 而draw()中是没有任何操作的(一般在函数原型后面加\"=0\"就意味着纯虚函数)，这就是纯虚函数，如果父类中的一个函数为纯虚函数的话，那么这个函数是必须在子类中去覆写的。 Inheritance(继承) with virtualTemplate Method 模板方法 CDocument:: OnFileOpen() { ... Serialize() ... }; 12345class CMyDoc:public CDocument&#123;virtual Serialize()&#123;...&#125;&#125;; main() { CMyDoc myDoc; ... myDoc.OnFileOpen(); } 模板方法具体就是定义一个模板结构，将具体内容延迟到子类去实现。（基于\"继承\"）在main中，我们通过子类对象myDoc调用父类中的函数OnFileOpen(),打开一个文件，进入到OnFileOpen()中，首先执行了打开所有文件都需要进行的操作，然后具体打开操作需要在Serialize()中实现，但每个应用如何打开只有对应的应用才知道，所以在子类中覆写 Serialize()方法，这样在OnFileOpen()中的Serialize()调用的其实是子类中的Serialize()方法，灵活性也大大提高了。 模拟过程 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;class CDocument&#123;public:void OnFileOpen()&#123;//每个cout 输出代表一个实际动作cout &lt;&lt; &quot;dialog...&quot; &lt;&lt;endl;cout &lt;&lt; &quot;check file status...&quot; &lt;&lt;endl;cout &lt;&lt; &quot;open file...&quot;&lt;&lt;endl;Serialize();cout &lt;&lt; &quot;close file...&quot; &lt;&lt;endl;cout &lt;&lt; &quot;update all views...&quot;&lt;&lt;endl;&#125;virtual void Serialize() &#123;&#125;;&#125;;class CMyDoc: public CDocument&#123;public:virtual void Serialize()&#123;//只有应用程序知道如何读取自己的文件格式cout &lt;&lt; &quot;CMyDoc::Serialize()&quot; &lt;&lt;endl;&#125;&#125;;int main()&#123;CMyDoc myDoc; //假设对应[File/Open]myDoc.OnFileOpen();&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++学习","slug":"C-学习","permalink":"http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"}]},{"title":"C++复合与继承下的ctor和dtor顺序","slug":"C++ctordtor","date":"2021-03-26T08:50:28.927Z","updated":"2021-03-26T08:51:57.932Z","comments":true,"path":"2021/03/26/C++ctordtor/","link":"","permalink":"http://example.com/2021/03/26/C++ctordtor/","excerpt":"","text":"¶C++复合与继承下的ctor和dtor顺序 了解到复合关系与继承关系，我们知道了复合关系下：先构造内部，再构造外部 继承关系下：先构造父类，再构造子类 那么在既有复合关系，又有继承关系的情况下，构造与析构的顺序分别是怎样呢，基于这个问题，写一段简单的代码观察。 ¶12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;class A &#123;public: A() &#123; cout &lt;&lt; &quot;A&quot;; &#125; ~A() &#123; cout &lt;&lt; &quot;A&quot;; &#125;&#125;;class B &#123;public: B() &#123; cout &lt;&lt; &quot;B&quot;; &#125; ~B() &#123; cout &lt;&lt; &quot;B&quot;; &#125;&#125;;class C : public A &#123;protected: B b;public: C() &#123; cout &lt;&lt; &quot;C&quot;; &#125; ~C() &#123; cout &lt;&lt; &quot;C&quot;; &#125;&#125;;int main() &#123; C * c = new C(); cout &lt;&lt; endl; delete c; system(&quot;pause&quot;); return 0;&#125; 运行结果如下： ABC CBA 可知，在复合关系与继承关系同时存在时，先构造父类，再去构造派生类以及它的内部类，而析构顺序则与构造顺序刚好相反。 补充一下类对象的创建与释放过程： 详细说明：https://blog.csdn.net/m0_37622246/article/details/99681188 类的创建过程 1、从堆栈中分配类所需要的空间。2、根据需求传递或不传递参数调用构造函数，完成如下任务： ①根据继承表依次调用父类的构造函数。 ②根据成员变量的顺序依次调用成员变量的构造函数。 ③执行构造函数体中的代码。 注意：执行构造函数的代码是整个构造函数的最后一步，要保证构造函数代码所需要的一切资源和先决条件在该代码执行前已经准备充分，并得到正确的初始化。 类的释放过程 析构函数负责释放在构造函数期间获取的所有资源，它的执行过程： ①先执行析构函数本身代码 ②调用成员类的析构函数 ③调用父类的析构函数 如果一个类没实现析构函数，编译器会自动生成一个具有析构功能的二进制指令，它负责释放编译器能够看得到的资源（成员变量、类成员、父类成员），这就是缺省析构。 如果类中没有动态资源，也不需要做善后工作，缺省析构就完全够用了，不需要再定义新析构函数。注意：缺省析构无法释放动态资源（堆内存）。","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++学习","slug":"C-学习","permalink":"http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"}]},{"title":"Composite模式与Prototype模式","slug":"C++design","date":"2021-03-26T08:44:28.650Z","updated":"2021-03-26T08:48:42.731Z","comments":true,"path":"2021/03/26/C++design/","link":"","permalink":"http://example.com/2021/03/26/C++design/","excerpt":"","text":"¶Composite模式与Prototype模式 这两种模式都是基于 Delegation(委托) + Inheritance(继承)&nbsp; 而来的， 首先讲一下Composite模式，也就是组合模式，是一个经典的设计模式。 组合模式是什么？ 组合模式是指将对象组合成树形结构以表示\"部分-整体\"的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。 假如我们面临一个场景，需要做一个文件类，那么我们知道，打开一个文件，文件既可以是文件夹，也可以是单体文件，为了便于识别，个体文件我们叫做Primitive,文件夹我们叫做Composite，由于文件夹里可以存放Primitive，也可以再存放Composite，形成一个递归结构，如果消耗时间去进行if-else判断显得愚钝并且效率极低，而且用户不管你如何设计，文件夹和文件如果都能当做一种东西来操作的话，是最好不过的，组合模式的目的就是让用户不再区分操作的是组合对象还是个体对象，而是以一个统一的方式来操作，实现这个目标的关键点就是设计一个抽象的基类，让它既可以代表组合对象也可以代表个体对象，这样一来，用户就不需要区分这两种对象了，只需要全部通过Compostie对象进行统一操作就行了。 （其实文件系统就是组合模型的典型应用） &nbsp; 伪代码实现模拟： ¶12345class Primitive:public Component&#123;public: Primitive(int val):Component(val)&#123;&#125;&#125;; ¶1234567class Component&#123; int value;public: Component(int val)&#123;value = val;&#125; virtual void add(Component*)&#123;&#125;&#125;; 1234567891011class Composite: public Component&#123; vector&lt;Component*&gt; c;public: Composite(int val):Component(val)&#123;&#125; void add(Component* elem)&#123; c.push_back(elem); &#125;...&#125;; 这样Composite类 通过父类指针既能接收primitive类也能接收自己。 通过下面代码就可以更加清晰看出来： ¶1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;class Component &#123; int value;public: Component() &#123; &#125; virtual void add(Component*) &#123;&#125;; virtual void print(string path) &#123; cout &lt;&lt; &quot;&quot;; &#125;;&#125;;class Composite : public Component&#123; string name; vector&lt;Component*&gt; c;public: Composite(string str) :Component() &#123; name = str; &#125; void add(Component* comp) &#123; c.push_back(comp); &#125; void print(string path) &#123; vector&lt;Component*&gt;::iterator it = c.begin(); for (; it != c.end(); it++) &#123; Component * comp = *it; string ss = path + &quot;\\\\&quot; + name; comp-&gt;print(ss); delete comp; &#125; &#125;&#125;;class Primitive : public Component &#123; string name; int size;public: Primitive(string str) :Component() &#123; name = str; &#125; void print(string path) &#123; cout &lt;&lt; path &lt;&lt; &quot;\\\\&quot; &lt;&lt; name &lt;&lt;endl; &#125;&#125;;int main() &#123; cout &lt;&lt; &quot;创建目录中...&quot; &lt;&lt; endl; Composite * rootdir = new Composite(&quot;root&quot;); Composite * dis_o = new Composite(&quot;cdcd&quot;); Composite * dis_s = new Composite(&quot;asda&quot;); rootdir-&gt;add(dis_o); rootdir-&gt;add(dis_s); dis_o-&gt;add(new Primitive(&quot;file1&quot;)); dis_s-&gt;add(new Primitive(&quot;file2&quot;)); cout &lt;&lt; &quot;输出目录&quot; &lt;&lt; endl; rootdir-&gt;print(&quot;cmd:&quot;); cout &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 输出结果： 看得出来我们只需要对Composite类进行操作，就又可以存放自己，又可以存放Primitive类，这就是组合模式的便利之处了。 接下来说Prototype模式，也就是原型模式，这个模式强大之处在于它能够在你不知道你以后要设计什么类的情况下，获取一个这个类的副本，实现一系列操作。 假如我们设计了一个框架，我们不知道以后使用人员会写入什么派生类，也总不可能去用string获取类名创建，这样是不符合C++编译标准的，那么此时就要用Prototype模式了，利用使用人员写的子类自己创建自己，然后传到自己的框架基类，获取一个副本，以实现对子类对象的操作。 如下图： &nbsp; &nbsp;下划线代表静态变量，-是私有类型，#是保护类型 假如上面的Image类是我们自己写的，但是我们写的时候并没有LandSatImage类与SpotImage类，这些类有可能是在交付到客户手上，客户自己写的，那么我们如何去用我们自己的类来实现构造当时并不存在的类呢。 可以看到 LandSatImage类，创建了一个静态的自己，那么此时，一定会调用本身的构造函数 LandSatImage(),可以看到构造函数中有addPrototype(this); 这个是父类中的一个静态函数，作为子类是可以直接调用的，这么做是为了把自己传到父类去，传完之后那么现在就全部完成了吗？还没有，此时相当于（粗略理解） 我把自己的类的指针给了父类，然后父类拿到现在这个类的指针后，保存到prototypes[]中，还要利用这个指针创建一个实例化对象，才算真正的使用，clone()的作用就是返回一个实例化对象，上图描写的很清楚，return new LandSatImage, 那么上面的 prototypes[i]-&gt;clone() 其实就相当于 LandSatImage a = new LandSatImage();所以我们获得了一个实例化对象，就可以对他进行操作了，还要注意一个很重要的点，可以看到LandSatImage中有两个构造函数，那么作用是什么呢，因为prototypes[i]-&gt;clone()调用了LandSatImage中的clone()函数，然后return new LandSatImage;此时因为创建了一个LandSatImage对象，所以还会调用构造函数，那么如果只有第一个构造函数的话，就会套娃，无限addPrototype(this); 所以用第二个构造函数，加一个数字，这样就会避免调用第一个构造函数，所以其实是在clone()函数中应该写return new LandSatImage(1);（任何数字都行）这样就不会再次调用第一个构造函数了。 实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;using namespace std;enum ImageType &#123; LSAT,SPOT&#125;;class Image&#123;public: virtual void draw() = 0; static Image *findAndClone(ImageType);protected: //规定子类必须实现clone()函数 virtual Image * clone() = 0; //获得子类的文件格式 virtual ImageType returnType() = 0; static void addPrototype(Image * image) &#123; _prototypes[_nextSlot++] = image; &#125;private: static Image * _prototypes[10]; static int _nextSlot;&#125;;Image * Image::_prototypes[];int Image::_nextSlot;Image * Image::findAndClone(ImageType type)&#123; for (int i = 0; i &lt; _nextSlot; i++) //保证副本格式正确 if (_prototypes[i]-&gt;returnType() == type) return _prototypes[i]-&gt;clone();&#125;class LandSatImage :public Image&#123;public: //返回当前文件格式 ImageType returnType() &#123; return LSAT; &#125; void draw() &#123; cout &lt;&lt; &quot;LandSatImage::draw&quot; &lt;&lt; _id &lt;&lt; endl; &#125; //创建对象 Image * clone() &#123; return new LandSatImage(1); &#125;protected: LandSatImage(int dummy) &#123; _id = _count++; &#125;private: static LandSatImage _landSatImage; LandSatImage() &#123; addPrototype(this); &#125; int _id; static int _count;&#125;;LandSatImage LandSatImage::_landSatImage;int LandSatImage::_count = 1; 以上就是个人对两种模式一点理解。","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++学习","slug":"C-学习","permalink":"http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"}]},{"title":"Conversion function 转换函数","slug":"C++cvfunc","date":"2021-03-26T08:37:57.084Z","updated":"2021-03-26T08:42:47.288Z","comments":true,"path":"2021/03/26/C++cvfunc/","link":"","permalink":"http://example.com/2021/03/26/C++cvfunc/","excerpt":"","text":"¶Conversion function 转换函数 Conversion function个人理解为是一个跟重载配合使用的重要结构，我们经常会对一些对象进行类型转换，比如把一个Double类型转为Int类型，或是float类型转Double类型，那么当我们构建自己的类的时候，我们希望当它与某种类型进行相加相减之类的操作时，能够自动将自己转换为对应的类型，亦是将另外一种类型转换成跟自己相同的类型，然后进行你设定好的操作。 一般来说，设定这种转化函数，必须是符合逻辑的，不能随意改变，否则会对程序整体造成不好的影响。 就拿分数类来进行解释。 1234567891011class Fraction &#123;public: Fraction(int num,int den = 1):m_numerator(num),m_denominator(den)&#123;&#125; operator double() const &#123; return (double)m_numerator / m_denominator; &#125;private: int m_numerator; // 分子 int m_denominator; //分母&#125;; 比如上面的代码，我们分数类有两个属性，一个分子，一个分母，且都是int类型，那么假如，我们想把这个分数类的对象与某个整数，或者是浮点数相加，那么该怎么做呢，比如下面这个操作： 123456int main()&#123;Fraction f(3, 5);double d = 4 + f;...&#125; 很明显，我们想要得到的结果是 3/5 + 4的结果，可是 4 是一个整形，而f是你自己构建的类的对象，两种完全不相同的东西，如何相加呢。 可以再回到我们最上面那一段代码： 123operator double() const &#123; return (double)m_numerator / m_denominator; &#125; 可能之前对重载有些许过了解的人，会对这段代码产生疑惑，一般是重载一个运算符，那么operator double() 是什么意思呢，其实很简单，意思就是，当对象与其他类型的变量进行运算时，编译器会先找你的类里面，有没有相关的设定，可以让你的对象变为一个类型并且能够符合当前的状况，比如运行到 double d = 4 + f;这里，编译器就开始找你的Fraction类里有什么可以使用的类型，operator double()就是表示，我这个类的对象，可以作为一个double类型使用，并且作为double类型使用时，应该变成一个什么样的double值，很明显，一个分数如何变成double值，当然是分子除以分母。 好了，那么新的问题又来了，万一它其中有多个重载类型呢，那将会发生什么。 12345678910111213class Fraction &#123;public: Fraction(int num,int den = 1):m_numerator(num),m_denominator(den)&#123;&#125; operator double() const &#123; return (double)m_numerator / m_denominator; &#125; operator int() const &#123; return (int)m_numerator / m_denominator; &#125;private: int m_numerator; // 分子 int m_denominator; //分母&#125;; 看到这段代码，我们发现，又多了一个operator int()，最开始说了，C++能处理的，都会自己处理，因为遇到的都是它觉得是这样，或者只能是这样的状况，那么当前这种情况下， 它再次遇到 double d = 4 + f;时，它找你的类中相应的转换函数，发现既可转换成 double，也可以转换成int,而且这两个都能与4相加，C++并不知道你到底想要f以什么样的类型面对这个4，所以就会报错。 遇到这种状况很简单，要么你告诉编译器你想做什么，要么就把可能性排掉只剩下一种（逻辑正确性就体现在这，如果逻辑思路正确，一般是不会分出很多种情况）。 我们当然可以告诉编译器我们想做什么，只需要： 123456int main()&#123;Fraction f(3, 5);double d = 4 + (int)f;...&#125; 或者 123456int main()&#123;Fraction f(3, 5);double d = 4 + (double)f;...&#125; 这样编译器就知道你想要f以什么样的姿势面对这个整形变量了。 我们也能得到想要的值。 那么Fraction类对象能转化为其他的类型，那么是否能将这个\"4\"转换为Fraction类型呢，答案是可以的. non-explicit-one-argument ctor 看下面这一段代码： 1234567891011class Fraction &#123;public: Fraction(int num,int den = 1):m_numerator(num),m_denominator(den)&#123;&#125; Fraction operator+ (const Fraction&amp; f) &#123; return Fraction(...); &#125;private: int m_numerator; // 分子 int m_denominator; //分母&#125;; 此时再遇到&nbsp; Fraction f(3,5); Fraction d2 = f + 4; 会如何，我们想得到一个Fraction类的对象，并且得到相应的值，是f + 4,此时应该怎么做，很明显，我们应该把4变成Fraction类，理所当然4就是 4/1，所以在 operator+ 中，我们直接调用构造函数，创建并返回一个分子为4，分母为1的Fraction类对象，因为Fraction(int num,int den = 1)可以看出，构造函数分母初始化为1,传值为4会赋值给num，所以得到4/1,具体相加的操作可以继续在重载函数中实现，这里就不具体操作了。 刚刚可以看到上面有个non-explicit-one-argument ctor ，这是什么意思呢，其实就是构造函数是非explicit类型，explicit是用来干什么的，之前说了，编译器觉得你想要干什么，会帮你去做，不加explicit就是让编译器能干就干，如果加上explicit就是让编译器不要去揣测，放这别去碰这个构造函数。 由于我们之前没有加explicit,所以当你把4变成一个Fraction类对象时，编译器看到分母den = 1 有初始值，所以会把4当做没有初始值的num,并调用构造函数。 而如果我们加上explicit,编译器就不会做这个动作，并且也我们也就无法实现上面那个操作了。 这里可以用两个例子来说明： 12345678910111213class Fraction &#123;public: Fraction(int num,int den = 1):m_numerator(num),m_denominator(den)&#123;&#125; operator double() const &#123; return (double)m_numerator / m_denominator; &#125; Fraction operator+ (const Fraction&amp; f) &#123; return Fraction(...); &#125;private: int m_numerator; // 分子 int m_denominator; //分母&#125;; 比如说这串代码，当它遇到&nbsp; Fraction f(3,5); Fraction d2 = f + 4; 它也是无法执行的，因为编译器不知道你是要将4转为Fraction类，还是要将f转为double型，编译器就会报错： Error:ambiguous 而如果你加上 explicit ，也就是 12345678910111213class Fraction &#123;public: explicit Fraction(int num,int den = 1):m_numerator(num),m_denominator(den)&#123;&#125; operator double() const &#123; return (double)m_numerator / m_denominator; &#125; Fraction operator+ (const Fraction&amp; f) &#123; return Fraction(...); &#125;private: int m_numerator; // 分子 int m_denominator; //分母&#125;; 此时，编译器就不会把 4 变为 4/1 了，因为编译器不会去揣测你的意思了，它不会去调用这个构造函数去把4变成4/1，然后由于我们要得到的d2 是 Fraction类型的，f变为double类型与4相加，会出现什么情况， 想象一样 Fraction d2 = 4.6 ;&nbsp; 这样能行吗，肯定不行，所以我们会看到这种报错： Error:conversion from \"double\" to \"Fraction\" requested 以上就是对Conversion function转换函数的一点粗略理解。","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++学习","slug":"C-学习","permalink":"http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"}]},{"title":"C++仿函数与仿指针","slug":"C++pointerfunc","date":"2021-03-26T08:31:45.077Z","updated":"2021-03-26T08:36:59.750Z","comments":true,"path":"2021/03/26/C++pointerfunc/","link":"","permalink":"http://example.com/2021/03/26/C++pointerfunc/","excerpt":"","text":"¶C++仿函数与仿指针 首先说明一下仿指针与仿函数是什么，指针我们知道是一个地址，我们可以利用指针来访问它所指向的value，仿指针就是用一个类去实现指针的作用，那么我们为什么要特地写一个类去实现指针呢，因为在我们开发过程中，我们希望指针可以有更多功能，而不仅仅是指向一个地址，那么我们就可以通过一个类去实现指针的功能的前提下，给它加上更多的功能，来满足我们的需求，比如说我们每使用一次指针，都要去释放掉这个指针，如果忘记释放，就会造成内存泄露，但我们无法使指针自己释放，但是如果是指针类，我们就可以在析构函数中加上delete语句，那么以后使用这个指针，就再也不用管它的释放问题了，C++特性中的智能指针其实就是这种原理，仿函数也是类似道理。 _ pointer-like classes 简单用代码实现一个智能指针，其实就是老版本的shared_ptr指针，可以明白其中的运作原理 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;using namespace std;template&lt;class T&gt;class shared_ptrc &#123;public: T&amp; operator*() const &#123; return *px; &#125; T* operator-&gt;() const &#123; return px; &#125; shared_ptrc(T* p) : px(p)&#123;&#125; ~shared_ptrc() &#123; delete px; &#125;private: T* px; long* pn;&#125;;struct Foo&#123; void method() &#123; cout &lt;&lt; &quot;Foo::method&quot; &lt;&lt; endl; &#125;&#125;;int main() &#123; shared_ptrc&lt;Foo&gt; sp(new Foo); Foo f(*sp); sp-&gt;method(); system(&quot;pause&quot;); return 0;&#125; 首先从它的重载说起， 可以看到 T&amp; operator*() const { return *px; } 重载了*号，并且无参数，这样就符合了指针的语法，我们平常建立一个指针比如int * p;&nbsp; *p代表就是它所指的value,再看这里，返回 *px,而px又是T类的指针(T * px),所以这里就是返回一个value，并且函数开头是T&amp;, 之前说了返回value的reference比直接返回value普遍要快很多，所以这里返回了一个reference。 我们再看 T* operator-&gt;() const { return px; } 当我们使用\"-&gt;\"时，是不是一般都是调用指针所指内容的方法或者属性，所以我们必须要返回指针类型，所以这里是 T* operator-&gt;() ,（如果这里不明白可以看之前说的引用与指针的区别） 所以现在来看，我们是不是就可以把shared_ptrc当作一个指针类型来使用了 shared_ptrc&lt;Foo&gt; sp(new Foo); 这样就是导入Foo模板，并且new一个Foo类对象，让shared_ptrc类中的px指针指向它，然后当我们使用完这个指针后，程序结束后，它会调用析构函数自动销毁，无需手动释放，这就是仿指针的基本用法。 迭代器其实也是一种仿指针，平常使用迭代器我们都有接触过，比如创建一个vector数组的迭代器，vector&lt;int&gt;::iterator it;我们经常会使用这种语法 it++,++it,使迭代器指针指向数组中的下一个内容，这其实就是在指针类中重载了++符号来实现的。 为了更加了解仿指针，我们可以看一看C++的智能指针，这样也能使我们对使用指针的风险更加了解。 有4种智能指针：auto_ptr(C++11已弃用), unique_ptr,shared_ptr, weak_ptr&nbsp; 首先看看智能指针为我们解决的问题，其实跟上面所说的基本一样。 当我们使用普通指针时： 1234567891011void func(string &amp; str)&#123; ... string * s = new string(str); if (error()) throw exception(); str = *s; delete s; ... return;&#125; 当程序出错，抛出异常，可以很明显看到发生了一个严重的问题，s指针未被释放，程序就中止了，导致内存泄露。 而我们如果使用智能指针auto_ptr 12345678910void func(string &amp; str)&#123; ... auto_ptr&lt;string&gt; s(new string(str)); if (error()) throw exception(); str = *s; ... return;&#125; 程序抛出异常，auto_ptr会调用内部析构函数，释放掉指针，这样就避免了内存泄漏。 然后说一下为什么auto_ptr会被抛弃，auto_ptr的工作模式是拥有所有权。对于特定的对象，只能有一个智能指针可拥有，这样只有拥有对象的智能指针的析构函数会删除该对象。赋值操作会转让所有权。 可以看下面这一串代码： 123456789101112131415161718#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; auto_ptr&lt;string&gt; test[3] = &#123; auto_ptr&lt;string&gt; (new string(&quot;helloworld1&quot;)), auto_ptr&lt;string&gt; (new string(&quot;helloworld2&quot;)), auto_ptr&lt;string&gt; (new string(&quot;helloworld3&quot;)), &#125;; auto_ptr&lt;string&gt; p; p = test[2]; // test[2]所有权被p拿走，此时test[2]为一个空指针。 cout&lt;&lt;test[2]&lt;&lt;endl; //运行时报错 return 0;&#125; 可以看出auto_ptr存在内存泄漏的潜在风险，所以不再使用auto_ptr，unique_ptr也是所有权模式，但是如果将上面auto_ptr换成unique_ptr的话，不会在运行程序时报错，而是会在编译时报错，这样也可以避免内存泄漏的潜在风险。 shared_ptr与weak_ptr则是另外一种模式，这里就不详细说明了，以后专门再用一篇博客描述4种智能指针。 _ function-like classes 仿函数也是用一个模板类去实现的，实现原理与仿指针差不多，由于目前不经常使用，了解不是很深，就先把代码语法问题解决了，以后再补充说明仿函数的使用环境与时机。 1234567891011121314151617181920212223242526272829template &lt;class T&gt;struct identity&#123; const T&amp; operator() (const T&amp; x) const &#123;return x;&#125;&#125;;template &lt;class Pair&gt;struct select1st &#123; const typename Pair::first_type&amp; operator() (const Pair&amp; x) const &#123; return x.first;&#125;&#125;;template &lt;class Pair&gt;struct select2nd &#123; const typename Pair::second_type&amp; operator() (const Pair&amp; x) const &#123; return x.second;&#125;&#125;;template &lt;class T1,class T2&gt;struct pair&#123; T1 first; T2 second; pair() : first(T1()),second(T2())&#123;&#125; pair(const T1&amp; a, const T2&amp; b) : first(a),second(b) &#123;&#125;...&#125;; 可以看到select1st与select2nd可以当作函数来使用，分别返回pair的两个value。 &nbsp;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++学习","slug":"C-学习","permalink":"http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"}]},{"title":"C++虚成员函数与动态联编","slug":"C++vir1","date":"2021-03-26T08:25:14.590Z","updated":"2021-03-26T08:37:04.449Z","comments":true,"path":"2021/03/26/C++vir1/","link":"","permalink":"http://example.com/2021/03/26/C++vir1/","excerpt":"","text":"¶C++虚成员函数与动态联编 本篇博客会说明一下虚函数与动态联编的联系，以及虚指针和虚函数表的基本概念。首先了解何为动态联编，何为静态联编。 当程序调用函数时，编译器负责告诉你将使用哪个可执行代码块，将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编。 在C语言中，每个函数名都对应一个不同的函数，所以用谁是谁，一对一，在编译过程就能完成联编，很明显的静态联编。而在C++中，由于函数重载的缘故，就不能简单的一对一去联编了，编译器必须查看函数名以及函数参数才能确定使用哪个函数(在C++中，编译器看到的并不是我们所定义的函数名，我们所定义的每个函数，都有一个函数签名，就算我们函数名相同，但我们参数不同，类型不同，甚至是const与non-const的关系，都会导致函数签名不相同)，不过，这种程度在C/C++编译器中也能够在编译过程完成联编，这种在编译过程完成联编的就叫做静态联编。但C++中有一个东西使得编译器很难在编译阶段确定你要使用哪一个函数，那就是虚函数，因为编译器不知道用户将选择哪种类型的对象，所以，编译器必须生成能够在程序运行时选择正确的虚函数的代码，这种称为动态联编。 接下来观察虚函数与动态联编的联系： 假设我们有基类Baseclass,与子类Derivedclass，基类中有execf()方法。 1234Deriveclass dc;Baseclass * bc;bc = &amp;dc;bc-&gt;execf(); 如果基类中没有将execf()声明为虚方法，则bc-&gt;execf()将会根据指针类型(Baseclass*)调用Baseclass::execf()。指针类型在编译时已知，因此编译器在编译时，将execf()关联到Baseclass::execf()，所以，编译器对非虚方法使用静态联编。 但如果在基类中将execf()声明为虚方法，则dc-&gt;execf()根据对象类型(Deriveclass)调用Deriveclass::execf()，在这个例子中，对象类型为BrassPlus,但通常只有在运行程序时才能确定对象类型。所以编译器生成的代码将在程序执行时，根据对象类型将execf()关联到Baseclass::execf()或者Deriveclass::execf()，所以编译器对虚方法使用动态联编。 接下来说明一下虚指针与虚表（也称虚函数表）。 当我们定义一个类时，并创建一个对象，编译器会给每个对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针，这个指针就是虚指针，这个数组就是虚函数表。虚函数表中存储了为类对象进行声明的虚函数的地址，例如，基类对象包含一个指针，该指针指向基类中所有虚函数的地址表，派生类对象将包含一个指向独立虚表的指针，如果派生类提供了虚函数的新定义，该虚函数表将保存这个重定义虚函数的地址；如果派生类没有重新定义基类虚函数，派生类的虚表将保存函数原始的地址，也就是跟基类中这个虚函数的地址相同（无则不变，有则更新），如果派生类定义了新的虚函数（基类没有的），则该虚函数的地址也将被添加到虚表中。 通过下面的代码和图片就能清晰理解其中的关系了。 123456789101112131415161718192021222324252627282930#ifndef __TEST__#define __TEST__class A &#123;public: virtual void vfunc1(); virtual void vfunc2(); void func1(); void func2();private: int m_data1, m_data2;&#125;;class B :public A &#123;public: virtual void vfunc1(); void func2();private: int m_data3;&#125;;class C :public B &#123;public: virtual void vfunc1(); void func2();private: int m_data1, m_data4;&#125;;#endif 可以看到在B类对象中重新定义了A类中的虚函数vfunc1()，所以在B的虚表中vfunc2的地址从0x401ED0更新为0x401F80,而因为没有重新定义vfunc2(),所以地址仍然是0x401F10，C类对象也是如此。 调用虚函数时，程序查看存储在对象中的vtbl地址，然后转向相应的函数地址表，如果使用类声明中定义的第一个虚函数，则程序将使用数组中的第一个函数地址，并执行具有该地址的函数，如果使用类声明中的第三个函数，程序将使用地址为数组中第三个元素的函数。 在使用虚函数时，在内存和执行速度方面有一定的成本： 每个对象都将增大，增大量为存储地址的空间 对于每个类，编译器都创建一个虚函数地址表（数组） 对于每个函数调用，都需要执行一项额外的操作，即到表中查找地址 虽然非虚函数的效率比虚函数稍高，但不具备动态联编功能。 对于虚析构函数的一些注意事项： 1.构造函数不能是虚函数，创建派生类对象时，将调用派生类的构造函数，而不是基类的构造函数，然后，派生类的构造函数将使用基类的一个构造函数，这种顺序不同于继承机制，因此，派生类不继承基类的构造函数。 2.析构函数应当是虚函数，除非类不用做基类，比如看下面代码： 12345678910111213141516171819202122#include&lt;iostream&gt;using namespace std;class A &#123;public: A() &#123; cout &lt;&lt; &quot;A::ctor()&quot; &lt;&lt; endl; &#125; ~A() &#123; cout &lt;&lt; &quot;A::dtor()&quot; &lt;&lt; endl; &#125;&#125;;class B : public A &#123;public: B() &#123; cout &lt;&lt; &quot;B::ctor()&quot; &lt;&lt; endl; &#125; ~B() &#123; cout &lt;&lt; &quot;B::dtor()&quot; &lt;&lt; endl; &#125;&#125;;int main() &#123; A * p = new B(); delete p; system(&quot;pause&quot;); return 0;&#125; 假如 基类析构函数不是虚函数，当使用A类指针指向一个B类对象时，释放内存时，我们会发现以下结果： &nbsp;B类的析构函数没有被调用，这样会造成严重的影响，因为delete p只删除了A类所拥有的内存空间，并没有释放掉B类对应的内存空间，并且也再也无法访问这片空间，这样就造成了内存泄漏。 那么我们将析构函数设为virtual呢。 12345678910111213141516171819202122#include&lt;iostream&gt;using namespace std;class A &#123;public: A() &#123; cout &lt;&lt; &quot;A::ctor()&quot; &lt;&lt; endl; &#125; virtual ~A() &#123; cout &lt;&lt; &quot;A::dtor()&quot; &lt;&lt; endl; &#125;&#125;;class B : public A &#123;public: B() &#123; cout &lt;&lt; &quot;B::ctor()&quot; &lt;&lt; endl; &#125; ~B() &#123; cout &lt;&lt; &quot;B::dtor()&quot; &lt;&lt; endl; &#125;&#125;;int main() &#123; A * p = new B(); delete p; system(&quot;pause&quot;); return 0;&#125; 可以发现我们成功调用了B类的析构函数。 有关虚函数的注意事项： 如果使用指向对象的引用或指针来调用虚方法，程序将使用为对象类型定义的方法，而不使用为引用或指针类型定义的方法，这称为动态联编，这种行为非常重要，因为这样基类指针或引用可以指向派生类对象。 如果定义的类将被用作基类，则应将那些要在派生类中重新定义的类方法声明为虚方法。","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++学习","slug":"C-学习","permalink":"http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"}]},{"title":"C++ volatlie变量","slug":"C++volatlie","date":"2021-03-26T08:19:13.233Z","updated":"2021-03-26T08:24:31.885Z","comments":true,"path":"2021/03/26/C++volatlie/","link":"","permalink":"http://example.com/2021/03/26/C++volatlie/","excerpt":"","text":"学习专用，转载自github:https://github.com/Light-City/CPlusPlusThings/tree/master/basic_content/volatile 1.volatile 被&nbsp;volatile&nbsp;修饰的变量，在对其进行读写操作时，会引发一些可观测的副作用。而这些可观测的副作用，是由程序之外的因素决定的。 2.volatile应用 （1）并行设备的硬件寄存器（如状态寄存器）。 假设要对一个设备进行初始化，此设备的某一个寄存器为0xff800000。 int *output = (unsigned int *)0xff800000; //定义一个IO端口； int init(void) { int i; for(i=0;i&lt; 10;i++) { *output = i; } } 经过编译器优化后，编译器认为前面循环半天都是废话，对最后的结果毫无影响，因为最终只是将output这个指针赋值为 9，所以编译器最后给你编译编译的代码结果相当于： int init(void) { *output = 9; } 如果你对此外部设备进行初始化的过程是必须是像上面代码一样顺序的对其赋值，显然优化过程并不能达到目的。反之如果你不是对此端口反复写操作，而是反复读操作，其结果是一样的，编译器在优化后，也许你的代码对此地址的读操作只做了一次。然而从代码角度看是没有任何问题的。这时候就该使用volatile通知编译器这个变量是一个不稳定的，在遇到此变量时候不要优化。 （2）一个中断服务子程序中访问到的变量； static int i=0; int main() { while(1) { if(i) dosomething(); } } /* Interrupt service routine */ void IRS() { i=1; } 上面示例程序的本意是产生中断时，由中断服务子程序IRS响应中断，变更程序变量i，使在main函数中调用dosomething函数，但是，由于编译器判断在main函数里面没有修改过i，因此可能只执行一次对从i到某寄存器的读操作，然后每次if判断都只使用这个寄存器里面的&ldquo;i副本&rdquo;，导致dosomething永远不会被调用。如果将变量i加上volatile修饰，则编译器保证对变量i的读写操作都不会被优化，从而保证了变量i被外部程序更改后能及时在原程序中得到感知。 （3）多线程应用中被多个任务共享的变量。 当多个线程共享某一个变量时，该变量的值会被某一个线程更改，应该用 volatile 声明。作用是防止编译器优化把变量从内存装入CPU寄存器中，当一个线程更改变量后，未及时同步到其它线程中导致程序出错。volatile的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值。示例如下： volatile bool bStop=false; //bStop 为共享全局变量 //第一个线程 void threadFunc1() { ... while(!bStop){...} } //第二个线程终止上面的线程循环 void threadFunc2() { ... bStop = true; } 要想通过第二个线程终止第一个线程循环，如果bStop不使用volatile定义，那么这个循环将是一个死循环，因为bStop已经读取到了寄存器中，寄存器中bStop的值永远不会变成FALSE，加上volatile，程序在执行时，每次均从内存中读出bStop的值，就不会死循环了。 是否了解volatile的应用场景是区分C/C++程序员和嵌入式开发程序员的有效办法，搞嵌入式的家伙们经常同硬件、中断、RTOS等等打交道，这些都要求用到volatile变量，不懂得volatile将会带来程序设计的灾难。 3.volatile常见问题 下面的问题可以看一下面试者是不是直正了解volatile。 （1）一个参数既可以是const还可以是volatile吗？为什么？ 可以。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。 （2）一个指针可以是volatile吗？为什么？ 可以。尽管这并不常见。一个例子是当一个中断服务子程序修该一个指向一个buffer的指针时。 （3）下面的函数有什么错误？ int square(volatile int *ptr) { return *ptr * *ptr; } 这段代码有点变态，其目的是用来返回指针ptr指向值的平方，但是，由于ptr指向一个volatile型参数，编译器将产生类似下面的代码： int square(volatile int *ptr) { int a,b; a = *ptr; b = *ptr; return a * b; } 由于*ptr的值可能被意想不到地改变，因此a和b可能是不同的。结果，这段代码可能返回的不是你所期望的平方值！正确的代码如下： long square(volatile int *ptr) { int a=*ptr; return a * a; } 4.volatile使用 volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。 volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值） const 可以是 volatile （如只读的状态寄存器） 指针可以是 volatile","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++学习","slug":"C-学习","permalink":"http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"}]},{"title":"Leetcode每日一题 1603.设计停车系统","slug":"leetcode1603","date":"2021-03-26T08:15:11.619Z","updated":"2021-03-26T08:16:22.752Z","comments":true,"path":"2021/03/26/leetcode1603/","link":"","permalink":"http://example.com/2021/03/26/leetcode1603/","excerpt":"","text":"1603. 设计停车系统 请你给一个停车场设计一个停车系统。停车场总共有三种不同大小的车位：大，中和小，每种尺寸分别有固定数目的车位。 请你实现&nbsp;ParkingSystem&nbsp;类： ParkingSystem(int big, int medium, int small)&nbsp;初始化&nbsp;ParkingSystem&nbsp;类，三个参数分别对应每种停车位的数目。 bool addCar(int carType)&nbsp;检查是否有&nbsp;carType&nbsp;对应的停车位。&nbsp;carType&nbsp;有三种类型：大，中，小，分别用数字&nbsp;1，&nbsp;2&nbsp;和&nbsp;3&nbsp;表示。一辆车只能停在&nbsp;&nbsp;carType&nbsp;对应尺寸的停车位中。如果没有空车位，请返回&nbsp;false&nbsp;，否则将该车停入车位并返回&nbsp;true&nbsp;。 示例 1： 输入： [\"ParkingSystem\", \"addCar\", \"addCar\", \"addCar\", \"addCar\"] [[1, 1, 0], [1], [2], [3], [1]] 输出： [null, true, true, false, false] 解释： ParkingSystem parkingSystem = new ParkingSystem(1, 1, 0); parkingSystem.addCar(1); // 返回 true ，因为有 1 个空的大车位 parkingSystem.addCar(2); // 返回 true ，因为有 1 个空的中车位 parkingSystem.addCar(3); // 返回 false ，因为没有空的小车位 parkingSystem.addCar(1); // 返回 false ，因为没有空的大车位，唯一一个大车位已经被占据了 提示： 0 &lt;= big, medium, small &lt;= 1000 carType&nbsp;取值为&nbsp;1，&nbsp;2&nbsp;或&nbsp;3 最多会调用&nbsp;addCar&nbsp;函数&nbsp;1000&nbsp;次 简单题，没啥好说的 12345678910111213141516171819202122232425262728293031323334class ParkingSystem &#123;private:int big;int medium;int small;public: ParkingSystem(int big, int medium, int small):big(big),medium(medium),small(small) &#123; &#125; bool addCar(int carType) &#123; if(carType == 1 &amp;&amp; big &gt; 0)&#123; big--; return true; &#125; if(carType == 2 &amp;&amp; medium &gt; 0)&#123; medium--; return true; &#125; if(carType == 3 &amp;&amp; small &gt; 0)&#123; small--; return true; &#125; return false; &#125;&#125;;/** * Your ParkingSystem object will be instantiated and called as such: * ParkingSystem* obj = new ParkingSystem(big, medium, small); * bool param_1 = obj-&gt;addCar(carType); */","categories":[{"name":"每日打卡","slug":"每日打卡","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"}],"tags":[{"name":"Leetcode题解","slug":"Leetcode题解","permalink":"http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"}]},{"title":"Leetcode每日一题 92.反转链表 II","slug":"leetcode92","date":"2021-03-26T08:13:06.955Z","updated":"2021-03-26T08:14:41.740Z","comments":true,"path":"2021/03/26/leetcode92/","link":"","permalink":"http://example.com/2021/03/26/leetcode92/","excerpt":"","text":"92. 反转链表 II 给你单链表的头节点&nbsp;head&nbsp;和两个整数&nbsp;left&nbsp;和&nbsp;right&nbsp;，其中&nbsp;left &lt;= right&nbsp;。请你反转从位置&nbsp;left&nbsp;到位置&nbsp;right&nbsp;的链表节点，返回&nbsp;反转后的链表&nbsp;。 示例 1： 输入：head = [1,2,3,4,5], left = 2, right = 4 输出：[1,4,3,2,5] 示例 2： 输入：head = [5], left = 1, right = 1 输出：[5] 提示： 链表中节点数目为&nbsp;n 1 &lt;= n &lt;= 500 -500 &lt;= Node.val &lt;= 500 1 &lt;= left &lt;= right &lt;= n 直接拿图举例，首先建立一个头结点，找到要反转的一段，记录下1这个结点，和5这个结点，然后切断1-&gt;4 , 2-&gt;5 ，将 4-&gt;3-&gt;2 反转，改变指针方向变为 4&lt;-3&lt;-2，然后利用记录下的结点，将1连接4,2连接5，完成，返回虚拟头结点的下一个结点。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode * relist(ListNode * head) &#123; ListNode * pre = nullptr; ListNode * cur = head; ListNode * tmp; while(cur) &#123; tmp = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = tmp; &#125; return pre; &#125;public: ListNode* reverseBetween(ListNode* head, int left, int right) &#123; ListNode * newhead = new ListNode(0); newhead-&gt;next = head; ListNode * cur = newhead; ListNode * end = newhead; ListNode * pre = newhead; for(int i = 0 ; i &lt; left - 1 ; i++) pre = pre-&gt;next; for(int i = 0 ; i &lt; right ; i++) end = end-&gt;next; ListNode * ls = pre-&gt;next; ListNode * re = end-&gt;next; pre-&gt;next = nullptr; end-&gt;next = nullptr; pre-&gt;next = relist(ls); ls-&gt;next = re; return newhead-&gt;next; &#125;&#125;;","categories":[{"name":"每日打卡","slug":"每日打卡","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"}],"tags":[{"name":"Leetcode题解","slug":"Leetcode题解","permalink":"http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"}]},{"title":"Leetcode每日一题 115.不同的子序列","slug":"leetcode115","date":"2021-03-26T08:08:53.862Z","updated":"2021-03-26T08:12:44.348Z","comments":true,"path":"2021/03/26/leetcode115/","link":"","permalink":"http://example.com/2021/03/26/leetcode115/","excerpt":"","text":"115. 不同的子序列 给定一个字符串&nbsp;s&nbsp;和一个字符串&nbsp;t&nbsp;，计算在&nbsp;s&nbsp;的子序列中&nbsp;t&nbsp;出现的个数。 字符串的一个&nbsp;子序列&nbsp;是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，\"ACE\"&nbsp;是&nbsp;\"ABCDE\"&nbsp;的一个子序列，而&nbsp;\"AEC\"&nbsp;不是） 题目数据保证答案符合 32 位带符号整数范围。 示例&nbsp;1： 输入: s = \"rabbbit\", t = \"rabbit\" 输出： 3 解释： 如下图所示, 有 3 种可以从 s 中得到 \"rabbit\" 的方案。 (上箭头符号 ^ 表示选取的字母) rabbbit ^^^^ ^^ rabbbit ^^ ^^^^ rabbbit ^^^ ^^^ 示例&nbsp;2： 输入: s = \"babgbag\", t = \"bag\" 输出: 5 解释： 如下图所示, 有 5 种可以从 s 中得到 \"bag\" 的方案。 (上箭头符号 ^ 表示选取的字母) babgbag ^^ ^ babgbag ^^ ^ babgbag ^ ^^ babgbag ^ ^^ babgbag ^^^ 提示： 0 &lt;= s.length, t.length &lt;= 1000 s&nbsp;和&nbsp;t&nbsp;由英文字母组成 这种题，难度还是困难，递归暴力肯定是第一个排除的，想都不要去想。 就从这道题开始我的字符串动归的学习之路吧，首先是看到这道题思考，要如何去使用动态规划去保证你能够得到你想要的结果。 第一件事就是建立dp数组，一定要深刻理解dp数组中每一个元素的含义以及下标的含义。不然永远学不会。 那么怎么去建立呢，抱歉，我也想不到，不过得到大佬的提示还是知道了要建立一个二维数组，原因是 dp[i][j] 代表了 s字符串 0~i-1 中 包含了多少个 0~j-1 个t ，又是熟悉的边界坑，有人可能会问，为什么dp数组的下标里明明是i,j，却代表的是字符串中i-1和j-1啊之类的，那是因为，dp数组为了把子串为空的情况考虑进去，比如说 s = &ldquo;bba&rdquo; 匹配 t = \"b\"&nbsp; 首先要考虑的不是 s中的\"b\" 是否匹配t中的 \"b\" 而是考虑 s 中的空字符 \" \" 是否匹配 t中的空字符 \" \"，然后才是s中的 \"b\" 是否匹配空字符等等，看到这应该明白了吧，也就是说dp数组扩充了边界，加入了s与t的子串为空的情况，因为s与t中又没有真正的空串,所以判断s,t的时候下标要减一，才能对应上dp[i][j]。 先把动归的转移方程摆上来，方便下面的例子解释： if(s[i - 1] == t[j - 1]) dp[i][j] = dp[i-1][j-1] + dp[i-1][j]; else dp[i][j] = dp[i-1][j]; 其实这道题不难，难点是你不知道这个dp数组为什么这样求就是正确答案，不明白转移方程的含义，无法把大问题分成子问题，迭代过程不清晰，所以就是很懵，我们先从这一点开始理解，就是先抛弃那些逻辑关系，我们已经知道dp[i][j]代表了 s字符串 0~i-1 中 包含了多少个 0~j-1 个t&nbsp; 对吧，意思就是dp[i][j] 就是一个解，一个答案，那么我们这样想，假如我们已经知道了\"bagg\" 里面有多少个\"bag\" ，是dp[4][3] = 2 ，实质题目是求\"baggg\"里面有多少个\"bag\"，此时是不是就相当于往\"bagg\"后面多加了一个\"g\"，对吧，那么我们略过t中的\"b\"与\"ba\"，直接到判断\"bag&rdquo;这里来，此时s[i-1] = \"g\" ,t[i-1] = \"g\" , 相同，所以等于dp[i-1][j-1] + dp[i-1][j];为什么是这两个相加呢。想象一下，假设我们加入的是一个&ldquo;？&rdquo;字符，先不管它是什么，现在是不是变成了&ldquo;bagg?&rdquo; ,但是，在之前我们已经得知了&ldquo;bagg&rdquo;里面有多少个\"bag\"，现在即使多了个字符，之前的答案是不是必须要加进来的，也就是dp[i-1][j],然后现在&ldquo;g&rdquo;进来了，它与\"bag\"最后一个字符串&ldquo;g&rdquo;相同，也就是说，我们可以拿它与最后一个&ldquo;g&rdquo;相匹配，也可以选择不与&ldquo;g&rdquo;相匹配，所以匹配与不匹配造成了两种结果，就是说\"bag\"可以用\"ba&rdquo;跟这个\"g&rdquo;组合成一个&ldquo;bag&rdquo; 它也可以跟另外两个\"g&rdquo;组合，意思就是因为进来了这个\"g\",之前所有的&ldquo;ba&rdquo;又可以和这个\"g\"组成一个新的\"bag\",把这个&ldquo;g&rdquo;考虑进来，就得到了dp[i-1][j-1]，区别是j变成了j-1,因为&ldquo;g&rdquo;被用来匹配了，而不用&ldquo;g&rdquo;，就相当于进来了个&ldquo;z&rdquo;,变成了\"baggz\"，那此时dp[i][j]的结果必然就是跟不加&ldquo;z&rdquo;之前一样的为dp[i-1][j],是一个道理。所以必须要用dp[i-1][j-1]+dp[i-1][j]才是正确答案。 所以思维方式必须是我们已知dp[i][j]的答案，然后判断下一个字符加进来时，会造成什么样的后果就行了，然后组成一个完整的字符串。 贴上代码观看： 123456789101112131415161718192021222324class Solution &#123;public: int numDistinct(string s, string t) &#123; int n = s.length(); int m = t.length(); vector&lt;vector&lt;long&gt;&gt; dp(n+1,vector&lt;long&gt;(m+1)); for(int i = 0 ; i &lt;= n ; i++)dp[i][0] = 1; for(int i = 1 ; i &lt;= m ; i++)dp[0][i] = 0; for(int i = 1 ; i &lt;= n ; i++) &#123; for(int j = 1 ; j &lt;= m ; j++) &#123; if(s[i - 1] == t[j - 1]) dp[i][j] = dp[i-1][j-1] + dp[i-1][j]; else dp[i][j] = dp[i-1][j]; &#125; &#125; return dp[n][m]; &#125;&#125;;","categories":[{"name":"每日打卡","slug":"每日打卡","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"}],"tags":[{"name":"Leetcode题解","slug":"Leetcode题解","permalink":"http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"}]},{"title":"Leetcode每日一题 59.螺旋矩阵 II","slug":"leetcode59","date":"2021-03-26T08:07:21.739Z","updated":"2021-03-26T08:08:15.228Z","comments":true,"path":"2021/03/26/leetcode59/","link":"","permalink":"http://example.com/2021/03/26/leetcode59/","excerpt":"","text":"59. 螺旋矩阵 II 给你一个正整数&nbsp;n&nbsp;，生成一个包含&nbsp;1&nbsp;到&nbsp;n2&nbsp;所有元素，且元素按顺时针顺序螺旋排列的&nbsp;n x n&nbsp;正方形矩阵&nbsp;matrix&nbsp;。 示例 1： 输入：n = 3 输出：[[1,2,3],[8,9,4],[7,6,5]] 示例 2： 输入：n = 1 输出：[[1]] 提示： 1 &lt;= n &lt;= 20 知道昨天那题怎么写了，今天这题就更简单了，既然是要生成螺旋矩阵，我们既然已经知道了如何遍历螺旋矩阵，那么只要在遍历的过程中给定一个不断增长的变量就行了。 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123; vector&lt;vector&lt;int&gt;&gt; ans(n,vector&lt;int&gt;(n)); int x1 = 0,y1 = 0; int x2 = n - 1 , y2 = n - 1; int num = 1; while(true) &#123; if(x1&gt;x2||y1&gt;y2) break; if(x1 == x2) &#123; for(int i = y1; i &lt;= y2; i++) ans[x1][i] = num++; break; &#125; if(y1 == y2) &#123; for(int i = x1 ; i &lt;= x2 ;i++) ans[i][y1] = num++; break; &#125; for(int i = y1 ; i &lt; y2 ; i++)ans[x1][i] = num++; for(int i = x1 ; i &lt; x2 ; i++)ans[i][y2] = num++; for(int i = y2 ; i &gt; y1 ; i--)ans[x2][i] = num++; for(int i = x2 ; i &gt; x1 ; i--)ans[i][y1] = num++; x1++; y1++; x2--; y2--; &#125; return ans; &#125;&#125;;","categories":[{"name":"每日打卡","slug":"每日打卡","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"}],"tags":[{"name":"Leetcode题解","slug":"Leetcode题解","permalink":"http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"}]},{"title":"Leetcode每日一题 54.螺旋矩阵","slug":"leetcode54","date":"2021-03-26T08:04:28.760Z","updated":"2021-03-26T08:07:05.430Z","comments":true,"path":"2021/03/26/leetcode54/","link":"","permalink":"http://example.com/2021/03/26/leetcode54/","excerpt":"","text":"54. 螺旋矩阵 给你一个 m 行 n 列的矩阵&nbsp;matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。 示例 1： 输入： matrix = [[1,2,3],[4,5,6],[7,8,9]] 输出： [1,2,3,6,9,8,7,4,5] 示例 2： 输入： matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]] 输出： [1,2,3,4,8,12,11,10,9,5,6,7] 提示： m == matrix.lengthn == matrix[i].length1 &lt;= m, n &lt;= 10-100 &lt;= matrix[i][j] &lt;= 100 以前写过，直接按圈遍历就行。 每次遍历左上角往右下递增一层，右下角往左上角递减一层。注意控制跳出循环的条件，只要x1或y1其中一个大于x2,y2则跳出循环。 比如：[1,2,3,4],[5,6,7,8]&nbsp; &nbsp;x1,y1从 元素1 跳到元素6&nbsp; &nbsp;x2,y2从元素8 跳到 元素3,此时已经遍历完成，如果不跳出循环，则会出现重复数据。 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123;public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int n = matrix.size(); int m = matrix[0].size(); vector&lt;int&gt; ans; int x1 = 0 , y1 = 0; int x2 = n - 1, y2 = m - 1; while(true) &#123; if(x1 &gt; x2 || y1 &gt; y2) &#123; break; &#125; if(x1 == x2) &#123; for(int i = y1 ; i &lt;= y2 ; i++)ans.push_back(matrix[x1][i]); break; &#125; if(y1 == y2) &#123; for(int i = x1 ; i &lt;= x2 ; i++)ans.push_back(matrix[i][y1]); break; &#125; for(int i = y1 ; i &lt; y2 ; i++)ans.push_back(matrix[x1][i]); for(int i = x1 ; i &lt; x2 ; i++)ans.push_back(matrix[i][y2]); for(int i = y2 ; i &gt; y1 ; i--)ans.push_back(matrix[x2][i]); for(int i = x2 ; i &gt; x1 ; i--)ans.push_back(matrix[i][y1]); x1++; y1++; x2--; y2--; &#125; return ans; &#125;&#125;; 只要确定了边界，这种题就非常好写了。","categories":[{"name":"每日打卡","slug":"每日打卡","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"}],"tags":[{"name":"Leetcode题解","slug":"Leetcode题解","permalink":"http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"}]},{"title":"Leetcode每日一题 706.设计哈希映射","slug":"leetcode706","date":"2021-03-26T08:00:48.488Z","updated":"2021-03-26T08:02:27.139Z","comments":true,"path":"2021/03/26/leetcode706/","link":"","permalink":"http://example.com/2021/03/26/leetcode706/","excerpt":"","text":"706. 设计哈希映射 不使用任何内建的哈希表库设计一个哈希映射（HashMap）。 实现&nbsp;MyHashMap&nbsp;类： MyHashMap()&nbsp;用空映射初始化对象 void put(int key, int value)&nbsp;向 HashMap 插入一个键值对&nbsp;(key, value)&nbsp;。如果&nbsp;key&nbsp;已经存在于映射中，则更新其对应的值&nbsp;value&nbsp;。 int get(int key)&nbsp;返回特定的&nbsp;key&nbsp;所映射的&nbsp;value&nbsp;；如果映射中不包含&nbsp;key&nbsp;的映射，返回&nbsp;-1&nbsp;。 void remove(key)&nbsp;如果映射中存在&nbsp;key&nbsp;的映射，则移除&nbsp;key&nbsp;和它所对应的&nbsp;value&nbsp;。 示例： 输入： [\"MyHashMap\", \"put\", \"put\", \"get\", \"get\", \"put\", \"get\", \"remove\", \"get\"] [[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]] 输出： [null, null, null, 1, -1, null, 1, null, -1] 解释： MyHashMap myHashMap = new MyHashMap(); myHashMap.put(1, 1); // myHashMap 现在为 [[1,1]] myHashMap.put(2, 2); // myHashMap 现在为 [[1,1], [2,2]] myHashMap.get(1); // 返回 1 ，myHashMap 现在为 [[1,1], [2,2]] myHashMap.get(3); // 返回 -1（未找到），myHashMap 现在为 [[1,1], [2,2]] myHashMap.put(2, 1); // myHashMap 现在为 [[1,1], [2,1]]（更新已有的值） myHashMap.get(2); // 返回 1 ，myHashMap 现在为 [[1,1], [2,1]] myHashMap.remove(2); // 删除键为 2 的数据，myHashMap 现在为 [[1,1]] myHashMap.get(2); // 返回 -1（未找到），myHashMap 现在为 [[1,1]] 代码: 12345678910111213141516171819202122232425262728293031class MyHashMap &#123;public: /** Initialize your data structure here. */ int hashmap[1000009]; MyHashMap() &#123; memset(hashmap,-1,sizeof(hashmap)); &#125; /** value will always be non-negative. */ void put(int key, int value) &#123; hashmap[key] = value; &#125; /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */ int get(int key) &#123; return hashmap[key]; &#125; /** Removes the mapping of the specified value key if this map contains a mapping for the key */ void remove(int key) &#123; hashmap[key] = -1; &#125;&#125;;/** * Your MyHashMap object will be instantiated and called as such: * MyHashMap* obj = new MyHashMap(); * obj-&gt;put(key,value); * int param_2 = obj-&gt;get(key); * obj-&gt;remove(key); */","categories":[{"name":"每日打卡","slug":"每日打卡","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"}],"tags":[{"name":"Leetcode题解","slug":"Leetcode题解","permalink":"http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"}]},{"title":"Leetcode每日一题 705.设计哈希集合","slug":"leetcode705","date":"2021-03-26T07:58:08.190Z","updated":"2021-03-26T08:00:25.326Z","comments":true,"path":"2021/03/26/leetcode705/","link":"","permalink":"http://example.com/2021/03/26/leetcode705/","excerpt":"","text":"不使用任何内建的哈希表库设计一个哈希集合（HashSet）。 实现 MyHashSet 类： void add(key) 向哈希集合中插入值 key 。bool contains(key) 返回哈希集合中是否存在这个值 key 。void remove(key) 将给定值 key 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。&nbsp;示例： 输入： [\"MyHashSet\", \"add\", \"add\", \"contains\", \"contains\", \"add\", \"contains\", \"remove\", \"contains\"] [[], [1], [2], [1], [3], [2], [2], [2], [2]] 输出： [null, null, null, true, false, null, true, null, false] 解释： MyHashSet myHashSet = new MyHashSet(); myHashSet.add(1); // set = [1] myHashSet.add(2); // set = [1, 2] myHashSet.contains(1); // 返回 True myHashSet.contains(3); // 返回 False ，（未找到） myHashSet.add(2); // set = [1, 2] myHashSet.contains(2); // 返回 True myHashSet.remove(2); // set = [1] myHashSet.contains(2); // 返回 False ，（已移除） 提示： 0 &lt;= key &lt;= 106最多调用 104 次 add、remove 和 contains 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class MyHashSet &#123;public: /** Initialize your data structure here. */ int index; vector&lt;int&gt; v; MyHashSet() &#123; index = -1; &#125; void add(int key) &#123; if(!contains(key)) &#123; v.insert(v.begin()+index,key); &#125; &#125; void remove(int key) &#123; if(contains(key)) &#123; v.erase(v.begin()+index); &#125; &#125; /** Returns true if this set contains the specified element */ bool contains(int key) &#123; int v_size = v.size(); int left = 0; int right = v_size - 1; int mid = left + (right-left)/2; while(left &lt;= right) &#123; mid = left + (right-left)/2; if(v[mid]==key) &#123; index = mid; return true; &#125; else if(v[mid] &gt; key) &#123; right = mid - 1; &#125; else if(v[mid] &lt; key) &#123; left = mid + 1; &#125; &#125; index = right + 1; return false; &#125;&#125;;/** * Your MyHashSet object will be instantiated and called as such: * MyHashSet* obj = new MyHashSet(); * obj-&gt;add(key); * obj-&gt;remove(key); * bool param_3 = obj-&gt;contains(key); */ 懒得想扩容问题，就用个vector数组，然后加上二分法查找，维护一个递增的哈希集合。","categories":[{"name":"每日打卡","slug":"每日打卡","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"}],"tags":[{"name":"Leetcode题解","slug":"Leetcode题解","permalink":"http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"}]},{"title":"Leetcode每日一题 331.验证二叉树的前序序列化","slug":"leetcode331","date":"2021-03-26T07:54:48.454Z","updated":"2021-03-26T07:56:29.033Z","comments":true,"path":"2021/03/26/leetcode331/","link":"","permalink":"http://example.com/2021/03/26/leetcode331/","excerpt":"","text":"331. 验证二叉树的前序序列化 序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如&nbsp;#。 _9_ / \\ 3 2 / \\ / \\ 4 1 # 6 / \\ / \\ / \\ # # # # # # 例如，上面的二叉树可以被序列化为字符串&nbsp;\"9,3,4,#,#,1,#,#,2,#,6,#,#\"，其中&nbsp;#&nbsp;代表一个空节点。 给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。 每个以逗号分隔的字符或为一个整数或为一个表示&nbsp;null&nbsp;指针的&nbsp;'#'&nbsp;。 你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如&nbsp;\"1,,3\"&nbsp;。 示例 1: 输入: \"9,3,4,#,#,1,#,#,2,#,6,#,#\" 输出: true 示例 2: 输入: “1,#” 输出: false 示例 2: 输入: “1,#” 输出: false 一开始看到这题第一时间想到的是判断节点的入度出度，不过思路对了，但就是在奇妙的地方卡住了，永远剩下几个案例过不去，就很懵，然后看了下大佬的思路，学到了新姿势，用消除法去判断，就是当遇到&ldquo;4，#，#&rdquo;这种的，就将它转化为&ldquo;#&rdquo;，最后栈中只剩下一个&ldquo;#&rdquo;，那么这个树就是合理的，因为所有叶子节点都会有两个空节点，如果这是一颗合理的二叉树，那么我们将叶子节点变为空节点，之前的父节点最终也会变成叶子节点，直到最后，顶点也会变为一个空节点，思路新奇，然后就自己动手实现了一下。 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: bool isValidSerialization(string preorder) &#123; int p_size = preorder.length(); if (p_size == 0)return false; //关键点，是否遇到&#x27;#&#x27; //遇到连续两个&#x27;#&#x27;,代表这颗子树的末端 vector&lt;string&gt; v; for (int i = 0; i &lt; p_size;) &#123; if (preorder[i] == &#x27;,&#x27;) &#123; i++; continue; &#125; if (preorder[i] != &#x27;#&#x27;) &#123; string tmp; while(i&lt;p_size &amp;&amp; preorder[i]!=&#x27;,&#x27;)&#123; tmp+=preorder[i++]; &#125; v.push_back(tmp); &#125; else &#123; v.push_back(&quot;#&quot;); i++; &#125; while(v.size()&gt;2 &amp;&amp; v.back() == &quot;#&quot; &amp;&amp; *(v.rbegin()+1) == &quot;#&quot; &amp;&amp; *(v.rbegin()+2) != &quot;#&quot;) &#123; v.pop_back(); v.pop_back(); v.pop_back(); v.push_back(&quot;#&quot;); &#125; &#125; if(v.size() == 1 &amp;&amp; v[0] == &quot;#&quot;)return true; return false; &#125;&#125;;","categories":[{"name":"每日打卡","slug":"每日打卡","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"}],"tags":[{"name":"Leetcode题解","slug":"Leetcode题解","permalink":"http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"}]},{"title":"Leetcode每日一题 227.基本计算器 II","slug":"leetcode227","date":"2021-03-26T07:50:31.646Z","updated":"2021-03-26T07:53:56.198Z","comments":true,"path":"2021/03/26/leetcode227/","link":"","permalink":"http://example.com/2021/03/26/leetcode227/","excerpt":"","text":"昨天的题基础上加了乘法和除法，但去除了括号，其实也很简单，既然知道了怎么利用栈实现基础的\"1+1\" ，那么乘法或除法只需要将栈中的上一个数a乘上或除以当前这个数b，得到c,然后让a出栈,c入栈就行了，这里可能会被先乘后除再加再减的数学计算规则给误导，如果再加上括号，导致越想越复杂，其实并没有那么难，因为我们维护的是一个保存了每一位数字的栈，遇到乘或除就按上面的方法过一遍，遇到加减直接将上一个数入栈就行，最后把栈内的每一个数加起来，就是我们要的结果。 227. 基本计算器 II 给你一个字符串表达式&nbsp;s&nbsp;，请你实现一个基本计算器来计算并返回它的值。 整数除法仅保留整数部分。 示例 1： 输入：s = \"3+2*2\" 输出：7 示例 2： 输入：s = \" 3/2 \" 输出：1 示例 3： 输入：s = \" 3+5 / 2 \" 输出：5 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123;public: inline bool isdigit(char c) &#123; return c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;; &#125;public: string s; int i; int s_size; int dfs() &#123; char sign = &#x27;+&#x27;; stack&lt;int&gt; num; long long sum = 0; while(i&lt;s_size) &#123; char c = s[i++]; if(isdigit(c)) sum = sum * 10 + (c - &#x27;0&#x27;); if(c == &#x27;(&#x27;) sum = dfs(); if((!isdigit(c)&amp;&amp;c!=&#x27; &#x27;)||i &gt;= s_size) &#123; int tmp; switch(sign)&#123; case &#x27;+&#x27;:num.push(sum);break; case &#x27;-&#x27;:num.push(-sum);break; case &#x27;*&#x27;:tmp = num.top() * sum;num.pop();num.push(tmp);break; case &#x27;/&#x27;:tmp = num.top() / sum;num.pop();num.push(tmp);break; &#125; sign = c; sum = 0; &#125; if(c == &#x27;)&#x27;) break; &#125; int res = 0; while(!num.empty()) &#123; res += num.top(); num.pop(); &#125; return res; &#125;public: int calculate(string s) &#123; this-&gt;s = s; this-&gt;i = 0; this-&gt;s_size = s.size(); return dfs(); &#125;&#125;; 再加上昨天的括号递归处理，这样就能实现一个简单的完整的字符串式子的计算了。","categories":[{"name":"每日打卡","slug":"每日打卡","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"}],"tags":[{"name":"Leetcode题解","slug":"Leetcode题解","permalink":"http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"}]},{"title":"Leetcode每日一题 224.基本计算器","slug":"leetcode224","date":"2021-03-26T07:48:33.550Z","updated":"2021-03-26T07:51:26.284Z","comments":true,"path":"2021/03/26/leetcode224/","link":"","permalink":"http://example.com/2021/03/26/leetcode224/","excerpt":"","text":"昨天刚到剑指offer里面看到这道题，今天每日一题刚好就是它... 224. 基本计算器 实现一个基本的计算器来计算一个简单的字符串表达式 s 的值。 示例 1： 输入：s = \"1 + 1\" 输出：2 示例 2： 输入：s = “ 2-1 + 2 ” 输出：3 示例 3： 输入：s = “(1+(4+5+2)-3)+(6+8)” 输出：23 ¶ 以前写过类似的判断括号的问题，想不起来是哪一道了..反正上次是被虐了，不过这次一下就想出来了，我们要思考的第一步是，如何判断最简单的式子，比如\"1+1\"或者\"1+2-3+4-5\"类似这种，万能的栈又来了，就不多说了，因为题目里只有加减法，然后加上括号，不过括号还是很好处理的，不用想太复杂，因为括号的最里面绝对是基础式子，回到了简单的\"1+1\"，所以我们只需要用一个递归结构就行了，遇到&ldquo;（&rdquo;进入递归，遇到&ldquo;）&rdquo;跳出递归，返回一个值，就是括号的和，最后的最后就会变成基础式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123;public: inline bool isdigit(char c) &#123; return c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;; &#125;public: string s; int i; int s_size; int dfs()&#123; stack&lt;int&gt; num; char sign = &#x27;+&#x27;; long long sum = 0; while(i &lt; s_size) &#123; char c = s[i++]; if(isdigit(c)) sum = sum*10 + (c - &#x27;0&#x27;); if(c == &#x27;(&#x27;) sum = dfs(); if((!isdigit(c)&amp;&amp;c!=&#x27; &#x27;)||i&gt;=s_size) &#123; switch(sign)&#123; case &#x27;+&#x27;:num.push(sum);break; case &#x27;-&#x27;:num.push(-sum);break; &#125; sign = c; sum = 0; &#125; if(c == &#x27;)&#x27;) break; &#125; long long res = 0; while(!num.empty()) &#123; res+=num.top(); num.pop(); &#125; return res; &#125; int calculate(string s) &#123; this-&gt;i = 0; this-&gt;s = s; this-&gt;s_size = s.size(); return dfs(); &#125;&#125;;","categories":[{"name":"每日打卡","slug":"每日打卡","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"}],"tags":[{"name":"Leetcode题解","slug":"Leetcode题解","permalink":"http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"}]},{"title":"Leetcode每日一题 1047.删除字符串中的所有相邻重复项","slug":"leetcode1047","date":"2021-03-26T07:43:37.558Z","updated":"2021-03-26T07:50:49.737Z","comments":true,"path":"2021/03/26/leetcode1047/","link":"","permalink":"http://example.com/2021/03/26/leetcode1047/","excerpt":"","text":"1047. 删除字符串中的所有相邻重复项 给出由小写字母组成的字符串&nbsp;S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。 在 S 上反复执行重复项删除操作，直到无法继续删除。 在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。 示例： 输入：\"abbaca\" 输出：\"ca\" 解释： 例如，在 \"abbaca\" 中，我们可以删除 \"bb\" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 \"aaca\"，其中又只有 \"aa\" 可以执行重复项删除操作，所以最后的字符串为 \"ca\"。 代码如下： ¶123456789101112131415161718192021222324class Solution &#123;public: vector&lt;char&gt; s; string removeDuplicates(string S) &#123; for(auto x : S) &#123; if(s.empty()||s.back() != x) &#123; s.push_back(x); continue; &#125; s.pop_back(); &#125; string ans = &quot;&quot;; for(auto x : s) &#123; ans+=x; &#125; return ans; &#125;&#125;; 突然想起了 std::string 本身就带有入栈和出栈的功能,麻了 123456789101112131415161718class Solution &#123;public: string s; string removeDuplicates(string S) &#123; for(auto x : S) &#123; if(s.empty()||s.back() != x) &#123; s.push_back(x); continue; &#125; s.pop_back(); &#125; return s; &#125;&#125;;","categories":[{"name":"每日打卡","slug":"每日打卡","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"}],"tags":[{"name":"Leetcode题解","slug":"Leetcode题解","permalink":"http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"}]},{"title":"Leetcode每日一题 132.分割回文串II","slug":"leetcode132","date":"2021-03-26T07:38:43.982Z","updated":"2021-03-26T07:51:05.001Z","comments":true,"path":"2021/03/26/leetcode132/","link":"","permalink":"http://example.com/2021/03/26/leetcode132/","excerpt":"","text":"132. 分割回文串 II 给你一个字符串&nbsp;s，请你将&nbsp;s&nbsp;分割成一些子串，使每个子串都是回文。 返回符合要求的&nbsp;最少分割次数&nbsp;。 示例 1： 输入：s = \"aab\" 输出：1 解释：只需一次分割就可将&nbsp;s 分割成 [\"aa\",\"b\"] 这样两个回文子串。 示例 2： 输入：s = \"a\" 输出：0 示例 3： 输入：s = \"ab\" 输出：1 提示： 1 &lt;= s.length &lt;= 2000 s&nbsp;仅由小写英文字母组成 分割回文串的另一种题型，求最小切割次数，从题意分析又是DP 本来想通过昨天代码改一改的，但发现复杂度可能超标，然后确实也超标了，然后就利用递增序列的dp思维去解题。 ¶12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: vector&lt; vector&lt;int&gt; &gt; f; vector&lt;int&gt; dp; int n; int minCut(string s) &#123; n = s.size(); f.assign(n, vector&lt;int&gt;(n, true)); dp.assign(n,INT_MAX); for (int i = n - 1; i &gt;= 0; --i) for (int j = i + 1; j &lt; n; ++j) f[i][j] = (s[i] == s[j]) &amp;&amp; f[i + 1][j - 1]; int minn = INT_MAX; for(int i = 0 ; i &lt; n ; i++) &#123; if(f[0][i]) &#123; dp[i] = 0; continue; &#125; for(int j = 0 ; j &lt; i ; j++) &#123; if(f[j+1][i]) &#123; dp[i] = min(dp[i],dp[j]+1); &#125; &#125; &#125; return dp[n - 1]; &#125;&#125;; 昨天学到的dp求回文串的模板今天就用上了，用f[i][j] 标记[i~j]区间的回文串。 先说明dp[i]的含义，保存的是在[0~i]区间的最少分割次数，所以当f[0][i]为1时，也就是[0~i]为回文串时，dp[i]理所当然的要赋值为0，因为不需要分割，当遇到不是回文串的点j时， 我们就有个循环 for(int j = 0 ;&nbsp; j &lt; i ; j++)，重点就是这，每次都从[j+1~i]中判断，当f[j+1][i]为1时，就更新dp[i]，这时可以理解最长递增子序列中，当每次遇到满足值更新条件时（回文序列断开时），就要从满足条件的那点的dp值加上一（我们就要使当前点 (j) 的最少分裂次数加上1）。 &nbsp;","categories":[{"name":"每日打卡","slug":"每日打卡","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"}],"tags":[{"name":"Leetcode题解","slug":"Leetcode题解","permalink":"http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"}]},{"title":"Leetcode每日一题 131.分割回文串","slug":"leetcode131","date":"2021-03-26T07:35:02.361Z","updated":"2021-03-26T07:51:08.769Z","comments":true,"path":"2021/03/26/leetcode131/","link":"","permalink":"http://example.com/2021/03/26/leetcode131/","excerpt":"","text":"131. 分割回文串 给定一个字符串&nbsp;s，将&nbsp;s&nbsp;分割成一些子串，使每个子串都是回文串。 返回&nbsp;s&nbsp;所有可能的分割方案。 示例: 输入: \"aab\" 输出: [ [\"aa\",\"b\"], [\"a\",\"a\",\"b\"] ] 记忆化搜索保存所有回文串。 然后DFS搜索所有回文串的组合。 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: vector&lt; vector&lt;int&gt; &gt; f; vector&lt; vector&lt;string&gt; &gt; ret; vector&lt; string &gt; ans; int n ; void dfs(string s,int i) &#123; if( i == n) &#123; ret.push_back(ans); return; &#125; for(int j = i ; j &lt; n ; ++j) &#123; if(f[i][j]) &#123; ans.push_back(s.substr(i,j-i+1)); dfs(s,j+1); ans.pop_back(); &#125; &#125; &#125; vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123; n = s.size(); f.assign(n,vector&lt;int&gt;(n,true)); for(int i = n - 1 ; i &gt;= 0 ; --i) //记忆化判断回文 for(int j = i + 1 ; j &lt; n ; ++j) f[i][j] = (s[i]==s[j])&amp;&amp;f[i+1][j-1]; dfs(s,0); return ret; &#125;&#125;; 这题不熟，第一次遇见，看的题解默写了一遍，加深一下理解，这里记录一下，新知识点 标准判断dp判断回文模板（f[i][j]记录字符串区间i~j是否为回文串） for(int i = n - 1 ; i &gt;= 0 ; --i) for(int j = i + 1 ; j &lt; n ; ++j) f[i][j] = (s[i]==s[j])&amp;&amp;f[i+1][j-1]; 大意就是找到s[i]与s[j] 判断它们两是否相等 并且 s[i+1 ~ j-1] 是否为回文串，满足两个条件，则s区间 (i~j)必定是回文串。 DFS则比较好理解，直接将字符串分割看成树状图。i是当前的分割点。 &nbsp; &nbsp;","categories":[{"name":"每日打卡","slug":"每日打卡","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"}],"tags":[{"name":"Leetcode题解","slug":"Leetcode题解","permalink":"http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"}]},{"title":"Leetcode每日一题  503.下一个更大元素II","slug":"leetcode503","date":"2021-03-26T06:54:14.271Z","updated":"2021-03-26T07:50:53.110Z","comments":true,"path":"2021/03/26/leetcode503/","link":"","permalink":"http://example.com/2021/03/26/leetcode503/","excerpt":"","text":"83.下一个更大元素 给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。 示例 1: 输入: [1,2,1]输出: [2,-1,2]解释: 第一个 1 的下一个更大的数是 2；数字 2 找不到下一个更大的数； 第二个 1 的下一个最大的数需要循环搜索，结果也是 2。注意: 输入数组的长度不会超过 10000。 本题可以使用单调栈在O(n）复杂度下解决。 分析题意，可以知道我们要找到每一个数之后第一个大于它的数，那么我们可以建立一个单调递减栈，遍历输入数组，设当前即将入栈的数为nums[i],判断当前栈顶的数是否小于nums[i]，如果小于，则弹出栈顶元素,并且在结果数组里给相应位置赋值nums[i]，继续判断，直到栈内元素都小于nums[i]，然后入栈。 先看代码： ¶123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) &#123; int nums_len = nums.size(); stack&lt;int&gt; s; vector&lt;int&gt; res(nums_len,-1); for(int i = 0 ; i &lt; nums_len * 2 - 1 ; i++) &#123; while(!s.empty()&amp;&amp;nums[s.top()]&lt;nums[i%nums_len])&#123; res[s.top()] = nums[i%nums_len]; s.pop(); &#125; s.push(i%nums_len); &#125; return res; &#125;&#125;; 思考过程： 分析while，可以发现第一个元素是直接跳过while，直接入栈的，而且保存在栈内的不是元素大小，而是元素在nums中的下标,又由于是循环数组，所以取了模。 分析例子[1,2,1] 当 i = 0 时，因为栈为空，while直接跳过,s.push(0%nums_len) 此时 s = [0] ; res = [-1,-1,-1]; 当 i = 1 时，因为nums[s.top()] 也就是nums[0] 小于 nums[1%nums_len] 也就是nums[1] ,所以 res[0] = nums[1] = 2; 此时 s = [ 1 ] , res = [2,-1,-1]; 当 i = 2 时，因为nums[s.top()]也就是nums[1] 等于 nums[2] ,所以此时 s = [1,2] , res = [2,-1,-1] ; 当 i = 3 时，因为nums[s.top()]也就是nums[2] 等于 nums[3%nums_len] 也就是nums[0] 所以此时 s= [1,2,0] ,res = [2,-1,-1]&nbsp; 当 i = 4 时，因为nums[s.top()]也就是nums[0] 小于nums[4%nums_len] 也就是nums[1] ，所以res[s.top()] = res[0] = nums[1] = 2 ;&nbsp; 此时s = [1,2],res = [2,-1,-1]; 然后继续循环，因为res[2] 小于 nums[1] ,所以res[2] = nums[1] = 2; 此时 s = [1] , res = [2,-1, 2];... 暴力法也写了： 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) &#123; int nums_len = nums.size(); vector&lt;int&gt; ans; for(int i = 0 ; i &lt; nums_len ; i++) &#123; int ind = i; int maxn = -1; int flag = 1; for(int j = ind ; j &lt; nums_len ; j++) &#123; if(nums[j] &gt; nums[i]) &#123; maxn = nums[j]; flag = 0; break; &#125; &#125; if(flag)&#123; for(int j = 0 ; j &lt; ind ; j++) &#123; if(nums[j] &gt; nums[i]) &#123; maxn = nums[j]; break; &#125; &#125; &#125; ans.push_back(maxn); &#125; return ans; &#125;&#125;;","categories":[{"name":"每日打卡","slug":"每日打卡","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"}],"tags":[{"name":"Leetcode题解","slug":"Leetcode题解","permalink":"http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"}]},{"title":"Leetcode每日一题 150.逆波兰表达式求值","slug":"leetcode150","date":"2021-03-26T06:45:13.219Z","updated":"2021-03-26T07:51:00.192Z","comments":true,"path":"2021/03/26/leetcode150/","link":"","permalink":"http://example.com/2021/03/26/leetcode150/","excerpt":"","text":"150. 逆波兰表达式求值 根据&nbsp;逆波兰表示法，求表达式的值。 有效的算符包括&nbsp;+、-、*、/&nbsp;。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 &nbsp; 说明： 整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。 &nbsp; 示例&nbsp;1： 输入：tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"] 输出：9 解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9 示例&nbsp;2： 输入：tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"] 输出：6 解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6 示例&nbsp;3： 输入：tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"] 输出：22 解释： 该算式转化为常见的中缀算术表达式为： ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22 &nbsp; 提示： 1 &lt;= tokens.length &lt;= 104 tokens[i]&nbsp;要么是一个算符（\"+\"、\"-\"、\"*\"&nbsp;或&nbsp;\"/\"），要么是一个在范围&nbsp;[-200, 200]&nbsp;内的整数 逆波兰应该算很常见的题目了吧，直接用一个栈，遇到符号的数字时做相应处理就行了。注意点就是遇到数字时要判断该数字的正负，以为传入进来的tokens保存的是string类型，我们不能直接把每一位相加，如果有负号会导致数字出错。 &nbsp; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution &#123;public: int evalRPN(vector&lt;string&gt;&amp; tokens) &#123; stack&lt;int&gt; s; int n = tokens.size(); for(int i = 0 ; i &lt; n ; i++) &#123; string tmp = tokens[i]; int sum = 0; if(tmp!=&quot;+&quot;&amp;&amp;tmp!=&quot;-&quot;&amp;&amp;tmp!=&quot;/&quot;&amp;&amp;tmp!=&quot;*&quot;) &#123; int k; if(tmp[0]!=&#x27;-&#x27;)k=0; else k=1; for(; k &lt; tmp.length(); k++) &#123; sum = sum * 10 + (tmp[k] - &#x27;0&#x27;); &#125; if(tmp[0] == &#x27;-&#x27;) s.push(-sum); else s.push(sum); &#125; else&#123; if(tmp == &quot;+&quot;) &#123; int a = s.top(); s.pop(); int b = s.top(); s.pop(); s.push(a+b); &#125; if(tmp == &quot;-&quot;) &#123; int a = s.top(); s.pop(); int b = s.top(); s.pop(); s.push(b-a); &#125; if(tmp == &quot;*&quot;) &#123; int a = s.top(); s.pop(); int b = s.top(); s.pop(); s.push(a*b); &#125; if(tmp == &quot;/&quot;) &#123; int a = s.top(); s.pop(); int b = s.top(); s.pop(); s.push(b/a); &#125; &#125; &#125; return s.top(); &#125;&#125;;","categories":[{"name":"每日打卡","slug":"每日打卡","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"}],"tags":[{"name":"Leetcode题解","slug":"Leetcode题解","permalink":"http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-03-25T13:59:55.014Z","updated":"2021-03-25T13:59:55.014Z","comments":true,"path":"2021/03/25/hello-world/","link":"","permalink":"http://example.com/2021/03/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"图形学","slug":"图形学","permalink":"http://example.com/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"数学","slug":"数学","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6/"},{"name":"每日打卡","slug":"每日打卡","permalink":"http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"}],"tags":[{"name":"概念知识","slug":"概念知识","permalink":"http://example.com/tags/%E6%A6%82%E5%BF%B5%E7%9F%A5%E8%AF%86/"},{"name":"Eigen","slug":"Eigen","permalink":"http://example.com/tags/Eigen/"},{"name":"线性代数","slug":"线性代数","permalink":"http://example.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"C++学习","slug":"C-学习","permalink":"http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"},{"name":"Leetcode题解","slug":"Leetcode题解","permalink":"http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"}]}