<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-03-27T04:53:26.138Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode每日一题 61.旋转链表</title>
    <link href="http://example.com/2021/03/27/leetcode61/"/>
    <id>http://example.com/2021/03/27/leetcode61/</id>
    <published>2021-03-27T04:42:17.133Z</published>
    <updated>2021-03-27T04:53:26.138Z</updated>
    
    <content type="html"><![CDATA[<h2 id="61-旋转链表"><a class="header-anchor" href="#61-旋转链表">¶</a>61. 旋转链表</h2><p>给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。</p><p>示例 1：<br><img src="https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], k = <span class="number">2</span>  </span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]  </span><br></pre></td></tr></table></figure><p>示例 2：<br><img src="https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], k = <span class="number">4</span>  </span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>提示：</p><p>链表中节点的数目在范围 [0, 500] 内<br>-100 &lt;= Node.val &lt;= 100<br>0 &lt;= k &lt;= 2 * 10^9</p><hr><p>对于这题我们可以直接先将链表连成环，然后断开旋转后的头尾结点就行了。</p><p>比如 1-&gt;2-&gt;3-&gt;4-&gt;5  我们将 5连上1 ，然后再将3,4断开，这样我们就得到了一个旋转后的链表。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">        ListNode * p = head;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        k=k%len;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>)<span class="keyword">return</span> head;<span class="comment">//如果不移动 直接返回表头</span></span><br><span class="line"></span><br><span class="line">        ListNode * q = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len - k - <span class="number">1</span> ; i++)&#123;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        p-&gt;next = head;</span><br><span class="line">        ListNode * newHead = q-&gt;next;</span><br><span class="line">        q-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;61-旋转链表&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#61-旋转链表&quot;&gt;¶&lt;/a&gt;61. 旋转链表&lt;/h2&gt;
&lt;p&gt;给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;br&gt;
&lt;i</summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 83.删除排序链表中的重复元素</title>
    <link href="http://example.com/2021/03/26/leetcode83/"/>
    <id>http://example.com/2021/03/26/leetcode83/</id>
    <published>2021-03-26T15:36:09.625Z</published>
    <updated>2021-03-26T15:37:42.698Z</updated>
    
    <content type="html"><![CDATA[<h2 id="83-删除排序链表中的重复元素"><a class="header-anchor" href="#83-删除排序链表中的重复元素">¶</a>83.删除排序链表中的重复元素</h2><h4 class="css-10c1h40-Title eugt34i1" data-cypress="QuestionTitle"><span style="font-size: 16px;"><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></span></h4><p><span style="font-size: 16px;">存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中&nbsp;没有重复出现&nbsp;的数字。</span></p><p><span style="font-size: 16px;">返回同样按升序排列的结果链表。</span></p><p><span style="font-size: 16px;">示例 1：</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p><span style="font-size: 16px;">示例 2：</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p><span style="font-size: 16px;">提示：</span></p><p><span style="font-size: 16px;">链表中节点数目在范围 [0, 300] 内</span><br /><span style="font-size: 16px;">-100 &lt;= Node.val &lt;= 100</span><br /><span style="font-size: 16px;">题目数据保证链表已经按升序排列</span></p><hr><p><span style="font-size: 16px;">跟昨天的题没啥区别，照样建新表。</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)<span class="keyword">return</span> head;</span><br><span class="line">        ListNode * newhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        newhead-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; maps;</span><br><span class="line">        ListNode * pre = head;</span><br><span class="line">        <span class="keyword">while</span>(pre != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            maps[pre-&gt;val]++;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pre = newhead;</span><br><span class="line">        ListNode * cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>( cur != <span class="literal">nullptr</span> &amp;&amp; maps[cur-&gt;val] &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode * node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(cur-&gt;val);</span><br><span class="line">                pre-&gt;next = node;</span><br><span class="line">                pre = pre-&gt;next;</span><br><span class="line">                node-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;83-删除排序链表中的重复元素&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#83-删除排序链表中的重复元素&quot;&gt;¶&lt;/a&gt;83.删除排序链表中的重复元素&lt;/h2&gt;
&lt;h4 class=&quot;css-10c1h40-Title eugt34i1&quot; d</summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 82.删除排序链表中的重复元素 II</title>
    <link href="http://example.com/2021/03/26/leetcode82/"/>
    <id>http://example.com/2021/03/26/leetcode82/</id>
    <published>2021-03-26T15:34:10.975Z</published>
    <updated>2021-03-26T15:35:59.171Z</updated>
    
    <content type="html"><![CDATA[<h2 id="82-删除排序链表中的重复元素-II"><a class="header-anchor" href="#82-删除排序链表中的重复元素-II">¶</a>82.删除排序链表中的重复元素 II</h2><h4 class="css-10c1h40-Title eugt34i1" data-cypress="QuestionTitle"><span style="font-size: 16px;"><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II</a></span></h4><p><span style="font-size: 16px;">存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中&nbsp;没有重复出现&nbsp;的数字。</span></p><p><span style="font-size: 16px;">返回同样按升序排列的结果链表。</span></p><p><span style="font-size: 16px;">示例 1：</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p><span style="font-size: 16px;">示例 2：</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p><span style="font-size: 16px;">提示：</span></p><p><span style="font-size: 16px;">链表中节点数目在范围 [0, 300] 内</span><br /><span style="font-size: 16px;">-100 &lt;= Node.val &lt;= 100</span><br /><span style="font-size: 16px;">题目数据保证链表已经按升序排列</span></p><hr><p><span style="font-size: 16px;">用哈希表保存出现的数值，将出现次数未超过一的值，建立结点赋给新链表。</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)<span class="keyword">return</span> head;</span><br><span class="line">        ListNode * newhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        newhead-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; maps;</span><br><span class="line">        ListNode * pre = head;</span><br><span class="line">        <span class="keyword">while</span>(pre != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            maps[pre-&gt;val]++;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pre = newhead;</span><br><span class="line">        ListNode * cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>( cur != <span class="literal">nullptr</span> &amp;&amp; maps[cur-&gt;val] &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode * node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(cur-&gt;val);</span><br><span class="line">                pre-&gt;next = node;</span><br><span class="line">                pre = pre-&gt;next;</span><br><span class="line">                node-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;82-删除排序链表中的重复元素-II&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#82-删除排序链表中的重复元素-II&quot;&gt;¶&lt;/a&gt;82.删除排序链表中的重复元素 II&lt;/h2&gt;
&lt;h4 class=&quot;css-10c1h40-Title eu</summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 456.132 模式</title>
    <link href="http://example.com/2021/03/26/leetcode456/"/>
    <id>http://example.com/2021/03/26/leetcode456/</id>
    <published>2021-03-26T15:10:36.906Z</published>
    <updated>2021-03-26T15:13:10.721Z</updated>
    
    <content type="html"><![CDATA[<h2 id="456-132-模式"><a class="header-anchor" href="#456-132-模式">¶</a>456.132 模式</h2><h4 class="css-10c1h40-Title eugt34i1" data-cypress="QuestionTitle"><span style="font-size: 16px;"><a href="https://leetcode-cn.com/problems/132-pattern/">456. 132 模式</a></span></h4><p><span style="font-size: 16px;">给你一个整数数组 nums ，数组中共有 n 个整数。132 模式的子序列 由三个整数 nums[i]、nums[j] 和 nums[k] 组成，并同时满足：i &lt; j &lt; k 和 nums[i] &lt; nums[k] &lt; nums[j] 。</span></p><p><span style="font-size: 16px;">如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false 。</span></p><p><span style="font-size: 16px;">&nbsp;</span></p><p><span style="font-size: 16px;">进阶：很容易想到时间复杂度为 O(n^2) 的解决方案，你可以设计一个时间复杂度为 O(n logn) 或 O(n) 的解决方案吗？</span></p><hr><p><span style="font-size: 16px;">示例 1：</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：序列中不存在 <span class="number">132</span> 模式的子序列。</span><br></pre></td></tr></table></figure><p><span style="font-size: 16px;">示例 2：</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：序列中有 <span class="number">1</span> 个 <span class="number">132</span> 模式的子序列： [<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>] 。</span><br></pre></td></tr></table></figure><p><span style="font-size: 16px;">示例 3：</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：序列中有 <span class="number">3</span> 个 <span class="number">132</span> 模式的的子序列：[<span class="number">-1</span>, <span class="number">3</span>, <span class="number">2</span>]、[<span class="number">-1</span>, <span class="number">3</span>, <span class="number">0</span>] 和 [<span class="number">-1</span>, <span class="number">2</span>, <span class="number">0</span>] 。</span><br></pre></td></tr></table></figure><p><span style="font-size: 16px;">提示：</span></p><p><span style="font-size: 16px;">n == nums.length</span><br /><span style="font-size: 16px;">1 &lt;= n &lt;= 104</span><br /><span style="font-size: 16px;">-109 &lt;= nums[i] &lt;= 109</span></p><p>&nbsp;</p><p><span style="font-size: 16px;">一开始用的是暴力法，O(n&sup2;)，勉强能接受..就是从做往右搜，以132中的3为基础，往左搜1，往右搜2，就行了。</span></p><p><span style="font-size: 16px;">代码：</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find132pattern</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> minn = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n<span class="number">-1</span> ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            minn = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= i - <span class="number">1</span> ; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(minn &gt; nums[j])minn = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt; n ; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &gt; minn &amp;&amp; nums[j] &lt; nums[i])<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p><span style="font-size: 16px;">后面又看到大神的单调栈思路，然后写了个单调栈方法，从右往左搜，利用单调栈的特性，同时找到2与3，只需要往左找1就行了。复杂度O(n)。</span></p><p><span style="font-size: 16px;">maxn维护3前面最大的数2。只要往左找到一个比maxn更小的数，就证明找到了132。</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find132pattern</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> maxn = INT_MIN;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span> ; i &gt;= <span class="number">0</span> ; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(maxn &gt; nums[i])<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()&amp;&amp;s.<span class="built_in">top</span>()&lt;nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                maxn = <span class="built_in">max</span>(s.<span class="built_in">top</span>(),maxn);</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;456-132-模式&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#456-132-模式&quot;&gt;¶&lt;/a&gt;456.132 模式&lt;/h2&gt;
&lt;h4 class=&quot;css-10c1h40-Title eugt34i1&quot; data-cypress=&quot;Qu</summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 341.扁平化嵌套列表迭代器</title>
    <link href="http://example.com/2021/03/26/leetcode341/"/>
    <id>http://example.com/2021/03/26/leetcode341/</id>
    <published>2021-03-26T15:07:54.443Z</published>
    <updated>2021-03-26T15:09:53.735Z</updated>
    
    <content type="html"><![CDATA[<h2 id="341-扁平化嵌套列表迭代器"><a class="header-anchor" href="#341-扁平化嵌套列表迭代器">¶</a>341. 扁平化嵌套列表迭代器</h2><h4 class="css-10c1h40-Title eugt34i1" data-cypress="QuestionTitle"><span style="font-size: 16px;"><a href="https://leetcode-cn.com/problems/flatten-nested-list-iterator/">341. 扁平化嵌套列表迭代器</a></span></h4><p><span style="font-size: 16px;">给你一个嵌套的整型列表。请你设计一个迭代器，使其能够遍历这个整型列表中的所有整数。</span></p><p><span style="font-size: 16px;">列表中的每一项或者为一个整数，或者是另一个列表。其中列表的元素也可能是整数或是其他列表。</span></p><hr><p><span style="font-size: 16px;">示例 1:</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [[<span class="number">1</span>,<span class="number">1</span>],<span class="number">2</span>,[<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">解释: 通过重复调用 next 直到 hasNext 返回 <span class="literal">false</span>，next 返回的元素的顺序应该是: [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]。</span><br></pre></td></tr></table></figure><p><span style="font-size: 16px;">示例 2:</span></p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,[<span class="number">4</span>,[<span class="number">6</span>]]]</span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">解释: 通过重复调用 next 直到 hasNext 返回 <span class="literal">false</span>，next 返回的元素的顺序应该是: [<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>]。</span><br></pre></td></tr></table></figure><hr><p><span style="font-size: 16px;">递归就行了。</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the interface that allows for creating nested lists.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class NestedInteger &#123;</span></span><br><span class="line"><span class="comment"> *   public:</span></span><br><span class="line"><span class="comment"> *     // Return true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line"><span class="comment"> *     bool isInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a nested list</span></span><br><span class="line"><span class="comment"> *     int getInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a single integer</span></span><br><span class="line"><span class="comment"> *     const vector&lt;NestedInteger&gt; &amp;getList() const;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator cur;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> vector&lt;NestedInteger&gt; &amp;nestedList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;nest : nestedList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nest.<span class="built_in">isInteger</span>()) &#123;</span><br><span class="line">                v.<span class="built_in">push_back</span>(nest.<span class="built_in">getInteger</span>());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(nest.<span class="built_in">getList</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NestedIterator</span>(vector&lt;NestedInteger&gt; &amp;nestedList) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(nestedList);</span><br><span class="line">        cur = v.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *cur++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cur != v.<span class="built_in">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NestedIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NestedIterator i(nestedList);</span></span><br><span class="line"><span class="comment"> * while (i.hasNext()) cout &lt;&lt; i.next();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;341-扁平化嵌套列表迭代器&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#341-扁平化嵌套列表迭代器&quot;&gt;¶&lt;/a&gt;341. 扁平化嵌套列表迭代器&lt;/h2&gt;
&lt;h4 class=&quot;css-10c1h40-Title eugt34i1&quot; dat</summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 191.位1的个数</title>
    <link href="http://example.com/2021/03/26/Leetcode191/"/>
    <id>http://example.com/2021/03/26/Leetcode191/</id>
    <published>2021-03-26T15:03:22.899Z</published>
    <updated>2021-03-26T15:06:36.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="191-位1的个数"><a class="header-anchor" href="#191-位1的个数">¶</a>191. 位1的个数</h2><p><span style="font-size: 16px;">编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。</span></p><p><span style="font-size: 16px;">提示：</span></p><p><span style="font-size: 16px;">请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</span><br /><span style="font-size: 16px;">在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的&nbsp;示例 3&nbsp;中，输入表示有符号整数 -3。</span><br /><span style="font-size: 16px;"></span></p><hr><p><span style="font-size: 16px;">示例 1：</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="number">00000000000000000000000000001011</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：输入的二进制串 <span class="number">00000000000000000000000000001011</span> 中，共有三位为 <span class="string">&#x27;1&#x27;</span>。</span><br></pre></td></tr></table></figure><p><span style="font-size: 16px;">示例 2：</span></p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="number">00000000000000000000000010000000</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：输入的二进制串 <span class="number">00000000000000000000000010000000</span> 中，共有一位为 <span class="string">&#x27;1&#x27;</span>。</span><br></pre></td></tr></table></figure><p><span style="font-size: 16px;">示例 3：</span></p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="number">11111111111111111111111111111101</span></span><br><span class="line">输出：<span class="number">31</span></span><br><span class="line">解释：输入的二进制串 <span class="number">11111111111111111111111111111101</span> 中，共有 <span class="number">31</span> 位为 <span class="string">&#x27;1&#x27;</span>。</span><br></pre></td></tr></table></figure><p><span style="font-size: 16px;">提示：</span></p><p><span style="font-size: 16px;">输入必须是长度为 32 的 二进制串 。</span><br /><span style="font-size: 16px;"></span></p><p><span style="font-size: 16px;">进阶：</span></p><p><span style="font-size: 16px;">如果多次调用这个函数，你将如何优化你的算法？</span></p><hr><p><span style="font-size: 16px;">利用位运算，判断当前数的最后一位是否为1，如果为1，则直接加入cnt,并且当前数右移一位。</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n&amp;<span class="number">1</span>)</span><br><span class="line">                cnt++;</span><br><span class="line">            n = n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;191-位1的个数&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#191-位1的个数&quot;&gt;¶&lt;/a&gt;191. 位1的个数&lt;/h2&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 16px;&quot;&gt;编写一个函数，输入是一个无符号整数（以二进制串</summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 73.矩阵置零</title>
    <link href="http://example.com/2021/03/26/leetcode73/"/>
    <id>http://example.com/2021/03/26/leetcode73/</id>
    <published>2021-03-26T14:42:11.018Z</published>
    <updated>2021-03-26T15:03:06.791Z</updated>
    
    <content type="html"><![CDATA[<h2 id="73-矩阵置零"><a class="header-anchor" href="#73-矩阵置零">¶</a>73.矩阵置零</h2><h4 class="css-10c1h40-Title eugt34i1" data-cypress="QuestionTitle"><span style="font-size: 16px;"><a href="https://leetcode-cn.com/problems/set-matrix-zeroes/">73. 矩阵置零</a></span></h4><div class="content__1Y2H"><div class="notranslate"><p><span style="font-size: 16px;">给定一个&nbsp;<code><em>m</em>&nbsp;x&nbsp;<em>n</em></code>&nbsp;的矩阵，如果一个元素为&nbsp;0&nbsp;，则将其所在行和列的所有元素都设为&nbsp;0&nbsp;。请使用&nbsp;<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>&nbsp;算法。</span></p><p><span style="font-size: 16px;">进阶：</span></p><ul><li><span style="font-size: 16px;">一个直观的解决方案是使用 &nbsp;<code>O(<em>m</em><em>n</em>)</code>&nbsp;的额外空间，但这并不是一个好的解决方案。</span></li><li><span style="font-size: 16px;">一个简单的改进方案是使用&nbsp;<code>O(<em>m</em>&nbsp;+&nbsp;<em>n</em>)</code>&nbsp;的额外空间，但这仍然不是最好的解决方案。</span></li><li><span style="font-size: 16px;">你能想出一个仅使用常量空间的解决方案吗？</span></li></ul><p><span style="font-size: 16px;">&nbsp;</span></p><p><span style="font-size: 16px;">示例 1：</span></p><span style="font-size: 16px;"><img src="https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg" alt="" /></span><pre><span style="font-size: 16px;">输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]输出：[[1,0,1],[0,0,0],[1,0,1]]</span></pre><p><span style="font-size: 16px;">示例 2：</span></p><span style="font-size: 16px;"><img src="https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg" alt="" /></span><pre><span style="font-size: 16px;">输入：matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]</span></pre><p><span style="font-size: 16px;">提示：</span></p><ul><li><span style="font-size: 16px;"><code>m == matrix.length</code></span></li><li><span style="font-size: 16px;"><code>n == matrix[0].length</code></span></li><li><span style="font-size: 16px;"><code>1 &lt;= m, n &lt;= 200</code></span></li><li><span style="font-size: 16px;"><code>-231&nbsp;&lt;= matrix[i][j] &lt;= 231&nbsp;- 1</code></span></li></ul><p>&nbsp;</p><p><span style="font-size: 16px;">普通解法，就是利用O(m+n)空间复杂度来解决问题，建立两个数组，一个row,一个col,分别保存要置零的行与要置零的列,遍历数组，获取相应的零的位置即可。</span></p><p><span style="font-size: 16px;">代码如下：</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> r[<span class="number">201</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> c[<span class="number">201</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; m ; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                r[i] = <span class="number">1</span>;</span><br><span class="line">                c[j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(r[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; m ; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(c[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    matrix[j][i] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><p><span style="font-size: 16px;">还有一种方法就是消耗最小的空间来解决问题，不创建任何数组，就利用它本身来解决问题，那么如何去解决呢。</span></p><p><span style="font-size: 16px;">首先，我们思考之前是不是都用两个数组来保存要置零的行和列，说到底就是我们需要知道哪一行需要置零，哪一列需要置零，那么我们是不是可以将置零信息保存在第0行与第0列呢。</span></p><p><span style="font-size: 16px;"><img src="https://img2020.cnblogs.com/blog/1582514/202103/1582514-20210326223554068-1329953760.png" alt="" loading="lazy" /></span></p><hr><p><span style="font-size: 16px;">最后遍历二维数组的时候，只需要遍历首行与首列，讲遇到的零的一列和一行全部置零就可以了，这个问题考虑完了，还有一个问题，就是首行与首列如果有零怎么办，我们选择用两个变量去保存首行首列是否需要置零的情况。比如，遍历首行，遇到一个零，那么我们知道，首行最后一定是要置零的，列同理，那么我们是不是应该考虑一下先后顺序，比如如果我们先将首行置零了，那接下来我们就无法根据上面的方法去判断哪一行和哪一列需要置零了，因为置零信息全部保存在起始行起始列。所以我们做事的顺序应该是：1.判断首行首列是否需要置零 2.遍历数组将需要置零的行列信息保存在首行首列（注意，遍历数组一定是不能包含首行首列的哦） 3.将蓝色区域置零 4.将粉色区域根据情况看是否置零</span></p><hr><p><span style="font-size: 16px;">这样我们就全部完成了。</span></p><p><span style="font-size: 16px;">代码如下：</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> row_z = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> col_z = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i++)</span><br><span class="line">            <span class="keyword">if</span>(matrix[<span class="number">0</span>][i] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    row_z = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    col_z = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; m ; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)</span><br><span class="line">                matrix[<span class="number">0</span>][j] = matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; m ; i++)</span><br><span class="line">            <span class="keyword">if</span>(matrix[<span class="number">0</span>][i] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; n ; j++)</span><br><span class="line">                    matrix[j][i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; i++)</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; m ; j++)</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(row_z)<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i++) matrix[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(col_z)<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++) matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;73-矩阵置零&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#73-矩阵置零&quot;&gt;¶&lt;/a&gt;73.矩阵置零&lt;/h2&gt;
&lt;h4 class=&quot;css-10c1h40-Title eugt34i1&quot; data-cypress=&quot;QuestionTit</summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>graphics pipeline - 图形管线</title>
    <link href="http://example.com/2021/03/26/graphics1/"/>
    <id>http://example.com/2021/03/26/graphics1/</id>
    <published>2021-03-26T11:18:01.301Z</published>
    <updated>2021-03-26T11:19:39.576Z</updated>
    
    <content type="html"><![CDATA[<h2 id="graphics-pipeline-图形管线"><a class="header-anchor" href="#graphics-pipeline-图形管线">¶</a>graphics pipeline - 图形管线</h2><p>标准图形系统的实施流程通常称为图形管线。&rdquo;管线&ldquo;一词在这里指从数学模型到生成屏幕上像素的过程，它包含多个步骤。在经典的体系结构中，这些步骤是按序执行的，即一个阶段的结果输出给下一个阶段，前面阶段随即开始处理新的多边形。</p><hr><p>管线简化示意图：</p><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210117225547738-1443334944.png" alt="" loading="lazy" /></p><hr><p>在许多情况下，管线的实现细节并非关注点，这时可以把它看成一个黑盒，通过黑盒，场景几何模型被转换为场景多边形的光栅透视投影（这里暂时忽略平行投影情况）图像。</p><hr><p>纹理映射与近似</p><p>　　图形管线中的一个标准模块是纹理映射(texture map)，纹理映射通过查表的方式将纹理图像的颜色映射到一个或多个多边形上。这个过程就像在表面上刻写图案或是将一张花纹纸粘贴到物体上，扫描到系统中的图像，相机拍摄的照片，或者绘图软件制作的图像都是纹理图像，<span style="background-color: #ffff00;">你可以把纹理图案想象成一张有图案的橡胶片，而纹理坐标描述了为了使这张橡胶片能够准确覆盖物体的某些部位，以及橡胶片是如何进行拉伸和变形的</span>。</p><hr><p>个人理解：</p><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210117230232056-878760406.png" alt="" loading="lazy" /></p><hr><p>如上图，就是通过纹理坐标将纹理图案进行一系列拉伸和变形准确覆盖到物体上的对应位置。</p><hr><p>通过纹理映射来指定图像上每个点的颜色仅仅是纹理映射的众多应用之一。例如，一个物体的外观部分取决于表面的法向量，计算光从表面的反射时就涉及法向量，由于表面通常采用多边形网格表示，所以通常在各多边形的顶点处计算表面的法向量，多边形内部各点的法向量则通过插值获得，从而使该物体表面呈现平滑的外观效果。</p><hr><p>上述提到，管线结构能够让我们并行处理很多任务，管线上的每一阶段针对一部分数据执行某个任务，然后将处理结果传送给下一阶段，接着这一阶段立即开始处理下一部分数据，如果管线设计合理，则大大提高处理能力。当然，随着管线所含阶段数的增多，从输入数据到生成最终结果所需的时间总量也将增加。对于交互性要求很高的系统来说，这种滞后或者潜在滞后可能会造成严重影响。</p><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210117231156283-1550082328.png" alt="" loading="lazy" /></p><hr><p>图形管线包括4个主要部分：顶点几何处理和变换，三角形处理（光栅化）和片段（fragment)生成、纹理映射和光照以及用来组装最终图像的片段组合操作。</p><p>在这个更大的管线里，应用程序提供显示所需的数据，而图形管线则生成最终的图像，但在此期间用户可能会输入信息对应用程序进行控制（例如对所显示的图像有所影响），还有从图形管线中返回的信息，他们组合起来，用于计算下一帧画面。</p><hr><p>持续补充。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;graphics-pipeline-图形管线&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#graphics-pipeline-图形管线&quot;&gt;¶&lt;/a&gt;graphics pipeline - 图形管线&lt;/h2&gt;
&lt;p&gt;标准图形系统的实施流程通常称</summary>
      
    
    
    
    <category term="图形学" scheme="http://example.com/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="概念知识" scheme="http://example.com/tags/%E6%A6%82%E5%BF%B5%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Eigen:Matrix and Vector arithmetic</title>
    <link href="http://example.com/2021/03/26/Eigen2/"/>
    <id>http://example.com/2021/03/26/Eigen2/</id>
    <published>2021-03-26T11:12:15.866Z</published>
    <updated>2021-03-26T11:16:57.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Eigen-Matrix-and-Vector-arithmetic"><a class="header-anchor" href="#Eigen-Matrix-and-Vector-arithmetic">¶</a>Eigen:Matrix and Vector arithmetic</h2><p>Eigen库 有重载关于Matrix与Vector的计算符，这样我们可以很方便的得到矩阵运算后的结果。</p><p>一些基本运算符：+,-,*,/,+=,-=,*=,/=</p><hr><p>普通的矩阵加减法运算：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Matrix2d a;</span><br><span class="line">a &lt;&lt; <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line"><span class="number">3</span>, <span class="number">4</span>;</span><br><span class="line"><span class="function">MatrixXd <span class="title">b</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">b &lt;&lt; <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line"><span class="number">1</span>, <span class="number">4</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;a + b =\n&quot;</span> &lt;&lt; a + b &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;a - b =\n&quot;</span> &lt;&lt; a - b &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Doing a += b;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">a += b;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Now a =\n&quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line"><span class="function">Vector3d <span class="title">v</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">Vector3d <span class="title">w</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;-v + w - v =\n&quot;</span> &lt;&lt; -v + w - v &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>Output:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a + b =</span><br><span class="line"><span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="number">8</span></span><br><span class="line">a - b =</span><br><span class="line"><span class="number">-1</span> <span class="number">-1</span></span><br><span class="line"> <span class="number">2</span>  <span class="number">0</span></span><br><span class="line">Doing a += b;</span><br><span class="line">Now a =</span><br><span class="line"><span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="number">8</span></span><br><span class="line">-v + w - v =</span><br><span class="line"><span class="number">-1</span></span><br><span class="line"><span class="number">-4</span></span><br><span class="line"><span class="number">-6</span></span><br></pre></td></tr></table></figure><hr><p>乘法运算：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Matrix2d a;</span><br><span class="line">a &lt;&lt; <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line"><span class="number">3</span>, <span class="number">4</span>;</span><br><span class="line"><span class="function">Vector3d <span class="title">v</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;a * 2.5 =\n&quot;</span> &lt;&lt; a * <span class="number">2.5</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;0.1 * v =\n&quot;</span> &lt;&lt; <span class="number">0.1</span> * v &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Doing v = 2;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">v = <span class="number">2</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Now v =\n&quot;</span> &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>Output:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a * <span class="number">2.5</span> =</span><br><span class="line"><span class="number">2.5</span>   <span class="number">5</span></span><br><span class="line"><span class="number">7.5</span>  <span class="number">10</span></span><br><span class="line"><span class="number">0.1</span> * v =</span><br><span class="line"><span class="number">0.1</span></span><br><span class="line"><span class="number">0.2</span></span><br><span class="line"><span class="number">0.3</span></span><br><span class="line">Doing v *= <span class="number">2</span>;</span><br><span class="line">Now v =</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><hr><p>除此之外，Eigen库关于运算还有个很人性化的地方<br />比如，VectorXf a(50),b(50),c(50),d(50);<br />...<br />a = 3 * b + 4 * c + 5 * d;<br />会自动编译为：<br />for(int i = 0 ; i &lt; 50 ; i++){<br />a[i] = 3*b[i] + 4*c[i] + 5*d[i];<br />}</p><hr><p>注意：如果你看了上面一段关于表达式模板的内容，担心做m=m*m会引起别名问题，暂时放心。Eigen将矩阵乘法作为一种特殊情况处理，并注意在这里引入一个临时的，所以它将把m=m*m编译为：</p><div class="cnblogs_code"><pre>temp = m*<span style="color: #000000;">m;m </span>= temp;</pre></div><hr><p>然后是一些特殊的计算函数，十分便利：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span>() <span class="comment">//矩阵内元素和</span></span><br><span class="line"><span class="built_in">prod</span>() <span class="comment">//元素积</span></span><br><span class="line"><span class="built_in">mean</span>() <span class="comment">//元素平均</span></span><br><span class="line"><span class="built_in">minCoeff</span>() <span class="comment">//最小元素</span></span><br><span class="line"><span class="built_in">maxCoeff</span>() <span class="comment">//最大元素</span></span><br><span class="line"><span class="built_in">trace</span>() <span class="comment">//对角线和</span></span><br><span class="line"><span class="built_in">transpose</span>() <span class="comment">//转置</span></span><br><span class="line"><span class="built_in">conjugate</span>() <span class="comment">//共轭</span></span><br><span class="line"><span class="built_in">adjoint</span>() <span class="comment">//共轭转置</span></span><br></pre></td></tr></table></figure><hr><p>普通计算函数示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Eigen::Matrix2d mat;</span><br><span class="line">mat &lt;&lt; <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line"><span class="number">3</span>, <span class="number">4</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Here is mat.sum():       &quot;</span> &lt;&lt; mat.<span class="built_in">sum</span>()       &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Here is mat.prod():      &quot;</span> &lt;&lt; mat.<span class="built_in">prod</span>()      &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Here is mat.mean():      &quot;</span> &lt;&lt; mat.<span class="built_in">mean</span>()      &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Here is mat.minCoeff():  &quot;</span> &lt;&lt; mat.<span class="built_in">minCoeff</span>()  &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Here is mat.maxCoeff():  &quot;</span> &lt;&lt; mat.<span class="built_in">maxCoeff</span>()  &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Here is mat.trace():     &quot;</span> &lt;&lt; mat.<span class="built_in">trace</span>()     &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Here is mat.<span class="built_in">sum</span>():       <span class="number">10</span></span><br><span class="line">Here is mat.<span class="built_in">prod</span>():      <span class="number">24</span></span><br><span class="line">Here is mat.<span class="built_in">mean</span>():      <span class="number">2.5</span></span><br><span class="line">Here is mat.<span class="built_in">minCoeff</span>():  <span class="number">1</span></span><br><span class="line">Here is mat.<span class="built_in">maxCoeff</span>():  <span class="number">4</span></span><br><span class="line">Here is mat.<span class="built_in">trace</span>():     <span class="number">5</span></span><br></pre></td></tr></table></figure><hr><p>并且minCoeff()与maxCoeff()能够得到相应元素的下标，可使用如下方法实现：</p><p>int i,j;</p><p>minCoeff(&amp;i,&amp;j);</p><p>maxCoeff(&amp;i,&amp;j);</p><p>得到的i,j就是相应元素的横纵坐标。</p><hr><p>转置，共轭，共轭转置示例代码：</p><div class="cnblogs_code"><pre>MatrixXcf a = MatrixXcf::Random(<span style="color: #800080;">2</span>,<span style="color: #800080;">2</span>); <span style="color: #008000;">//</span><span style="color: #008000;">随机2x2矩阵</span>cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">Here is the matrix a\n</span><span style="color: #800000;">"</span> &lt;&lt; a &lt;&lt;<span style="color: #000000;"> endl;<p>cout </span>&lt;&lt; <span style="color: #800000;">“</span><span style="color: #800000;">Here is the matrix a^T\n</span><span style="color: #800000;">”</span> &lt;&lt; a.transpose() &lt;&lt;<span style="color: #000000;"> endl;</p><p>cout </span>&lt;&lt; <span style="color: #800000;">“</span><span style="color: #800000;">Here is the conjugate of a\n</span><span style="color: #800000;">”</span> &lt;&lt; a.conjugate() &lt;&lt;<span style="color: #000000;"> endl;</p><p>cout </span>&lt;&lt; <span style="color: #800000;">“</span><span style="color: #800000;">Here is the matrix a^*\n</span><span style="color: #800000;">”</span> &lt;&lt; a.adjoint() &lt;&lt; endl;</pre></p></div><hr><p>Output:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Here is the matrix a</span><br><span class="line">    (<span class="number">-1</span>,<span class="number">-0.737</span>) (<span class="number">0.0655</span>,<span class="number">-0.562</span>)</span><br><span class="line">(<span class="number">0.511</span>,<span class="number">-0.0827</span>)  (<span class="number">-0.906</span>,<span class="number">0.358</span>)</span><br><span class="line">Here is the matrix a^T</span><br><span class="line">    (<span class="number">-1</span>,<span class="number">-0.737</span>) (<span class="number">0.511</span>,<span class="number">-0.0827</span>)</span><br><span class="line">(<span class="number">0.0655</span>,<span class="number">-0.562</span>)  (<span class="number">-0.906</span>,<span class="number">0.358</span>)</span><br><span class="line">Here is the conjugate of a</span><br><span class="line">     (<span class="number">-1</span>,<span class="number">0.737</span>)  (<span class="number">0.0655</span>,<span class="number">0.562</span>)</span><br><span class="line"> (<span class="number">0.511</span>,<span class="number">0.0827</span>) (<span class="number">-0.906</span>,<span class="number">-0.358</span>)</span><br><span class="line">Here is the matrix a^*</span><br><span class="line">     (<span class="number">-1</span>,<span class="number">0.737</span>)  (<span class="number">0.511</span>,<span class="number">0.0827</span>)</span><br><span class="line"> (<span class="number">0.0655</span>,<span class="number">0.562</span>) (<span class="number">-0.906</span>,<span class="number">-0.358</span>)</span><br></pre></td></tr></table></figure><p>注意：<span style="background-color: #00ffff;">至于基本的算术运算符，transpose()和 adjoint()只是返回一个代理对象，而不进行实际的转置。如果你做b = a.transpose()，那么在将结果写入b的同时就会对transpose进行评估。如果执行a = a.transpose()，那么在转置的评估完成之前，Eigen就开始将结果写入a中。因此，指令a = a.transpose()并不像人们所期望的那样，用它的转置替换a。</span></p><hr><p>还有两个函数差点忘记说了，分别是dot()与cross()，一个是计算点积，一个是计算叉积，非常实用的两个函数！</p><hr><p>补充两个编译时容易出现的错误：（官方文档详细说明）</p><p><a class="el" title="Namespace containing all symbols from the Eigen library." href="http://eigen.tuxfamily.org/dox/namespaceEigen.html">Eigen</a>&nbsp;checks the validity of the operations that you perform. When possible, it checks them at compile time, producing compilation errors. These error messages can be long and ugly, but&nbsp;<a class="el" title="Namespace containing all symbols from the Eigen library." href="http://eigen.tuxfamily.org/dox/namespaceEigen.html">Eigen</a>&nbsp;writes the important message in UPPERCASE_LETTERS_SO_IT_STANDS_OUT. For example:（Eigen会检查你所执行的操作的有效性，在可能的情况下，它会在编译时检查它们，产生编译错误。在可能的情况下，它在编译时检查它们，产生编译错误。这些错误信息可能又长又丑，但Eigen会把重要的信息用UPPERCASE_LETTERS_SO_IT_STANDS_OUT写出来，如下：）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Matrix3f m;</span><br><span class="line">Vector4f v;</span><br><span class="line">v = m*v; <span class="comment">// Compile-time error: YOU_MIXED_MATRICES_OF_DIFFERENT_SIZES</span></span><br></pre></td></tr></table></figure><div class="line"><span class="comment">Of course, in many cases, for example when checking dynamic sizes, the check cannot be performed at compile time.&nbsp;<a class="el" title="Namespace containing all symbols from the Eigen library." href="http://eigen.tuxfamily.org/dox/namespaceEigen.html">Eigen</a>then uses runtime assertions. This means that the program will abort with an error message when executing an illegal operation if it is run in "debug mode", and it will probably crash if assertions are turned off（当然，在很多情况下，比如检查动态大小时，不能在编译时进行检查。Eigen就会使用运行时断点。这意味着，如果在 "debug模式 "下运行，程序在执行非法操作时，会以错误信息中止，如果断点被关闭，程序很可能会崩溃）.</span></div><div class="line">&nbsp;</div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MatrixXf <span class="title">m</span><span class="params">(<span class="number">3</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">VectorXf <span class="title">v</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">v = m * v; <span class="comment">// Run-time assertion failure here: &quot;invalid matrix product&quot;</span></span><br></pre></td></tr></table></figure><p><span class="comment">解释：第一个就是两种不同类型的矩阵相乘会出现SIZE报错，这是理所当然的，第二个就是检查动态大小时，不能在编译时进行检查！</span></p></div><hr><p>有些内容暂时用不到，以后补充。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Eigen-Matrix-and-Vector-arithmetic&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#Eigen-Matrix-and-Vector-arithmetic&quot;&gt;¶&lt;/a&gt;Eigen:Matrix and Vector</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="Eigen" scheme="http://example.com/tags/Eigen/"/>
    
  </entry>
  
  <entry>
    <title>Eigen:The Matrix Class</title>
    <link href="http://example.com/2021/03/26/Eigen1/"/>
    <id>http://example.com/2021/03/26/Eigen1/</id>
    <published>2021-03-26T11:05:43.527Z</published>
    <updated>2021-03-26T11:11:24.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="The-Matrix-Class"><a class="header-anchor" href="#The-Matrix-Class">¶</a>The Matrix Class</h2><p>Eigen库 矩阵类的使用：</p><p>（本文根据官方文档加上自己的一些理解修改制成）</p><hr><p>首先关于Matrix的定义：&nbsp; Matrix&lt;typename scalar, int RowsAtCompileTime, int ColsAtCompileTime&gt; 这是常用的模板，一般为三个参数，也就是Matrix&lt;矩阵变量类型，行数，列数&gt;.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">　　　　　　　　　　　 Matrix&lt;<span class="keyword">typename</span> Scalar, <span class="comment">//标量类型</span></span><br><span class="line"></span><br><span class="line">　　　　　　　　　　　　　    <span class="keyword">int</span> RowsAtCompileTime, <span class="comment">//行数</span></span><br><span class="line"></span><br><span class="line">　　　　　　　　　　　　　　  <span class="keyword">int</span> ColsAtCompileTime,<span class="comment">//列数</span></span><br><span class="line"></span><br><span class="line"> 　　　　　　　　　　　　　　 <span class="keyword">int</span> Options = <span class="number">0</span>,<span class="comment">//位域</span></span><br><span class="line"></span><br><span class="line">　　　　　　　　　　　　      <span class="keyword">int</span> MaxRowsAtCompileTime = RowsAtCompileTime,<span class="comment">//最大行数</span></span><br><span class="line"></span><br><span class="line">　　　　　　　　　　　　　　  <span class="keyword">int</span> MaxColsAtCompileTime = ColsAtCompileTime&gt; <span class="comment">//最大列数</span></span><br></pre></td></tr></table></figure><p><em>使用Eigen库定义一个矩阵: Matrix&lt;int,2,2&gt; 这是一个int类型的2x2矩阵</em></p><p><em>　　　　　　　　　　　　Matrix&lt;float,3,3&gt;这是一个float类型的3x3矩阵</em></p><hr><p><em>Eigen库中简化了部分以上定义的过程，一般用于固定尺寸的矩阵的定义。</em></p><p><em>例如：&nbsp; Matrix2f,Matrix3f,Matrix4f&nbsp; float类型的2x2,3x3,4x4的矩阵(可见结尾部分为f）</em></p><p><em>&nbsp; &nbsp; &nbsp;同理Matrix2d,Matrix3d,Matrix4d,Matrix2i,Matrix3i,Matrix4i,只需要看最后结尾的字母，即可明白变量类型(double,int)</em></p><p>Eigen还有个常用的概念，向量，向量是矩阵中的特殊情况，表现为有一行或一列，也就是行向量和列向量，最常见的情况是只有一列，表现方式有：</p><p>　　　　　　　　　　　&nbsp; typedef Matrix&lt;float, 3, 1&gt; Vector3f;&nbsp; //列向量</p><p>　　　　　　　　　　　&nbsp; typedef Matrix&lt;int, 1, 2&gt; RowVector2i; //行向量</p><hr><p>接下来说明它们各自的赋值方式以及特殊情况：</p><p>静态矩阵下有如下的初始化方式:&nbsp; Vector2i myvector(1,2);&nbsp; 表示初始化一个列向量为<img src="https://img2020.cnblogs.com/blog/1582514/202012/1582514-20201230135221369-1383356973.png" alt="" loading="lazy" />&nbsp;或者 Vector2f myvector(1.0,2.0); 表示初始化一个列向量为<img src="https://img2020.cnblogs.com/blog/1582514/202012/1582514-20201230135913953-1373528500.png" alt="" loading="lazy" /></p><hr><p>向量能这样初始化，但Matrix就不行了，比如Matrix3f a(3,3)虽然编译能够通过，不会报错，但是这样的传递参数是无效的， 在官方文档有解释：In order to offer a uniform API across fixed-size and dynamic-size matrices, it is legal to use these constructors on fixed-size matrices, even if passing the sizes is useless in this case. 意思是：为了在固定大小和动态大小的矩阵上提供统一的API，在固定大小的矩阵上使用这些构造函数是合法的，即使在这种情况下传递大小是无用的。</p><hr><p>所以只能使用规定的输入方法： Matrix3f a;</p><p>　　　　　　　　　　　　　　 a&lt;&lt;1,2,3,</p><p>　　　　　　　　　　　　　　&nbsp; &nbsp; &nbsp; &nbsp;4,5,6,</p><p>　　　　　　　　　　　　　　　　7,8,9;</p><hr><p>说完静态矩阵，接下来说动态矩阵：typedef Matrix &lt;double,Dynamic,Dynamic&gt; MatrixXd;</p><p>看如下对比即可明白：</p><p>一般Matrix4f mymatrix; 等价于 float mymatrix[16];<br />一般MatrixXf mymatrix(rows,columns); 等价于 float *mymatrix = new float[rows*columns];</p><hr><p>所以有 MatrixXf a(2,2) 即定义一个2x2的矩阵，而且Eigen库有访问矩阵中值的特定方式。</p><p>如<img src="https://img2020.cnblogs.com/blog/1582514/202012/1582514-20201230140825999-966352070.png" alt="" loading="lazy" />，&nbsp;</p><hr><p>访问第一行第一个元素 即 a(0,1) ,也可 a(0,1) = x 为第一行第一个元素赋值。</p><p>如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">MatrixXd <span class="title">m</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="built_in">m</span>(<span class="number">0</span>,<span class="number">0</span>) = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">m</span>(<span class="number">1</span>,<span class="number">0</span>) = <span class="number">2.5</span>;</span><br><span class="line"><span class="built_in">m</span>(<span class="number">0</span>,<span class="number">1</span>) = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">m</span>(<span class="number">1</span>,<span class="number">1</span>) = <span class="built_in">m</span>(<span class="number">1</span>,<span class="number">0</span>) + <span class="built_in">m</span>(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Here is the matrix m:\n&quot;</span> &lt;&lt; m &lt;&lt; std::endl;</span><br><span class="line"><span class="function">VectorXd <span class="title">v</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="built_in">v</span>(<span class="number">0</span>) = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">v</span>(<span class="number">1</span>) = <span class="built_in">v</span>(<span class="number">0</span>) - <span class="number">1</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Here is the vector v:\n&quot;</span> &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Here is the matrix m:</span><br><span class="line">  <span class="number">3</span>  <span class="number">-1</span></span><br><span class="line"><span class="number">2.5</span> <span class="number">1.5</span></span><br><span class="line">Here is the vector v:</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>像这类动态分配大小的矩阵，有 resize()方法，可以重新定义大小，这篇代码写的很清楚：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">MatrixXd <span class="title">m</span><span class="params">(<span class="number">2</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">m.<span class="built_in">resize</span>(<span class="number">4</span>,<span class="number">3</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;The matrix m is of size &quot;</span></span><br><span class="line">&lt;&lt; m.<span class="built_in">rows</span>() &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; m.<span class="built_in">cols</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;It has &quot;</span> &lt;&lt; m.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; coefficients&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="function">VectorXd <span class="title">v</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">v.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;The vector v is of size &quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;As a matrix, v is of size &quot;</span></span><br><span class="line">&lt;&lt; v.<span class="built_in">rows</span>() &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; v.<span class="built_in">cols</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The matrix m is of size <span class="number">4</span>x3</span><br><span class="line">It has <span class="number">12</span> coefficients</span><br><span class="line">The vector v is of size <span class="number">5</span></span><br><span class="line">As a matrix, v is of size <span class="number">5</span>x1</span><br></pre></td></tr></table></figure><hr><p>&nbsp;然后说明一下固定尺寸与动态尺寸的选择问题，也就是什么时候静态分配最好，什么时候动态分配最好。</p><p>&nbsp;对于非常小的尺寸，尽可能使用Fixed（一般定义为小于等于16），这种情况下使用Fixed尺寸性能更加优越,因为它可以让Eigen避免动态内存分配和展开循环，对于较大尺寸的话就使用dynamic尺寸，</p><p>&nbsp;当然，使用固定大小的局限性在于，只有在编译时知道大小时才有可能。另外，对于足够大的尺寸，比如说大于或等于32的尺寸，使用固定尺寸的性能优势就变得微不足道了。更糟糕的是，如果试图在函数中使用固定大小创建一个非常大&nbsp; &nbsp;的矩阵，可能会导致堆栈溢出，因为Eigen会尝试将数组作为一个局部变量自动分配，而这通常是在堆栈中完成的。最后，根据不同的情况，当使用动态大小时，Eigen还可以更积极地尝试矢量化（使用SIMD指令）。</p><hr><p>&nbsp;最后解释一下上面说过的可选参数模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Matrix&lt;<span class="keyword">typename</span> Scalar,</span><br><span class="line">　　　　　　<span class="keyword">int</span> RowsAtCompileTime,</span><br><span class="line">　　　　　　<span class="keyword">int</span> ColsAtCompileTime,</span><br><span class="line">　　　　　　<span class="keyword">int</span> Options = <span class="number">0</span>,</span><br><span class="line">　　　　　　<span class="keyword">int</span> MaxRowsAtCompileTime = RowsAtCompileTime,</span><br><span class="line">　　　　　　<span class="keyword">int</span> MaxColsAtCompileTime = ColsAtCompileTime&gt;</span><br></pre></td></tr></table></figure><p>从参数的定义名即可看出来其大概意思。</p><p>分析：Matrix&lt;float,Dynamic,Dynamic,0,3,4&gt;&nbsp; 一个不知道大小，但最大行数为3，最大列数为4的矩阵。<br />从官方文档对于Matrix Optional template parameters 的定义来看，这是一个确定了上限的固定内存矩阵，如果在编译时不知道矩阵的确切大小，但在编译时可以知道一个固定的上限，这样做可以避免动态内存分配。</p><p>第三个参数是什么意思呢，在我看来是一个优先级的参数，比如一个矩阵是行优先还是列优先就是使用这个参数，0一般是默认值，不设置任何优先。</p><p>比如：Matrix&lt;float,3,3,RowMajor&gt; 就是一个行优先的矩阵。</p><hr><p>补充Eigen便利类型定义：</p><p><a class="el" title="Namespace containing all symbols from the Eigen library." href="http://eigen.tuxfamily.org/dox/namespaceEigen.html">Eigen</a>&nbsp;defines the following&nbsp;<a class="el" title="The matrix class, also used for vectors and row-vectors." href="http://eigen.tuxfamily.org/dox/classEigen_1_1Matrix.html">Matrix</a>&nbsp;typedefs:</p><ul><li>MatrixNt for Matrix&lt;type, N, N&gt;. For example, MatrixXi for Matrix&lt;int, Dynamic, Dynamic&gt;.</li><li>VectorNt for Matrix&lt;type, N, 1&gt;. For example, Vector2f for Matrix&lt;float, 2, 1&gt;.</li><li>RowVectorNt for Matrix&lt;type, 1, N&gt;. For example, RowVector3d for Matrix&lt;double, 1, 3&gt;.</li></ul><p>Where:</p><ul><li>N can be any one of&nbsp;<code>2</code>,&nbsp;<code>3</code>,&nbsp;<code>4</code>, or&nbsp;<code>X</code>&nbsp;(meaning&nbsp;<code>Dynamic</code>).</li><li>t can be any one of&nbsp;<code>i</code>&nbsp;(meaning int),&nbsp;<code>f</code>&nbsp;(meaning float),&nbsp;<code>d</code>&nbsp;(meaning double),&nbsp;<code>cf</code>&nbsp;(meaning complex&lt;float&gt;), or&nbsp;<code>cd</code>(meaning complex&lt;double&gt;). The fact that typedefs are only defined for these five types doesn't mean that they are the only supported scalar types. For example, all standard integer types are supported, see&nbsp;<a class="el" href="http://eigen.tuxfamily.org/dox/TopicScalarTypes.html">Scalar types</a>.</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;The-Matrix-Class&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#The-Matrix-Class&quot;&gt;¶&lt;/a&gt;The Matrix Class&lt;/h2&gt;
&lt;p&gt;Eigen库 矩阵类的使用：&lt;/p&gt;
&lt;p&gt;（本文根据官方文档加上自</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="Eigen" scheme="http://example.com/tags/Eigen/"/>
    
  </entry>
  
  <entry>
    <title>线性代数及其应用(二)</title>
    <link href="http://example.com/2021/03/26/lial2/"/>
    <id>http://example.com/2021/03/26/lial2/</id>
    <published>2021-03-26T11:00:38.711Z</published>
    <updated>2021-03-26T11:05:08.478Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线性代数及其应用-二"><a class="header-anchor" href="#线性代数及其应用-二">¶</a>线性代数及其应用(二)</h2><p>向量方程</p><p>线性方程组的重要性质都可用向量概念与符号来描述。</p><p><strong>R</strong><sup>2</sup>中的向量:</p><p>　　仅含一列的矩阵称为列向量，或简称向量，包含两个元素的向量如下：</p><p>　　<img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114203419813-1752537434.png" alt="" loading="lazy" /><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114203438965-2116671834.png" alt="" loading="lazy" /><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114203521345-1191418457.png" alt="" loading="lazy" /></p><hr><p>&nbsp;　&nbsp; 其中w<sub>1</sub>和w<sub>2</sub>是任意实数，所有两个元素的向量集记为<strong>R</strong><sup>2</sup>，<strong>R</strong>表示向量中的元素是实数，而指数2表示每个向量包含两个元素.&nbsp;</p><p>　　给定<strong>R</strong><sup>2</sup>中两个向量u和v，它们的和u+v是把u和v对应元素相加所得的向量，如</p><p>　　<img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114203944587-551626870.png" alt="" loading="lazy" /></p><hr><div class="cnblogs_code"><pre><span style="color: #000000;">\begin{bmatrix}</span><span style="color: #800080;">1</span><span style="color: #000000;">\\ </span>-<span style="color: #800080;">2</span><span style="color: #000000;">\\\end{bmatrix}</span>+<span style="color: #000000;">\begin{bmatrix}</span><span style="color: #800080;">2</span><span style="color: #000000;">\\ </span><span style="color: #800080;">5</span><span style="color: #000000;">\\\end{bmatrix}</span>=<span style="color: #000000;">\begin{bmatrix}</span><span style="color: #800080;">1</span>+<span style="color: #800080;">2</span><span style="color: #000000;">\\ </span>-<span style="color: #800080;">2</span>+<span style="color: #800080;">5</span><span style="color: #000000;">\\\end{bmatrix}</span>=<span style="color: #000000;">\begin{bmatrix}</span><span style="color: #800080;">3</span><span style="color: #000000;">\\ </span><span style="color: #800080;">3</span><span style="color: #000000;">\\\end{bmatrix}</span></pre></div><hr><p>　　给定向量u和实数c,u与c的标量乘法（或数乘）是把u的每个元素乘以c,所得向量记为cu，例如：</p><p>　　若<img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114204144474-273683973.png" alt="" loading="lazy" />;, c = 5,则</p><hr><p>&nbsp; &nbsp; &nbsp; &nbsp;<img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114204235817-645942824.png" alt="" loading="lazy" /></p><hr><div class="cnblogs_code"><pre>cu = <span style="color: #800080;">5</span><span style="color: #000000;">\begin{bmatrix}</span><span style="color: #800080;">3</span><span style="color: #000000;">\\ </span>-<span style="color: #800080;">1</span><span style="color: #000000;">\\\end{bmatrix}</span>=<span style="color: #000000;">\begin{bmatrix}</span><span style="color: #800080;">15</span><span style="color: #000000;">\\ </span>-<span style="color: #800080;">5</span><span style="color: #000000;">\\\end{bmatrix}</span></pre></div><hr><p><strong>&nbsp;R</strong><sup>2</sup>的几何表示</p><p>　　考虑平面上的直角坐标系，因为平面上每个点由实数的有序对确定，所以可把几何点(a,b) 与列向量<img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114204443579-1598459939.png" alt="" loading="lazy" />等同，因此我们可把R<sup>2</sup>看作平面上所有点的集合</p><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114204712781-911184167.png" alt="" loading="lazy" />&nbsp;&nbsp;<hr><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114204820571-445091784.png" alt="" loading="lazy" /></p></p><hr><p>&nbsp;　　两个向量的和的几何意义</p><p>　　<img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114205154150-1250560095.png" alt="" loading="lazy" /></p><hr><p>　　<strong>R</strong><sup>3</sup>中的向量</p><p>　　<img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114205719156-1126824442.png" alt="" loading="lazy" /></p><hr><p>　　<strong>R</strong><sup>n</sup>中的代数性质 （对<strong>R</strong><sup>n</sup>中一切向量u,v,w以及标量c和d）：</p><p>　　1. u + v = v + u</p><p>　　2.(u+v)+w = u+(v+w)</p><p>　　3.(u+0)=0+u=u</p><p>　　4.u+(-u) = -u+u =0</p><p>　　5.c(u+v)=cu+cv</p><p>　　6.(c+d)u=cu+du</p><p>　　7.c(du)=(cd)u</p><p>　　8.1u=u</p><hr><p>　　线性代数的一个主要思想是研究可以表示为某一个固定向量集合{v<sub>1</sub>,v<sub>2</sub>,....v<sub>p</sub>}的线性组合的所有向量</p><p>　　Span{v} 与 Span{u,v}的几何解释</p><p>　　设v是<strong>R</strong><sup>3</sup>中的向量，那么Span{v}就是v的所有标量倍数的集合，也就是<strong>R</strong><sup>3</sup>中通过v和0的直线上所有点的集合</p><p>　　</p><p>&nbsp;　　<img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114210420986-390914887.png" alt="" loading="lazy" /></p><hr><p>　　　若u和v是<strong>R</strong><sup>3</sup>中的非零向量，v不是u的倍数，则Span{u,v}是<strong>R</strong><sup>3</sup>中包含u,v和0的平面，特别地，Span{u,v}包含<strong>R</strong><sup>3</sup>中通过u与0的直线，也包含通过v与0的直线，反正就是确定了一个平面。</p><p>　　　　</p><p>&nbsp;　　<img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114210841656-276500780.png" alt="" loading="lazy" /></p><hr><p>&nbsp;　　蓝色范围在概念上无限扩充。</p><p>&nbsp;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;线性代数及其应用-二&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#线性代数及其应用-二&quot;&gt;¶&lt;/a&gt;线性代数及其应用(二)&lt;/h2&gt;
&lt;p&gt;向量方程&lt;/p&gt;
&lt;p&gt;线性方程组的重要性质都可用向量概念与符号来描述。&lt;/p&gt;
&lt;p&gt;&lt;strong</summary>
      
    
    
    
    <category term="数学" scheme="http://example.com/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="线性代数" scheme="http://example.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>线性代数及其应用(一)</title>
    <link href="http://example.com/2021/03/26/lial1/"/>
    <id>http://example.com/2021/03/26/lial1/</id>
    <published>2021-03-26T10:58:34.458Z</published>
    <updated>2021-03-26T11:00:26.140Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线性代数及其应用-一"><a class="header-anchor" href="#线性代数及其应用-一">¶</a>线性代数及其应用(一)</h2><p>线性方程组：</p><p>包含变量x<sub>1</sub>,x<sub>2</sub>，&hellip;&hellip;，x<sub>n</sub>的线性方程是形如</p><p>　　　　　　　　　　a<sub>1</sub>x<sub>2</sub> +a<sub>2</sub>x<sub>2</sub>+...+a<sub>3</sub>x<sub>3</sub>&nbsp; = b&nbsp;</p><p>的方程，其中b与系数a<sub>1&nbsp; &nbsp;</sub>，a<sub>2&nbsp;</sub>&nbsp;，&hellip;&hellip; ，a<sub>n是实数或者复数，通常是已知数，下标n可以是任意正整数。</sub><sub><br /></sub></p><hr><p>线性方程组的解有下列三种情况：</p><p>①无解</p><p>②有唯一解</p><p>③有无穷多解</p><hr><p>若一个线性方程组有一个解或无穷多个解，则称它是相容的，若它无解，则称它是不相容的。</p><hr><p>初等行变换：</p><p>①（倍加变换）把某一行换成它本身与另一行的倍数的和</p><p>②（对换变换）把两行对换</p><p>③（倍乘对换）把某一行的所有元素乘以同一个非零数</p><hr><p>行变换可以施与任何矩阵，不仅仅是对于线性方程组的增广矩阵，若其中一个矩阵可以经过一系列初等行变换变换成另外一个矩阵，则我们称这两个矩阵是等价的。</p><p>若两个线性方程组的增广矩阵是行等价的，则它们具有相同的解集。</p><hr><p>行简化与阶梯形矩阵</p><p>定义：一个矩阵称为阶梯形（或行阶梯形），则它有已下三个性质：</p><p>①每一非零行都在每一零行之上</p><p>②某一行的先导元素所在的列位于前一行先导元素的右边</p><p>③某一先导元素所在列下方元素都是零</p><p>一个矩阵称为简化阶梯形，则它满足以下性质：</p><p>①每一非零行的先导元素是1</p><p>②每一先导元素1是该元素所在列的唯一非零元素</p><hr><p>通常将矩阵变换成简化阶梯形矩阵的过程称为高斯消元法。（计算机程序通常选择一列中绝对值最大的元素作为主元，可以减少舍入误差）</p><p>但某些条件下高斯消元法不适用，使用的是部分主元法（列主元高斯消元法）</p><hr><p>原因：</p><p>&nbsp;</p><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210111155846873-924934418.png" alt="" loading="lazy" /></p><hr><p>&nbsp;<img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210111155905395-20983245.png" alt="" loading="lazy" /></p><hr><p>&nbsp;图片来自：<a href="https://www.zhihu.com/question/33862337">https://www.zhihu.com/question/33862337</a></p><hr><p>部分主元法思想：在进行第k(k=1,2,3...n-1)步消元时，从第k列的a<sub>kk</sub>及其以下的各元素中选取绝对值最大的元素，然后通过行变换将它交换到主元素a<sub>kk</sub>的位置上，再进行消元。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;线性代数及其应用-一&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#线性代数及其应用-一&quot;&gt;¶&lt;/a&gt;线性代数及其应用(一)&lt;/h2&gt;
&lt;p&gt;线性方程组：&lt;/p&gt;
&lt;p&gt;包含变量x&lt;sub&gt;1&lt;/sub&gt;,x&lt;sub&gt;2&lt;/sub&gt;，&amp;hell</summary>
      
    
    
    
    <category term="数学" scheme="http://example.com/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="线性代数" scheme="http://example.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++关于数据和函数</title>
    <link href="http://example.com/2021/03/26/C++datafuc/"/>
    <id>http://example.com/2021/03/26/C++datafuc/</id>
    <published>2021-03-26T10:51:03.688Z</published>
    <updated>2021-03-26T10:55:26.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-关于数据和函数"><a class="header-anchor" href="#C-关于数据和函数">¶</a>C++关于数据和函数</h2><p><span style="color: #000000; font-size: 14pt;">C++关于数据和函数</span></p><p>C语言在设计程序的时候会准备一些数据和函数，函数用来处理你创造的数据，这样会有一些缺点，由于语言没有提供足够的关键字，所以这些数据一定是全局的，所以所有的函数都可以处理这些数据，在后期会造成很大的影响的，所以面向对象语言C++出现了，基本思想是把数据和处理这些数据的函数包装在一起，也就是&ldquo;类&rdquo;，类其实和结构体是差不多的。</p><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210111195119606-1812816107.png" alt="" loading="lazy" /></p><hr><p>类是否涉及指针，一定要特别注意</p><p>Class 的 两个经典分类：</p><p>&middot;Class without pointer member(s)</p><p>&middot;Class with pointer member(s)</p><hr><p><span style="font-size: 14pt;">C++ program 代码基本形式</span></p><p>&nbsp;</p><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210111195754227-2039798270.png" alt="" loading="lazy" /></p><hr><p>&nbsp;.h 头文件 与 .cpp 代码程序</p><p>用#include的方法使用头文件，标准库也是类似。</p><p>使用自己的写的头文件使用双引号"",默认库使用尖括号&lt;&gt;</p><p>延伸文件名不一定是.h或.cpp</p><p>也可能是.hpp甚至是无延伸名</p><p>在不同的平台上可能不同。</p><p>Header头文件中的防卫式声明</p><p>#ifndef _XXX_&nbsp; &nbsp; &nbsp; &nbsp;//if not define 如果没有被定义（引用）过</p><p>#define _XXX_&nbsp; &nbsp; &nbsp; //则执行下列代码直到#endif</p><p>...</p><p>...</p><p>#endif&nbsp; //若第一行判定被定义过，则直接跳到#endif</p><p>作用是避免多重调用,出现重定义错误！</p><hr><p>比如 我在 Main.cpp 中&nbsp;</p><div class="cnblogs_code"><pre>#include<span style="color: #800000;">"</span><span style="color: #800000;">op1.h</span><span style="color: #800000;">"</span><span style="color: #000000;">#include</span><span style="color: #800000;">"</span><span style="color: #800000;">op2.h</span><span style="color: #800000;">"</span><span style="color: #000000;">.........</span></pre></div><p>而在op2.h中</p><div class="cnblogs_code"><pre>#include<span style="color: #800000;">"</span><span style="color: #800000;">op1.h</span><span style="color: #800000;">"</span><span style="color: #000000;">.........</span></pre></div><p>&nbsp;这样就形成了多重调用，因为op2.h中包含了op1.h，而在Main.cpp中既调用了op2.h也调用了op1.h。</p><p>&nbsp;<span style="color: #ff0000;">所以要养成写任何一个头文件都要使用#ifndef来避免重定义的习惯。</span></p><hr><p>既然有 #ifndef ，所以也有#ifdef</p><p>当在不同平台下编写代码时，由于环境不同，所以要使用的头文件也会不同，这时就可以用到#ifdef</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> OS_Win</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> OS_Linux</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这样就实现了windows环境下调用windows.h 而Linux环境下则调用linux.h。</p><p>Class 的声明（拿complex来举例）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">complex</span> (<span class="keyword">double</span> r = <span class="number">0</span> , <span class="keyword">double</span> i = <span class="number">0</span> ) <span class="comment">//构造函数</span></span><br><span class="line">    : <span class="built_in">re</span>(r),<span class="built_in">im</span>(i)</span><br><span class="line">   &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    complex&amp; <span class="keyword">operator</span> += (<span class="keyword">const</span> complex&amp;); <span class="comment">//重载+=</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">real</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> re;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> im;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> re,im;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>public: 下的函数或者数据都是可以直接给外界访问的，而private：下的函数或数据只能内部访问。实现数据与函数封装。</p><hr><p>class template(模板）</p><p>当你使用大量同一种数据类型的变量的时候，突然想改变这些变量的数据类型，那么一条一条代码去改是很难实现的，就比如上面有变量re和im，我想同时改变它们两个的数据类型，首先是变量声明那改成另一种数据类型，但是还有相关函数呢，返回的也是double类型，也需要更改，而且构造函数中传入的参数也是double类型，几乎所有地方都要修改，这样就显得极其麻烦，而且如果想通过不同的情况随时更改无法实现，灵活性也极差。</p><p>那么就使用到了&ldquo;模板&rdquo;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">complex</span> (T r = <span class="number">0</span> , T = <span class="number">0</span> ) <span class="comment">//构造函数</span></span><br><span class="line">    : <span class="built_in">re</span>(r),<span class="built_in">im</span>(i)</span><br><span class="line">   &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    complex&amp; <span class="keyword">operator</span> += (<span class="keyword">const</span> complex&amp;); <span class="comment">//重载+=</span></span><br><span class="line">    <span class="function">T <span class="title">real</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> re;&#125;</span><br><span class="line">    <span class="function">T <span class="title">imag</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> im;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T re;</span><br><span class="line">    T im;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">...主函数...</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">complex&lt;<span class="keyword">double</span>&gt; <span class="title">c1</span><span class="params">(<span class="number">2.5</span>,<span class="number">1.5</span>)</span></span>;</span><br><span class="line">    <span class="function">complex&lt;<span class="keyword">int</span>&gt; <span class="title">c1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就想使用double类型就用double模板，使用int类型就用int模板。灵活性强。</p><hr><p>关于 避免头文件重定义的补充：</p><p>我们已经知道一种方法 #ifndef</p><p>还有一种方法是 #pragma once</p><p>那么这两种方法有什么区别呢？</p><p>#ifndef 因为要定义宏名，如果出现两个头文件定义的宏名相同的话，可能会导致使用该头文件，但编译器找不到。</p><p>#pragma once则由编译器提供保证：同一个文件不会被包含多次。且这个文件是物理上的文件，缺点是如果物理文件被拷贝多次会导致无法避免重定义，且不支持跨平台。</p><hr><p>所以两种方法的使用需要根据情况来把握。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-关于数据和函数&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#C-关于数据和函数&quot;&gt;¶&lt;/a&gt;C++关于数据和函数&lt;/h2&gt;
&lt;p&gt;&lt;span style=&quot;color: #000000; font-size: 14pt;&quot;&gt;C++关于数据</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++学习" scheme="http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>C++ 重载</title>
    <link href="http://example.com/2021/03/26/C++opcz/"/>
    <id>http://example.com/2021/03/26/C++opcz/</id>
    <published>2021-03-26T10:46:25.415Z</published>
    <updated>2021-03-26T10:50:22.917Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-重载"><a class="header-anchor" href="#C-重载">¶</a>C++ 重载</h2><p>操作符就是一种函数，是可以让你重新定义的<br />比如说相加，与其自己写个相加函数 plus(u,v); 将u,v相加，<br />用 "+" 号 显得更为方便，可读性更高，所以C++就出现了重载运算符这个功能。<br />并且可以实现将各种你需要的属性相加。</p><p>一般来说，重载操作符的对象会有接收者和传递者</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> complex&amp;</span><br><span class="line">complex::<span class="keyword">operator</span> += (<span class="keyword">this</span>,<span class="keyword">const</span> complex&amp; r)&#123;</span><br><span class="line"><span class="keyword">return</span> __doapl(<span class="keyword">this</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面那个this,是不需要写的  比如 complex c1,c2;<br />c1 += c2;<br />c1就是this。代表操作对象中的接收者。<br />所以一般会这么写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> complex&amp;</span><br><span class="line">complex::<span class="keyword">operator</span> += (<span class="keyword">const</span> complex&amp; r)&#123; <span class="comment">//省略了this</span></span><br><span class="line"><span class="keyword">return</span> __doapl(<span class="keyword">this</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>return by reference语法分析<br />传递者无需知道接收者是以什么形式接收</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> complex&amp; __doapl(complex * ths,<span class="keyword">const</span> complex&amp; r)&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> *ths;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> complex&amp;</span><br><span class="line">complex::<span class="keyword">operator</span> += (<span class="keyword">const</span> complex&amp; r)&#123;</span><br><span class="line"><span class="keyword">return</span> __doapl(<span class="keyword">this</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>可以看到 第一个函数明明是 complex&amp; __doapl(...)<br />返回的却是一个value,return *ths, 这里是没有错误的，因为C++有个特性，就是return by reference,一般来说返回一个引用，会比返回一个值快很多，接收者与其接收其值，不如接收它的引用（也就是地址），而且传递者也不需要知道接收者如何接收，这样下来整个程序会快很多，避免了很多转换。<br />complex::operator += (const complex&amp; r) 也是一样，接收的是 c2 的引用，而不需要接收c2的值，直接通过引用去得到它的值，比起创建一个临时空间去转换去获取它的值要快的多。</p><hr><p>temp object(临时对象) typename();<br />刚刚说到了return by reference 比传value快，但下面这些情况，是一定不能return by reference的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="function">complex <span class="title">c1</span><span class="params">(<span class="number">2</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">complex c2;</span><br><span class="line">c2 = c1 + c2;</span><br><span class="line">c2 = c1 + <span class="number">5</span>;</span><br><span class="line">c2 = <span class="number">7</span> + c1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对应 c1 + c2</span></span><br><span class="line"><span class="keyword">inline</span> complex</span><br><span class="line"><span class="keyword">operator</span> + (<span class="keyword">const</span> complex&amp; x,<span class="keyword">const</span> complex&amp; y)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">complex</span> (<span class="built_in">real</span>(x) + <span class="built_in">real</span>(y) , <span class="built_in">imag</span>(x) + <span class="built_in">imag</span>(y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对应 c1 + 5</span></span><br><span class="line"><span class="keyword">inline</span> complex</span><br><span class="line"><span class="keyword">operator</span> + (<span class="keyword">const</span> complex&amp; x,<span class="keyword">double</span> y)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">complex</span> (<span class="built_in">real</span>(x) + y , <span class="built_in">imag</span>(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//对应 5 + c1</span></span><br><span class="line"><span class="keyword">inline</span> complex</span><br><span class="line"><span class="keyword">operator</span> + (<span class="keyword">double</span> x,<span class="keyword">const</span> complex&amp; y)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">complex</span> (x + <span class="built_in">real</span>(y) , <span class="built_in">imag</span>(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里也看出来 + 操作也分很多种不同情况。<br />为什么这里不能传引用呢，可以跟刚才的对比一下，<br />因为刚才我们传引用之后进行 += 操作之后，是将结果直接传给了C1，而现在我们没有一个地方存放结果，如果传引用，函数一结束，直接死亡，就等于什么也没做，所以我们需要一个临时complex对象，去存放结果，再将临时对象的结果返回到 c2 , 这样才是正确的，然后销毁临时对象。</p><p>注：typename() 就等于是创建临时变量，像上面的 complex( ... , ... )，也可以是int(7),double(3.65)等等...</p><hr><p>最后是关于返回类型的注意事项<br />比如说：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> complex&amp;</span><br><span class="line">complex::<span class="keyword">operator</span> += (<span class="keyword">const</span> complex&amp; r)&#123;</span><br><span class="line"><span class="keyword">return</span> __doapl(<span class="keyword">this</span>,r);</span><br><span class="line">&#125;</span><br><span class="line">改成：</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">complex::<span class="keyword">operator</span> += (<span class="keyword">const</span> complex&amp; r)&#123;</span><br><span class="line"><span class="keyword">return</span> __doapl(<span class="keyword">this</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会引起什么问题呢<br />如果说是 c1+=c2; 这样依然不会有任何问题，因为c2赋值到c1上（也就是执行__doapl()之后就完成了）<br />不用再管接下来返回的是什么类型了，所以改成void是没有问题的。<br />但如果是 c3 += c2 += c1;呢，当c1 赋值到 c2 上后，c2必须还要以 complex 类型 加到c3身上，如果返回的是void类型，那么是无法加到c3上面的，所以设计上考虑周全一点，还是会以第一种形式设计重载。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-重载&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#C-重载&quot;&gt;¶&lt;/a&gt;C++ 重载&lt;/h2&gt;
&lt;p&gt;操作符就是一种函数，是可以让你重新定义的&lt;br /&gt;比如说相加，与其自己写个相加函数 plus(u,v); 将u,v相加，&lt;br /&gt;用</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++学习" scheme="http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>C++ stack与heap</title>
    <link href="http://example.com/2021/03/26/C++stackheap/"/>
    <id>http://example.com/2021/03/26/C++stackheap/</id>
    <published>2021-03-26T09:09:14.141Z</published>
    <updated>2021-03-26T09:13:39.539Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-stack与heap"><a class="header-anchor" href="#C-stack与heap">¶</a>C++ stack与heap</h2><p>stack(栈) heap(堆)<br />Stack,是存在于某作用域(scope)的一块内存空间(memory space).例如当你调用函数，函数本身即会形成一个stack用来放置它所接收的参数，以及返回地址。</p><p>在函数本身(function body)内声明的任何变量，其所使用的内存块都取自于上述stack.</p><p>Heap，或者说system heap,是指由操作系统提供的一块global内存空间，程序可动态分配(dynamic allocated)从中获得若干区块(blocks)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span>...&#125;;</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;<span class="comment">// c1所占用的空间来自stack</span></span><br><span class="line">Complex * p = <span class="keyword">new</span> <span class="built_in">Complex</span>(<span class="number">3</span>); </span><br><span class="line"><span class="comment">//Complex(3)是个临时对象，其所占用的空间是以new自heap动态分配而得，并由p指向</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>stack objects 的生命周期</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span>...&#125;;</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c1便是所谓stack object,其生命在作用域(scope)结束时结束。<br />这种作用域内的object,又称为auto object,因为它会被自动释放。</p><p>static local objects 的生命周期</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span>...&#125;;</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Complex <span class="title">c2</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c2便是所谓static object,其生命在作用域(scope)结束时仍然存在，直到整个程序结束.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span>...&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="function">Complex <span class="title">c3</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>c3就是global object,其生命在整个程序结束之后才结束，也可以把它视为一种static object,其作用域是整个程序.</p><p>heap objects 的生命周期</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span>...&#125;;</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">Complex* p = <span class="keyword">new</span> Complex;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>p所指的是heap object,其生命在它被deleted时结束。</p><div class="cnblogs_code"><pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Complex{...};...<p>{<br>Complex</span>* p = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Complex;<br>}</span></pre></p></div><hr><p>以上出现内存泄露(memory leak)，因为当作用域结束，p所指的heap object仍然存在，但指针<br />p的生命却结束了，作用域之外再也看不到p(也就没机会delete p)了。<br />尽可能避免这种情况。</p><p>new:先分配memory，再调用ctor</p><p>Complex * pc = new Complex(1,2);</p><p>三个步骤。<br />编译器转化为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Complex * pc;</span><br><span class="line"><span class="comment">// operator new是C++中的一个特殊函数，其本质也是调用了malloc分配内存</span></span><br><span class="line"><span class="number">1.</span><span class="keyword">void</span> * mem = <span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Complex));</span><br><span class="line"><span class="number">2.</span>pc = <span class="keyword">static_cast</span>&lt;Complex*&gt;(mem); <span class="comment">//将mem指针转为Complex类型的指针</span></span><br><span class="line"><span class="number">3.</span>pc-&gt;Complex::<span class="built_in">Complex</span>(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">//构造函数 本质 Complex::Complex(pc,1,2); 这里的pc相当于this,是不可见的</span></span><br></pre></td></tr></table></figure><p>delete: 先调用 dtor,再释放memory</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String * ps = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> ps;</span><br></pre></td></tr></table></figure><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String::~<span class="built_in">String</span>(ps); <span class="comment">//析构函数</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(ps)</span></span>; <span class="comment">//释放内存，operator delete()是C++中的一个特殊函数其内部调用free(ps)</span></span><br></pre></td></tr></table></figure><p>array new 一定要搭配 array delete</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String * p = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span>[] p; <span class="comment">//唤起3次dtor</span></span><br><span class="line"></span><br><span class="line">String * p = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> p; <span class="comment">//唤起1次dtor</span></span><br></pre></td></tr></table></figure><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210113170228948-1252176890.png" alt="" loading="lazy" /></p><p>&nbsp;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-stack与heap&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#C-stack与heap&quot;&gt;¶&lt;/a&gt;C++ stack与heap&lt;/h2&gt;
&lt;p&gt;stack(栈) heap(堆)&lt;br /&gt;Stack,是存在于某作用域(scope)的</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++学习" scheme="http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>C++引用小结</title>
    <link href="http://example.com/2021/03/26/C++refer/"/>
    <id>http://example.com/2021/03/26/C++refer/</id>
    <published>2021-03-26T09:05:54.114Z</published>
    <updated>2021-03-26T09:08:38.497Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-引用小结"><a class="header-anchor" href="#C-引用小结">¶</a>C++引用小结</h2><p>从之前的博客中有提到，C++有两种特性</p><p>return by value&nbsp; &nbsp;and&nbsp; &nbsp;return by reference</p><p>一种是返回值，一种是返回引用</p><p>并且，在一般情况下，传引用比传值效率更高。</p><hr><p>先说说引用是什么，引用用的是&amp;符号，&amp;符号既可以用来当引用，也可以用来当取地址符，只不过使用方法不同。</p><p>引用的本质是别名。</p><p>引用的基本使用方法是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> &amp; a = b;</span><br></pre></td></tr></table></figure><p>此时a就是b的引用，也就是b的别名，那可能会发现一个问题，我为什么不直接用b，而去特意创建一个别名去使用b呢。</p><p>这里去思考一下typedef的作用就知道了。</p><hr><p>我们可以用它来接收返回值，并且创建引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> complex&amp;</span><br><span class="line">__doaml (complex* ths, <span class="keyword">const</span> complex&amp; r)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">double</span> f = ths-&gt;re * r.re - ths-&gt;im * r.im;</span><br><span class="line">  ths-&gt;im = ths-&gt;re * r.im + ths-&gt;im * r.re;</span><br><span class="line">  ths-&gt;re = f;</span><br><span class="line">  <span class="keyword">return</span> *ths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传递者是*ths，是一个&ldquo;实体&rdquo;，而接收者是 complex&amp; , 也就是一个引用，其实这里也可以直接接收值，但如果之后还要使用*ths,这里的用引用接收之后使用，效率会快上很多。</p><p>（可以把这整个函数想象成返回了一个 *ths 的引用）</p><hr><p>引用和指针是差不多的，因为</p><p>T&amp; ... = T* const ...&nbsp; 指针无法改变</p><p>const T&amp; ... = const T* const ... 指针无法改变，指针指向的值也无法改变</p><hr><p>所以引用就是一个不能改变指向的指针，传递的也是地址。</p><hr><p>并且引用能够解决 派生类切割问题。</p><p>比如说有两个类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     string name;</span><br><span class="line">     <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span>:</span> <span class="keyword">public</span> person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string classid;<span class="comment">//班级名</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printattribute</span><span class="params">(person p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; p.name;</span><br><span class="line">  cout &lt;&lt; p.classid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">//假设</span></span><br><span class="line">student s;</span><br><span class="line"><span class="built_in">printattribute</span>(s);</span><br></pre></td></tr></table></figure><p>当派生类对象s 传入到 printattribute()里去后，会切割掉自己原本有的属性，变成一个原原本本的基类，此时将没有classid这个属性。</p><p>如果传的是引用，则可以解决这个问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printattribute</span><span class="params">(<span class="keyword">const</span> person&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; p.name;</span><br><span class="line">  cout &lt;&lt; p.classid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样 p 的行为就和传入到函数的真实类型一致了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-引用小结&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#C-引用小结&quot;&gt;¶&lt;/a&gt;C++引用小结&lt;/h2&gt;
&lt;p&gt;从之前的博客中有提到，C++有两种特性&lt;/p&gt;
&lt;p&gt;return by value&amp;nbsp; &amp;nbsp;and&amp;nbsp</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++学习" scheme="http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>C++组合与继承</title>
    <link href="http://example.com/2021/03/26/C++zuhejicheng/"/>
    <id>http://example.com/2021/03/26/C++zuhejicheng/</id>
    <published>2021-03-26T08:55:49.033Z</published>
    <updated>2021-03-26T08:59:18.739Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-组合与继承"><a class="header-anchor" href="#C-组合与继承">¶</a>C++组合与继承</h2><p>组合与继承</p><p>Composition(复合)，表示has-a<br />复合关系简单来说，就是一个类中有另外一个类，A类中需要实现的东西，完全可以由B类中的方法来实现的话，就不需要在A类中去写，而直接去调用B类中的方法就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Sequence</span> =</span> deque&lt;T&gt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">queue</span>&#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">sequence c; <span class="comment">//底层容器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">empty</span>();&#125;</span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">size</span>();&#125;</span><br><span class="line"><span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">front</span>();&#125;</span><br><span class="line"><span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">back</span>();&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span> </span>&#123;c.<span class="built_in">push_back</span>(x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;c.<span class="built_in">pop_front</span>();&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为单向队列类queue中的一些操作完全可以由双端队列类deque中的方法去实现，所以可以在queue类中直接加入底层容器去调用deque中的方法，而不是自己实现，这就是复合。</p><hr><p>内存关系：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">queue</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">deque&lt;T&gt; c;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">deque</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Itr&lt;T&gt; start;</span><br><span class="line">Itr&lt;T&gt; finish;</span><br><span class="line">T** map;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> map_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Itr</span>&#123;</span></span><br><span class="line">T* cur;</span><br><span class="line">T* first;</span><br><span class="line">T* last;</span><br><span class="line">T** node;</span><br><span class="line">....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>算内存，由内而外，首先看结构体Itr，一个指针4字节，所以sizeof(Itr) = 4*4 =16<br />然后在 class deque中，有两个Itr结构体 加一个指针变量一个整形变量，所以sizeof(deque) = 16 * 2 + 4 + 4 = 40;<br />同理，所以sizeof(queue) = 40;</p><p>Composition(复合)关系下的构造和析构</p><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114110805972-646031218.png" alt="" loading="lazy" /></p><hr><p>构造由内而外<br />Container 的构造函数首先调用 Component 的 default 构造函数，然后才执行自己。</p><div class="cnblogs_code"><pre>Container::Container(...): Component() {...}; <span style="color: #008000;">//</span><span style="color: #008000;">因为Component的构造函数可能不止一个，编译器不知道调用哪个，所以只会调用缺省构造函数，除非自己指定参数。</span></pre></div><p>析构由外而内<br />Container 的析构函数首先执行自己，然后才调用Component的析构函数</p><div class="cnblogs_code"><pre>Container::~Container(...){... ~Component()};</pre></div><p>组装都是由内而外的，拆开肯定只能由外而内。</p><p><br />Delegation(委托).Composition by reference;<br />委托其实跟复合很像，说实在点也就是定义上有点区别。<br />不过委托就是Composition(复合) by reference，看这个应该就能明白了。</p><hr><h2 id="code￼2"><a class="header-anchor" href="#code￼2">¶</a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file String.hpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringRep</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">String</span>();</span><br><span class="line"><span class="built_in">String</span>(<span class="keyword">const</span> <span class="keyword">char</span> * s);</span><br><span class="line"><span class="built_in">String</span>(<span class="keyword">const</span> String&amp; s);</span><br><span class="line">String &amp;<span class="keyword">operator</span> = (<span class="keyword">const</span> String&amp; s);</span><br><span class="line">~<span class="built_in">String</span>();</span><br><span class="line">....</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">StringRep * rep; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file String.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;String.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringRep</span>&#123;</span></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span>;</span></span><br><span class="line"><span class="built_in">StringRep</span>(<span class="keyword">const</span> <span class="keyword">char</span> * s);</span><br><span class="line">~<span class="built_in">StringRep</span>();</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">char</span> * rep;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String::<span class="built_in">String</span>()&#123;...&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>通过调用 StringRep指针来获取到字符串"Hello"，通过下图就很明显能够看出。</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;<img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114110929461-942601926.png" alt="" loading="lazy" /></p><hr><p><br />这种模式的优点就是无论你怎么修改StringRep 对客户所需要看到的Hello都不影响，甚至可以更换委托对象。维护和更新起来特别方便。<br />可以说这两者之间就是 Handle 与 Body 的关系。</p><p>Inheritance(继承) ,表示is-a</p><div class="cnblogs_code"><pre><span style="color: #0000ff;">struct</span><span style="color: #000000;"> _List_node_base{_List_node_base</span>*<span style="color: #000000;"> _M_next;_List_node_base</span>*<span style="color: #000000;"> _M_prev;};<p>template</span>&lt;typename _Tp&gt;<br><span style="color: #0000ff;">struct</span><span style="color: #000000;"> _List_node<br>:</span><span style="color: #0000ff;">public</span><span style="color: #000000;"> _List_node_base<br>{<br>_Tp _M_data;<br>};</span></pre></p></div><hr><p>语法上继承有3种方法，最常用的就是 :public ...<br />其实struct和class是非常相似的，所以这里拿struct举例，继承是is-a的关系<br />继承在面向对象中的概念来说，就是父类与子类，比如说人类分男人，女人，人类是父类，男人与女人是子类。<br />拥有父类-人类的属性的同时，多了自己的属性。</p><p>构造由内而外</p><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114110901434-1450263716.png" alt="" loading="lazy" /></p><hr><p><br />Derived 的构造函数首先调用Base的 default 构造函数，然后才执行自己。</p><div class="cnblogs_code"><pre>Deruved::Derived(...) : Base() {...};</pre></div><p>析构由外而内<br />Derived 的析构函数首先执行自己，然后才调用Base的析构函数。</p><div class="cnblogs_code"><pre>Derived::~Derived(...){...~Base()};</pre></div><hr><p>注意：base class 的 dtor必须是virtual,否则会出现 undefined behaviod<br />养成习惯，每当创建的类有可能会作为基类衍生子类时，最好把这个类的析构函数设为虚函数(virtual)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-组合与继承&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#C-组合与继承&quot;&gt;¶&lt;/a&gt;C++组合与继承&lt;/h2&gt;
&lt;p&gt;组合与继承&lt;/p&gt;
&lt;p&gt;Composition(复合)，表示has-a&lt;br /&gt;复合关系简单来说，就是一个类中有另外</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++学习" scheme="http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>C++虚函数与多态</title>
    <link href="http://example.com/2021/03/26/C++vir2/"/>
    <id>http://example.com/2021/03/26/C++vir2/</id>
    <published>2021-03-26T08:52:43.991Z</published>
    <updated>2021-03-26T08:55:21.783Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-虚函数与多态"><a class="header-anchor" href="#C-虚函数与多态">¶</a>C++虚函数与多态</h2><p>C++ 虚函数与多态</p><p>Inheritance(继承)with virtual functions(虚函数)</p><p>non-virtual函数：你不希望derived class 重新定义(override,覆写)它<br />它已有默认定义。</p><p>pure virtual函数：你希望derived class 一定要重新定义(override,覆写)它，<br />你对他没有默认定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>; <span class="comment">// pure virtual</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(<span class="keyword">const</span> std::string&amp; msg)</span></span>; <span class="comment">// impure virtual</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">objectID</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// non-virtual</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span><span class="keyword">public</span> Shape&#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ellipse</span>:</span><span class="keyword">public</span> Shape&#123;...&#125;;</span><br></pre></td></tr></table></figure><p>形状为基类，子类为矩形，椭圆形，error()是打印错误信息的函数，那么设为虚函数的意义是，也许在子类中，我们不同的形状需要打印不同的错误信息，更为精确的错误信息的话，那么我们就可以在子类中去覆写error()函数，这样，在调用error()函数的时候调用的就是对应子类中的error()函数，那么draw()与error()有什么区别呢，可以看到 error()中是有默认操作的， const std::string&amp; msg , 而draw()中是没有任何操作的(一般在函数原型后面加"=0"就意味着纯虚函数)，这就是纯虚函数，如果父类中的一个函数为纯虚函数的话，那么这个函数是必须在子类中去覆写的。</p><p>Inheritance(继承) with virtual<br />Template Method 模板方法</p><div class="cnblogs_code"><pre><span style="color: #000000;">CDocument::OnFileOpen(){...Serialize()...};</span></pre></div><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyDoc</span>:</span></span><br><span class="line"><span class="keyword">public</span> CDocument</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="title">Serialize</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><div class="cnblogs_code"><pre><span style="color: #000000;">main(){CMyDoc myDoc;...myDoc.OnFileOpen();}</span></pre></div><hr><p>模板方法具体就是定义一个模板结构，将具体内容延迟到子类去实现。（基于"继承"）<br />在main中，我们通过子类对象myDoc调用父类中的函数OnFileOpen(),打开一个文件，<br />进入到OnFileOpen()中，首先执行了打开所有文件都需要进行的操作，然后具体打开操作需要在<br />Serialize()中实现，但每个应用如何打开只有对应的应用才知道，所以在子类中覆写 Serialize()方法，这样在OnFileOpen()中的Serialize()调用的其实是子类中的Serialize()方法，<br />灵活性也大大提高了。</p><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114192843446-885101246.png" alt="" loading="lazy" /></p><hr><p>模拟过程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDocument</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnFileOpen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//每个cout 输出代表一个实际动作</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;dialog...&quot;</span> &lt;&lt;endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;check file status...&quot;</span> &lt;&lt;endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;open file...&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="built_in">Serialize</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;close file...&quot;</span> &lt;&lt;endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;update all views...&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Serialize</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyDoc</span>:</span> <span class="keyword">public</span> CDocument</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Serialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//只有应用程序知道如何读取自己的文件格式</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;CMyDoc::Serialize()&quot;</span> &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CMyDoc myDoc; <span class="comment">//假设对应[File/Open]</span></span><br><span class="line">myDoc.<span class="built_in">OnFileOpen</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-虚函数与多态&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#C-虚函数与多态&quot;&gt;¶&lt;/a&gt;C++虚函数与多态&lt;/h2&gt;
&lt;p&gt;C++ 虚函数与多态&lt;/p&gt;
&lt;p&gt;Inheritance(继承)with virtual functions(虚</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++学习" scheme="http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>C++复合与继承下的ctor和dtor顺序</title>
    <link href="http://example.com/2021/03/26/C++ctordtor/"/>
    <id>http://example.com/2021/03/26/C++ctordtor/</id>
    <published>2021-03-26T08:50:28.927Z</published>
    <updated>2021-03-26T08:51:57.932Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-复合与继承下的ctor和dtor顺序"><a class="header-anchor" href="#C-复合与继承下的ctor和dtor顺序">¶</a>C++复合与继承下的ctor和dtor顺序</h2><p>了解到复合关系与继承关系，我们知道了复合关系下：先构造内部，再构造外部</p><p>　　　　　　　　　　　　　　　　　　继承关系下：先构造父类，再构造子类</p><hr><p>那么在既有复合关系，又有继承关系的情况下，构造与析构的顺序分别是怎样呢，基于这个问题，写一段简单的代码观察。</p><h2 id="code￼0"><a class="header-anchor" href="#code￼0">¶</a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;B&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;B&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    B b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>() &#123; cout &lt;&lt; <span class="string">&quot;C&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">C</span>() &#123; cout &lt;&lt; <span class="string">&quot;C&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    C * c = <span class="keyword">new</span> <span class="built_in">C</span>();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> c;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><p>运行结果如下：</p><div class="cnblogs_code"><pre><span style="color: #000000;">ABCCBA</span></pre></div><hr><p>可知，在复合关系与继承关系同时存在时，先构造父类，再去构造派生类以及它的内部类，而析构顺序则与构造顺序刚好相反。</p><p>补充一下类对象的创建与释放过程：</p><p>详细说明：<a href="https://blog.csdn.net/m0_37622246/article/details/99681188">https://blog.csdn.net/m0_37622246/article/details/99681188</a></p><p>类的创建过程</p><p>1、从堆栈中分配类所需要的空间。<br />2、根据需求传递或不传递参数调用构造函数，完成如下任务：</p><p><strong>①根据继承表依次调用父类的构造函数。</strong></p><p><strong>②根据成员变量的顺序依次调用成员变量的构造函数。</strong></p><p><strong>③执行构造函数体中的代码。</strong></p><p> 注意：执行构造函数的代码是整个构造函数的最后一步，要保证构造函数代码所需要的一切资源和先决条件在该代码执行前已经准备充分，并得到正确的初始化。</p><hr><p>类的释放过程</p><p>析构函数负责释放在构造函数期间获取的所有资源，它的执行过程：</p><p><strong>①先执行析构函数本身代码 </strong></p><p><strong>②调用成员类的析构函数 </strong></p><p><strong>③调用父类的析构函数</strong></p><p>如果一个类没实现析构函数，编译器会自动生成一个具有析构功能的二进制指令，它负责释放编译器能够看得到的资源（成员变量、类成员、父类成员），这就是缺省析构。</p><p>如果类中没有动态资源，也不需要做善后工作，缺省析构就完全够用了，不需要再定义新析构函数。<br />注意：缺省析构无法释放动态资源（堆内存）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-复合与继承下的ctor和dtor顺序&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#C-复合与继承下的ctor和dtor顺序&quot;&gt;¶&lt;/a&gt;C++复合与继承下的ctor和dtor顺序&lt;/h2&gt;
&lt;p&gt;了解到复合关系与继承关系，我们知道了复合关</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++学习" scheme="http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Composite模式与Prototype模式</title>
    <link href="http://example.com/2021/03/26/C++design/"/>
    <id>http://example.com/2021/03/26/C++design/</id>
    <published>2021-03-26T08:44:28.650Z</published>
    <updated>2021-03-26T08:48:42.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Composite模式与Prototype模式"><a class="header-anchor" href="#Composite模式与Prototype模式">¶</a>Composite模式与Prototype模式</h2><p>这两种模式都是基于 Delegation(委托) + Inheritance(继承)&nbsp; 而来的，</p><p>首先讲一下Composite模式，也就是组合模式，是一个经典的设计模式。</p><hr><p><strong>组合模式是什么？</strong></p><p><strong>组合模式是指将对象组合成树形结构以表示"部分-整体"的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。</strong></p><hr><p>假如我们面临一个场景，需要做一个文件类，那么我们知道，打开一个文件，文件既可以是文件夹，也可以是单体文件，为了便于识别，个体文件我们叫做Primitive,文件夹我们叫做Composite，由于文件夹里可以存放Primitive，也可以再存放Composite，形成一个递归结构，如果消耗时间去进行if-else判断显得愚钝并且效率极低，而且用户不管你如何设计，文件夹和文件如果都能当做一种东西来操作的话，是最好不过的，组合模式的目的就是让用户不再区分操作的是组合对象还是个体对象，而是以一个统一的方式来操作，实现这个目标的关键点就是设计一个抽象的基类，让它既可以代表组合对象也可以代表个体对象，这样一来，用户就不需要区分这两种对象了，只需要全部通过Compostie对象进行统一操作就行了。</p><p>（其实文件系统就是组合模型的典型应用）</p><p>&nbsp;</p><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210115204048564-983255842.png" alt="" loading="lazy" /></p><p>伪代码实现模拟：</p><h2 id="code￼0"><a class="header-anchor" href="#code￼0">¶</a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Primitive</span>:</span><span class="keyword">public</span> Component</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Primitive</span>(<span class="keyword">int</span> val):<span class="built_in">Component</span>(val)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></h2><h2 id="code￼1"><a class="header-anchor" href="#code￼1">¶</a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Component</span>(<span class="keyword">int</span> val)&#123;value = val;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component*)</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Composite</span>:</span> <span class="keyword">public</span> Component</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;Component*&gt; c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Composite</span>(<span class="keyword">int</span> val):<span class="built_in">Component</span>(val)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Component* elem)</span></span>&#123;</span><br><span class="line">        c.<span class="built_in">push_back</span>(elem);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样Composite类 通过父类指针既能接收primitive类也能接收自己。</p><p>通过下面代码就可以更加清晰看出来：</p><h2 id="code￼3"><a class="header-anchor" href="#code￼3">¶</a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Component</span>() &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component*)</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(string path)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Composite</span> :</span> <span class="keyword">public</span> Component&#123;</span><br><span class="line">    string name;</span><br><span class="line">    vector&lt;Component*&gt; c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Composite</span>(string str) :<span class="built_in">Component</span>() &#123; name = str; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Component* comp)</span> </span>&#123;</span><br><span class="line">        c.<span class="built_in">push_back</span>(comp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(string path)</span> </span>&#123;</span><br><span class="line">        vector&lt;Component*&gt;::iterator it = c.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">for</span> (; it != c.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">            Component * comp = *it;</span><br><span class="line">            string ss = path + <span class="string">&quot;\\&quot;</span> + name;</span><br><span class="line">            comp-&gt;<span class="built_in">print</span>(ss);</span><br><span class="line">            <span class="keyword">delete</span> comp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Primitive</span> :</span> <span class="keyword">public</span> Component &#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Primitive</span>(string str) :<span class="built_in">Component</span>() &#123; name = str; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(string path)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; path &lt;&lt; <span class="string">&quot;\\&quot;</span> &lt;&lt; name &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;创建目录中...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Composite * rootdir = <span class="keyword">new</span> <span class="built_in">Composite</span>(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">    Composite * dis_o = <span class="keyword">new</span> <span class="built_in">Composite</span>(<span class="string">&quot;cdcd&quot;</span>);</span><br><span class="line">    Composite * dis_s = <span class="keyword">new</span> <span class="built_in">Composite</span>(<span class="string">&quot;asda&quot;</span>);</span><br><span class="line">    rootdir-&gt;<span class="built_in">add</span>(dis_o);</span><br><span class="line">    rootdir-&gt;<span class="built_in">add</span>(dis_s);</span><br><span class="line">    dis_o-&gt;<span class="built_in">add</span>(<span class="keyword">new</span> <span class="built_in">Primitive</span>(<span class="string">&quot;file1&quot;</span>));</span><br><span class="line">    dis_s-&gt;<span class="built_in">add</span>(<span class="keyword">new</span> <span class="built_in">Primitive</span>(<span class="string">&quot;file2&quot;</span>));</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输出目录&quot;</span> &lt;&lt; endl;</span><br><span class="line">    rootdir-&gt;<span class="built_in">print</span>(<span class="string">&quot;cmd:&quot;</span>);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><p>输出结果：</p><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210116112054819-1692135074.png" alt="" loading="lazy" /></p><hr><p>看得出来我们只需要对Composite类进行操作，就又可以存放自己，又可以存放Primitive类，这就是组合模式的便利之处了。</p><hr><p>接下来说Prototype模式，也就是原型模式，这个模式强大之处在于它能够在你不知道你以后要设计什么类的情况下，获取一个这个类的副本，实现一系列操作。</p><p>假如我们设计了一个框架，我们不知道以后使用人员会写入什么派生类，也总不可能去用string获取类名创建，这样是不符合C++编译标准的，那么此时就要用Prototype模式了，利用使用人员写的子类自己创建自己，然后传到自己的框架基类，获取一个副本，以实现对子类对象的操作。</p><hr><p>如下图：</p><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210116113439075-742580494.png" alt="" loading="lazy" /></p><p>&nbsp;</p><p><span style="background-color: #ffff00;">&nbsp;下划线代表静态变量，-是私有类型，#是保护类型</span></p><p>假如上面的Image类是我们自己写的，但是我们写的时候并没有LandSatImage类与SpotImage类，这些类有可能是在交付到客户手上，客户自己写的，那么我们如何去用我们自己的类来实现构造当时并不存在的类呢。</p><hr><p>可以看到 LandSatImage类，创建了一个静态的自己，那么此时，一定会调用本身的构造函数 LandSatImage(),可以看到构造函数中有addPrototype(this); 这个是父类中的一个静态函数，作为子类是可以直接调用的，这么做是为了把自己传到父类去，传完之后那么现在就全部完成了吗？还没有，此时相当于（粗略理解） 我把自己的类的指针给了父类，然后父类拿到现在这个类的指针后，保存到prototypes[]中，还要利用这个指针创建一个实例化对象，才算真正的使用，clone()的作用就是返回一个实例化对象，上图描写的很清楚，return new LandSatImage, 那么上面的 prototypes[i]-&gt;clone() 其实就相当于 LandSatImage a = new LandSatImage();所以我们获得了一个实例化对象，就可以对他进行操作了，还要注意一个很重要的点，可以看到LandSatImage中有两个构造函数，那么作用是什么呢，因为prototypes[i]-&gt;clone()调用了LandSatImage中的clone()函数，然后return new LandSatImage;此时因为创建了一个LandSatImage对象，所以还会调用构造函数，那么如果只有第一个构造函数的话，就会套娃，无限addPrototype(this); 所以用第二个构造函数，加一个数字，这样就会避免调用第一个构造函数，所以其实是在clone()函数中应该写return new LandSatImage(1);（任何数字都行）这样就不会再次调用第一个构造函数了。</p><hr><p>实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ImageType</span> &#123;</span></span><br><span class="line">    LSAT,SPOT</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Image</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Image *<span class="title">findAndClone</span><span class="params">(ImageType)</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//规定子类必须实现clone()函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Image * <span class="title">clone</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//获得子类的文件格式</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ImageType <span class="title">returnType</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addPrototype</span><span class="params">(Image * image)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _prototypes[_nextSlot++] = image;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Image * _prototypes[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> _nextSlot;</span><br><span class="line">&#125;;</span><br><span class="line">Image * Image::_prototypes[];</span><br><span class="line"><span class="keyword">int</span> Image::_nextSlot;</span><br><span class="line"><span class="function">Image * <span class="title">Image::findAndClone</span><span class="params">(ImageType type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _nextSlot; i++)</span><br><span class="line">        <span class="comment">//保证副本格式正确</span></span><br><span class="line">        <span class="keyword">if</span> (_prototypes[i]-&gt;<span class="built_in">returnType</span>() == type)</span><br><span class="line">            <span class="keyword">return</span> _prototypes[i]-&gt;<span class="built_in">clone</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LandSatImage</span> :</span><span class="keyword">public</span> Image</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//返回当前文件格式</span></span><br><span class="line">    <span class="function">ImageType <span class="title">returnType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LSAT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;LandSatImage::draw&quot;</span> &lt;&lt; _id &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建对象</span></span><br><span class="line">    <span class="function">Image * <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">LandSatImage</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">LandSatImage</span>(<span class="keyword">int</span> dummy) &#123;</span><br><span class="line">        _id = _count++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> LandSatImage _landSatImage;</span><br><span class="line">    <span class="built_in">LandSatImage</span>() &#123;</span><br><span class="line">        <span class="built_in">addPrototype</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> _id;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> _count;</span><br><span class="line">&#125;;</span><br><span class="line">LandSatImage LandSatImage::_landSatImage;</span><br><span class="line"><span class="keyword">int</span> LandSatImage::_count = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>以上就是个人对两种模式一点理解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Composite模式与Prototype模式&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#Composite模式与Prototype模式&quot;&gt;¶&lt;/a&gt;Composite模式与Prototype模式&lt;/h2&gt;
&lt;p&gt;这两种模式都是基于 Del</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++学习" scheme="http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
