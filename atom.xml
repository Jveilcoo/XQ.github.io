<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-03-26T11:19:39.576Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>graphics pipeline - 图形管线</title>
    <link href="http://example.com/2021/03/26/graphics1/"/>
    <id>http://example.com/2021/03/26/graphics1/</id>
    <published>2021-03-26T11:18:01.301Z</published>
    <updated>2021-03-26T11:19:39.576Z</updated>
    
    <content type="html"><![CDATA[<h2 id="graphics-pipeline-图形管线"><a class="header-anchor" href="#graphics-pipeline-图形管线">¶</a>graphics pipeline - 图形管线</h2><p>标准图形系统的实施流程通常称为图形管线。&rdquo;管线&ldquo;一词在这里指从数学模型到生成屏幕上像素的过程，它包含多个步骤。在经典的体系结构中，这些步骤是按序执行的，即一个阶段的结果输出给下一个阶段，前面阶段随即开始处理新的多边形。</p><hr><p>管线简化示意图：</p><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210117225547738-1443334944.png" alt="" loading="lazy" /></p><hr><p>在许多情况下，管线的实现细节并非关注点，这时可以把它看成一个黑盒，通过黑盒，场景几何模型被转换为场景多边形的光栅透视投影（这里暂时忽略平行投影情况）图像。</p><hr><p>纹理映射与近似</p><p>　　图形管线中的一个标准模块是纹理映射(texture map)，纹理映射通过查表的方式将纹理图像的颜色映射到一个或多个多边形上。这个过程就像在表面上刻写图案或是将一张花纹纸粘贴到物体上，扫描到系统中的图像，相机拍摄的照片，或者绘图软件制作的图像都是纹理图像，<span style="background-color: #ffff00;">你可以把纹理图案想象成一张有图案的橡胶片，而纹理坐标描述了为了使这张橡胶片能够准确覆盖物体的某些部位，以及橡胶片是如何进行拉伸和变形的</span>。</p><hr><p>个人理解：</p><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210117230232056-878760406.png" alt="" loading="lazy" /></p><hr><p>如上图，就是通过纹理坐标将纹理图案进行一系列拉伸和变形准确覆盖到物体上的对应位置。</p><hr><p>通过纹理映射来指定图像上每个点的颜色仅仅是纹理映射的众多应用之一。例如，一个物体的外观部分取决于表面的法向量，计算光从表面的反射时就涉及法向量，由于表面通常采用多边形网格表示，所以通常在各多边形的顶点处计算表面的法向量，多边形内部各点的法向量则通过插值获得，从而使该物体表面呈现平滑的外观效果。</p><hr><p>上述提到，管线结构能够让我们并行处理很多任务，管线上的每一阶段针对一部分数据执行某个任务，然后将处理结果传送给下一阶段，接着这一阶段立即开始处理下一部分数据，如果管线设计合理，则大大提高处理能力。当然，随着管线所含阶段数的增多，从输入数据到生成最终结果所需的时间总量也将增加。对于交互性要求很高的系统来说，这种滞后或者潜在滞后可能会造成严重影响。</p><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210117231156283-1550082328.png" alt="" loading="lazy" /></p><hr><p>图形管线包括4个主要部分：顶点几何处理和变换，三角形处理（光栅化）和片段（fragment)生成、纹理映射和光照以及用来组装最终图像的片段组合操作。</p><p>在这个更大的管线里，应用程序提供显示所需的数据，而图形管线则生成最终的图像，但在此期间用户可能会输入信息对应用程序进行控制（例如对所显示的图像有所影响），还有从图形管线中返回的信息，他们组合起来，用于计算下一帧画面。</p><hr><p>持续补充。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;graphics-pipeline-图形管线&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#graphics-pipeline-图形管线&quot;&gt;¶&lt;/a&gt;graphics pipeline - 图形管线&lt;/h2&gt;
&lt;p&gt;标准图形系统的实施流程通常称</summary>
      
    
    
    
    <category term="图形学" scheme="http://example.com/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="概念知识" scheme="http://example.com/tags/%E6%A6%82%E5%BF%B5%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Eigen:Matrix and Vector arithmetic</title>
    <link href="http://example.com/2021/03/26/Eigen2/"/>
    <id>http://example.com/2021/03/26/Eigen2/</id>
    <published>2021-03-26T11:12:15.866Z</published>
    <updated>2021-03-26T11:16:57.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Eigen-Matrix-and-Vector-arithmetic"><a class="header-anchor" href="#Eigen-Matrix-and-Vector-arithmetic">¶</a>Eigen:Matrix and Vector arithmetic</h2><p>Eigen库 有重载关于Matrix与Vector的计算符，这样我们可以很方便的得到矩阵运算后的结果。</p><p>一些基本运算符：+,-,*,/,+=,-=,*=,/=</p><hr><p>普通的矩阵加减法运算：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Matrix2d a;</span><br><span class="line">a &lt;&lt; <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line"><span class="number">3</span>, <span class="number">4</span>;</span><br><span class="line"><span class="function">MatrixXd <span class="title">b</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">b &lt;&lt; <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line"><span class="number">1</span>, <span class="number">4</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;a + b =\n&quot;</span> &lt;&lt; a + b &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;a - b =\n&quot;</span> &lt;&lt; a - b &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Doing a += b;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">a += b;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Now a =\n&quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line"><span class="function">Vector3d <span class="title">v</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">Vector3d <span class="title">w</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;-v + w - v =\n&quot;</span> &lt;&lt; -v + w - v &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>Output:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a + b =</span><br><span class="line"><span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="number">8</span></span><br><span class="line">a - b =</span><br><span class="line"><span class="number">-1</span> <span class="number">-1</span></span><br><span class="line"> <span class="number">2</span>  <span class="number">0</span></span><br><span class="line">Doing a += b;</span><br><span class="line">Now a =</span><br><span class="line"><span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="number">8</span></span><br><span class="line">-v + w - v =</span><br><span class="line"><span class="number">-1</span></span><br><span class="line"><span class="number">-4</span></span><br><span class="line"><span class="number">-6</span></span><br></pre></td></tr></table></figure><hr><p>乘法运算：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Matrix2d a;</span><br><span class="line">a &lt;&lt; <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line"><span class="number">3</span>, <span class="number">4</span>;</span><br><span class="line"><span class="function">Vector3d <span class="title">v</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;a * 2.5 =\n&quot;</span> &lt;&lt; a * <span class="number">2.5</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;0.1 * v =\n&quot;</span> &lt;&lt; <span class="number">0.1</span> * v &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Doing v = 2;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">v = <span class="number">2</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Now v =\n&quot;</span> &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>Output:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a * <span class="number">2.5</span> =</span><br><span class="line"><span class="number">2.5</span>   <span class="number">5</span></span><br><span class="line"><span class="number">7.5</span>  <span class="number">10</span></span><br><span class="line"><span class="number">0.1</span> * v =</span><br><span class="line"><span class="number">0.1</span></span><br><span class="line"><span class="number">0.2</span></span><br><span class="line"><span class="number">0.3</span></span><br><span class="line">Doing v *= <span class="number">2</span>;</span><br><span class="line">Now v =</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><hr><p>除此之外，Eigen库关于运算还有个很人性化的地方<br />比如，VectorXf a(50),b(50),c(50),d(50);<br />...<br />a = 3 * b + 4 * c + 5 * d;<br />会自动编译为：<br />for(int i = 0 ; i &lt; 50 ; i++){<br />a[i] = 3*b[i] + 4*c[i] + 5*d[i];<br />}</p><hr><p>注意：如果你看了上面一段关于表达式模板的内容，担心做m=m*m会引起别名问题，暂时放心。Eigen将矩阵乘法作为一种特殊情况处理，并注意在这里引入一个临时的，所以它将把m=m*m编译为：</p><div class="cnblogs_code"><pre>temp = m*<span style="color: #000000;">m;m </span>= temp;</pre></div><hr><p>然后是一些特殊的计算函数，十分便利：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span>() <span class="comment">//矩阵内元素和</span></span><br><span class="line"><span class="built_in">prod</span>() <span class="comment">//元素积</span></span><br><span class="line"><span class="built_in">mean</span>() <span class="comment">//元素平均</span></span><br><span class="line"><span class="built_in">minCoeff</span>() <span class="comment">//最小元素</span></span><br><span class="line"><span class="built_in">maxCoeff</span>() <span class="comment">//最大元素</span></span><br><span class="line"><span class="built_in">trace</span>() <span class="comment">//对角线和</span></span><br><span class="line"><span class="built_in">transpose</span>() <span class="comment">//转置</span></span><br><span class="line"><span class="built_in">conjugate</span>() <span class="comment">//共轭</span></span><br><span class="line"><span class="built_in">adjoint</span>() <span class="comment">//共轭转置</span></span><br></pre></td></tr></table></figure><hr><p>普通计算函数示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Eigen::Matrix2d mat;</span><br><span class="line">mat &lt;&lt; <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line"><span class="number">3</span>, <span class="number">4</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Here is mat.sum():       &quot;</span> &lt;&lt; mat.<span class="built_in">sum</span>()       &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Here is mat.prod():      &quot;</span> &lt;&lt; mat.<span class="built_in">prod</span>()      &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Here is mat.mean():      &quot;</span> &lt;&lt; mat.<span class="built_in">mean</span>()      &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Here is mat.minCoeff():  &quot;</span> &lt;&lt; mat.<span class="built_in">minCoeff</span>()  &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Here is mat.maxCoeff():  &quot;</span> &lt;&lt; mat.<span class="built_in">maxCoeff</span>()  &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Here is mat.trace():     &quot;</span> &lt;&lt; mat.<span class="built_in">trace</span>()     &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Here is mat.<span class="built_in">sum</span>():       <span class="number">10</span></span><br><span class="line">Here is mat.<span class="built_in">prod</span>():      <span class="number">24</span></span><br><span class="line">Here is mat.<span class="built_in">mean</span>():      <span class="number">2.5</span></span><br><span class="line">Here is mat.<span class="built_in">minCoeff</span>():  <span class="number">1</span></span><br><span class="line">Here is mat.<span class="built_in">maxCoeff</span>():  <span class="number">4</span></span><br><span class="line">Here is mat.<span class="built_in">trace</span>():     <span class="number">5</span></span><br></pre></td></tr></table></figure><hr><p>并且minCoeff()与maxCoeff()能够得到相应元素的下标，可使用如下方法实现：</p><p>int i,j;</p><p>minCoeff(&amp;i,&amp;j);</p><p>maxCoeff(&amp;i,&amp;j);</p><p>得到的i,j就是相应元素的横纵坐标。</p><hr><p>转置，共轭，共轭转置示例代码：</p><div class="cnblogs_code"><pre>MatrixXcf a = MatrixXcf::Random(<span style="color: #800080;">2</span>,<span style="color: #800080;">2</span>); <span style="color: #008000;">//</span><span style="color: #008000;">随机2x2矩阵</span>cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">Here is the matrix a\n</span><span style="color: #800000;">"</span> &lt;&lt; a &lt;&lt;<span style="color: #000000;"> endl;<p>cout </span>&lt;&lt; <span style="color: #800000;">“</span><span style="color: #800000;">Here is the matrix a^T\n</span><span style="color: #800000;">”</span> &lt;&lt; a.transpose() &lt;&lt;<span style="color: #000000;"> endl;</p><p>cout </span>&lt;&lt; <span style="color: #800000;">“</span><span style="color: #800000;">Here is the conjugate of a\n</span><span style="color: #800000;">”</span> &lt;&lt; a.conjugate() &lt;&lt;<span style="color: #000000;"> endl;</p><p>cout </span>&lt;&lt; <span style="color: #800000;">“</span><span style="color: #800000;">Here is the matrix a^*\n</span><span style="color: #800000;">”</span> &lt;&lt; a.adjoint() &lt;&lt; endl;</pre></p></div><hr><p>Output:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Here is the matrix a</span><br><span class="line">    (<span class="number">-1</span>,<span class="number">-0.737</span>) (<span class="number">0.0655</span>,<span class="number">-0.562</span>)</span><br><span class="line">(<span class="number">0.511</span>,<span class="number">-0.0827</span>)  (<span class="number">-0.906</span>,<span class="number">0.358</span>)</span><br><span class="line">Here is the matrix a^T</span><br><span class="line">    (<span class="number">-1</span>,<span class="number">-0.737</span>) (<span class="number">0.511</span>,<span class="number">-0.0827</span>)</span><br><span class="line">(<span class="number">0.0655</span>,<span class="number">-0.562</span>)  (<span class="number">-0.906</span>,<span class="number">0.358</span>)</span><br><span class="line">Here is the conjugate of a</span><br><span class="line">     (<span class="number">-1</span>,<span class="number">0.737</span>)  (<span class="number">0.0655</span>,<span class="number">0.562</span>)</span><br><span class="line"> (<span class="number">0.511</span>,<span class="number">0.0827</span>) (<span class="number">-0.906</span>,<span class="number">-0.358</span>)</span><br><span class="line">Here is the matrix a^*</span><br><span class="line">     (<span class="number">-1</span>,<span class="number">0.737</span>)  (<span class="number">0.511</span>,<span class="number">0.0827</span>)</span><br><span class="line"> (<span class="number">0.0655</span>,<span class="number">0.562</span>) (<span class="number">-0.906</span>,<span class="number">-0.358</span>)</span><br></pre></td></tr></table></figure><p>注意：<span style="background-color: #00ffff;">至于基本的算术运算符，transpose()和 adjoint()只是返回一个代理对象，而不进行实际的转置。如果你做b = a.transpose()，那么在将结果写入b的同时就会对transpose进行评估。如果执行a = a.transpose()，那么在转置的评估完成之前，Eigen就开始将结果写入a中。因此，指令a = a.transpose()并不像人们所期望的那样，用它的转置替换a。</span></p><hr><p>还有两个函数差点忘记说了，分别是dot()与cross()，一个是计算点积，一个是计算叉积，非常实用的两个函数！</p><hr><p>补充两个编译时容易出现的错误：（官方文档详细说明）</p><p><a class="el" title="Namespace containing all symbols from the Eigen library." href="http://eigen.tuxfamily.org/dox/namespaceEigen.html">Eigen</a>&nbsp;checks the validity of the operations that you perform. When possible, it checks them at compile time, producing compilation errors. These error messages can be long and ugly, but&nbsp;<a class="el" title="Namespace containing all symbols from the Eigen library." href="http://eigen.tuxfamily.org/dox/namespaceEigen.html">Eigen</a>&nbsp;writes the important message in UPPERCASE_LETTERS_SO_IT_STANDS_OUT. For example:（Eigen会检查你所执行的操作的有效性，在可能的情况下，它会在编译时检查它们，产生编译错误。在可能的情况下，它在编译时检查它们，产生编译错误。这些错误信息可能又长又丑，但Eigen会把重要的信息用UPPERCASE_LETTERS_SO_IT_STANDS_OUT写出来，如下：）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Matrix3f m;</span><br><span class="line">Vector4f v;</span><br><span class="line">v = m*v; <span class="comment">// Compile-time error: YOU_MIXED_MATRICES_OF_DIFFERENT_SIZES</span></span><br></pre></td></tr></table></figure><div class="line"><span class="comment">Of course, in many cases, for example when checking dynamic sizes, the check cannot be performed at compile time.&nbsp;<a class="el" title="Namespace containing all symbols from the Eigen library." href="http://eigen.tuxfamily.org/dox/namespaceEigen.html">Eigen</a>then uses runtime assertions. This means that the program will abort with an error message when executing an illegal operation if it is run in "debug mode", and it will probably crash if assertions are turned off（当然，在很多情况下，比如检查动态大小时，不能在编译时进行检查。Eigen就会使用运行时断点。这意味着，如果在 "debug模式 "下运行，程序在执行非法操作时，会以错误信息中止，如果断点被关闭，程序很可能会崩溃）.</span></div><div class="line">&nbsp;</div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MatrixXf <span class="title">m</span><span class="params">(<span class="number">3</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">VectorXf <span class="title">v</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">v = m * v; <span class="comment">// Run-time assertion failure here: &quot;invalid matrix product&quot;</span></span><br></pre></td></tr></table></figure><p><span class="comment">解释：第一个就是两种不同类型的矩阵相乘会出现SIZE报错，这是理所当然的，第二个就是检查动态大小时，不能在编译时进行检查！</span></p></div><hr><p>有些内容暂时用不到，以后补充。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Eigen-Matrix-and-Vector-arithmetic&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#Eigen-Matrix-and-Vector-arithmetic&quot;&gt;¶&lt;/a&gt;Eigen:Matrix and Vector</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="Eigen" scheme="http://example.com/tags/Eigen/"/>
    
  </entry>
  
  <entry>
    <title>Eigen:The Matrix Class</title>
    <link href="http://example.com/2021/03/26/Eigen1/"/>
    <id>http://example.com/2021/03/26/Eigen1/</id>
    <published>2021-03-26T11:05:43.527Z</published>
    <updated>2021-03-26T11:11:24.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="The-Matrix-Class"><a class="header-anchor" href="#The-Matrix-Class">¶</a>The Matrix Class</h2><p>Eigen库 矩阵类的使用：</p><p>（本文根据官方文档加上自己的一些理解修改制成）</p><hr><p>首先关于Matrix的定义：&nbsp; Matrix&lt;typename scalar, int RowsAtCompileTime, int ColsAtCompileTime&gt; 这是常用的模板，一般为三个参数，也就是Matrix&lt;矩阵变量类型，行数，列数&gt;.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">　　　　　　　　　　　 Matrix&lt;<span class="keyword">typename</span> Scalar, <span class="comment">//标量类型</span></span><br><span class="line"></span><br><span class="line">　　　　　　　　　　　　　    <span class="keyword">int</span> RowsAtCompileTime, <span class="comment">//行数</span></span><br><span class="line"></span><br><span class="line">　　　　　　　　　　　　　　  <span class="keyword">int</span> ColsAtCompileTime,<span class="comment">//列数</span></span><br><span class="line"></span><br><span class="line"> 　　　　　　　　　　　　　　 <span class="keyword">int</span> Options = <span class="number">0</span>,<span class="comment">//位域</span></span><br><span class="line"></span><br><span class="line">　　　　　　　　　　　　      <span class="keyword">int</span> MaxRowsAtCompileTime = RowsAtCompileTime,<span class="comment">//最大行数</span></span><br><span class="line"></span><br><span class="line">　　　　　　　　　　　　　　  <span class="keyword">int</span> MaxColsAtCompileTime = ColsAtCompileTime&gt; <span class="comment">//最大列数</span></span><br></pre></td></tr></table></figure><p><em>使用Eigen库定义一个矩阵: Matrix&lt;int,2,2&gt; 这是一个int类型的2x2矩阵</em></p><p><em>　　　　　　　　　　　　Matrix&lt;float,3,3&gt;这是一个float类型的3x3矩阵</em></p><hr><p><em>Eigen库中简化了部分以上定义的过程，一般用于固定尺寸的矩阵的定义。</em></p><p><em>例如：&nbsp; Matrix2f,Matrix3f,Matrix4f&nbsp; float类型的2x2,3x3,4x4的矩阵(可见结尾部分为f）</em></p><p><em>&nbsp; &nbsp; &nbsp;同理Matrix2d,Matrix3d,Matrix4d,Matrix2i,Matrix3i,Matrix4i,只需要看最后结尾的字母，即可明白变量类型(double,int)</em></p><p>Eigen还有个常用的概念，向量，向量是矩阵中的特殊情况，表现为有一行或一列，也就是行向量和列向量，最常见的情况是只有一列，表现方式有：</p><p>　　　　　　　　　　　&nbsp; typedef Matrix&lt;float, 3, 1&gt; Vector3f;&nbsp; //列向量</p><p>　　　　　　　　　　　&nbsp; typedef Matrix&lt;int, 1, 2&gt; RowVector2i; //行向量</p><hr><p>接下来说明它们各自的赋值方式以及特殊情况：</p><p>静态矩阵下有如下的初始化方式:&nbsp; Vector2i myvector(1,2);&nbsp; 表示初始化一个列向量为<img src="https://img2020.cnblogs.com/blog/1582514/202012/1582514-20201230135221369-1383356973.png" alt="" loading="lazy" />&nbsp;或者 Vector2f myvector(1.0,2.0); 表示初始化一个列向量为<img src="https://img2020.cnblogs.com/blog/1582514/202012/1582514-20201230135913953-1373528500.png" alt="" loading="lazy" /></p><hr><p>向量能这样初始化，但Matrix就不行了，比如Matrix3f a(3,3)虽然编译能够通过，不会报错，但是这样的传递参数是无效的， 在官方文档有解释：In order to offer a uniform API across fixed-size and dynamic-size matrices, it is legal to use these constructors on fixed-size matrices, even if passing the sizes is useless in this case. 意思是：为了在固定大小和动态大小的矩阵上提供统一的API，在固定大小的矩阵上使用这些构造函数是合法的，即使在这种情况下传递大小是无用的。</p><hr><p>所以只能使用规定的输入方法： Matrix3f a;</p><p>　　　　　　　　　　　　　　 a&lt;&lt;1,2,3,</p><p>　　　　　　　　　　　　　　&nbsp; &nbsp; &nbsp; &nbsp;4,5,6,</p><p>　　　　　　　　　　　　　　　　7,8,9;</p><hr><p>说完静态矩阵，接下来说动态矩阵：typedef Matrix &lt;double,Dynamic,Dynamic&gt; MatrixXd;</p><p>看如下对比即可明白：</p><p>一般Matrix4f mymatrix; 等价于 float mymatrix[16];<br />一般MatrixXf mymatrix(rows,columns); 等价于 float *mymatrix = new float[rows*columns];</p><hr><p>所以有 MatrixXf a(2,2) 即定义一个2x2的矩阵，而且Eigen库有访问矩阵中值的特定方式。</p><p>如<img src="https://img2020.cnblogs.com/blog/1582514/202012/1582514-20201230140825999-966352070.png" alt="" loading="lazy" />，&nbsp;</p><hr><p>访问第一行第一个元素 即 a(0,1) ,也可 a(0,1) = x 为第一行第一个元素赋值。</p><p>如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">MatrixXd <span class="title">m</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="built_in">m</span>(<span class="number">0</span>,<span class="number">0</span>) = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">m</span>(<span class="number">1</span>,<span class="number">0</span>) = <span class="number">2.5</span>;</span><br><span class="line"><span class="built_in">m</span>(<span class="number">0</span>,<span class="number">1</span>) = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">m</span>(<span class="number">1</span>,<span class="number">1</span>) = <span class="built_in">m</span>(<span class="number">1</span>,<span class="number">0</span>) + <span class="built_in">m</span>(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Here is the matrix m:\n&quot;</span> &lt;&lt; m &lt;&lt; std::endl;</span><br><span class="line"><span class="function">VectorXd <span class="title">v</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="built_in">v</span>(<span class="number">0</span>) = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">v</span>(<span class="number">1</span>) = <span class="built_in">v</span>(<span class="number">0</span>) - <span class="number">1</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Here is the vector v:\n&quot;</span> &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Here is the matrix m:</span><br><span class="line">  <span class="number">3</span>  <span class="number">-1</span></span><br><span class="line"><span class="number">2.5</span> <span class="number">1.5</span></span><br><span class="line">Here is the vector v:</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>像这类动态分配大小的矩阵，有 resize()方法，可以重新定义大小，这篇代码写的很清楚：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">MatrixXd <span class="title">m</span><span class="params">(<span class="number">2</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">m.<span class="built_in">resize</span>(<span class="number">4</span>,<span class="number">3</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;The matrix m is of size &quot;</span></span><br><span class="line">&lt;&lt; m.<span class="built_in">rows</span>() &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; m.<span class="built_in">cols</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;It has &quot;</span> &lt;&lt; m.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; coefficients&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="function">VectorXd <span class="title">v</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">v.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;The vector v is of size &quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;As a matrix, v is of size &quot;</span></span><br><span class="line">&lt;&lt; v.<span class="built_in">rows</span>() &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; v.<span class="built_in">cols</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The matrix m is of size <span class="number">4</span>x3</span><br><span class="line">It has <span class="number">12</span> coefficients</span><br><span class="line">The vector v is of size <span class="number">5</span></span><br><span class="line">As a matrix, v is of size <span class="number">5</span>x1</span><br></pre></td></tr></table></figure><hr><p>&nbsp;然后说明一下固定尺寸与动态尺寸的选择问题，也就是什么时候静态分配最好，什么时候动态分配最好。</p><p>&nbsp;对于非常小的尺寸，尽可能使用Fixed（一般定义为小于等于16），这种情况下使用Fixed尺寸性能更加优越,因为它可以让Eigen避免动态内存分配和展开循环，对于较大尺寸的话就使用dynamic尺寸，</p><p>&nbsp;当然，使用固定大小的局限性在于，只有在编译时知道大小时才有可能。另外，对于足够大的尺寸，比如说大于或等于32的尺寸，使用固定尺寸的性能优势就变得微不足道了。更糟糕的是，如果试图在函数中使用固定大小创建一个非常大&nbsp; &nbsp;的矩阵，可能会导致堆栈溢出，因为Eigen会尝试将数组作为一个局部变量自动分配，而这通常是在堆栈中完成的。最后，根据不同的情况，当使用动态大小时，Eigen还可以更积极地尝试矢量化（使用SIMD指令）。</p><hr><p>&nbsp;最后解释一下上面说过的可选参数模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Matrix&lt;<span class="keyword">typename</span> Scalar,</span><br><span class="line">　　　　　　<span class="keyword">int</span> RowsAtCompileTime,</span><br><span class="line">　　　　　　<span class="keyword">int</span> ColsAtCompileTime,</span><br><span class="line">　　　　　　<span class="keyword">int</span> Options = <span class="number">0</span>,</span><br><span class="line">　　　　　　<span class="keyword">int</span> MaxRowsAtCompileTime = RowsAtCompileTime,</span><br><span class="line">　　　　　　<span class="keyword">int</span> MaxColsAtCompileTime = ColsAtCompileTime&gt;</span><br></pre></td></tr></table></figure><p>从参数的定义名即可看出来其大概意思。</p><p>分析：Matrix&lt;float,Dynamic,Dynamic,0,3,4&gt;&nbsp; 一个不知道大小，但最大行数为3，最大列数为4的矩阵。<br />从官方文档对于Matrix Optional template parameters 的定义来看，这是一个确定了上限的固定内存矩阵，如果在编译时不知道矩阵的确切大小，但在编译时可以知道一个固定的上限，这样做可以避免动态内存分配。</p><p>第三个参数是什么意思呢，在我看来是一个优先级的参数，比如一个矩阵是行优先还是列优先就是使用这个参数，0一般是默认值，不设置任何优先。</p><p>比如：Matrix&lt;float,3,3,RowMajor&gt; 就是一个行优先的矩阵。</p><hr><p>补充Eigen便利类型定义：</p><p><a class="el" title="Namespace containing all symbols from the Eigen library." href="http://eigen.tuxfamily.org/dox/namespaceEigen.html">Eigen</a>&nbsp;defines the following&nbsp;<a class="el" title="The matrix class, also used for vectors and row-vectors." href="http://eigen.tuxfamily.org/dox/classEigen_1_1Matrix.html">Matrix</a>&nbsp;typedefs:</p><ul><li>MatrixNt for Matrix&lt;type, N, N&gt;. For example, MatrixXi for Matrix&lt;int, Dynamic, Dynamic&gt;.</li><li>VectorNt for Matrix&lt;type, N, 1&gt;. For example, Vector2f for Matrix&lt;float, 2, 1&gt;.</li><li>RowVectorNt for Matrix&lt;type, 1, N&gt;. For example, RowVector3d for Matrix&lt;double, 1, 3&gt;.</li></ul><p>Where:</p><ul><li>N can be any one of&nbsp;<code>2</code>,&nbsp;<code>3</code>,&nbsp;<code>4</code>, or&nbsp;<code>X</code>&nbsp;(meaning&nbsp;<code>Dynamic</code>).</li><li>t can be any one of&nbsp;<code>i</code>&nbsp;(meaning int),&nbsp;<code>f</code>&nbsp;(meaning float),&nbsp;<code>d</code>&nbsp;(meaning double),&nbsp;<code>cf</code>&nbsp;(meaning complex&lt;float&gt;), or&nbsp;<code>cd</code>(meaning complex&lt;double&gt;). The fact that typedefs are only defined for these five types doesn't mean that they are the only supported scalar types. For example, all standard integer types are supported, see&nbsp;<a class="el" href="http://eigen.tuxfamily.org/dox/TopicScalarTypes.html">Scalar types</a>.</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;The-Matrix-Class&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#The-Matrix-Class&quot;&gt;¶&lt;/a&gt;The Matrix Class&lt;/h2&gt;
&lt;p&gt;Eigen库 矩阵类的使用：&lt;/p&gt;
&lt;p&gt;（本文根据官方文档加上自</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="Eigen" scheme="http://example.com/tags/Eigen/"/>
    
  </entry>
  
  <entry>
    <title>线性代数及其应用(二)</title>
    <link href="http://example.com/2021/03/26/lial2/"/>
    <id>http://example.com/2021/03/26/lial2/</id>
    <published>2021-03-26T11:00:38.711Z</published>
    <updated>2021-03-26T11:05:08.478Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线性代数及其应用-二"><a class="header-anchor" href="#线性代数及其应用-二">¶</a>线性代数及其应用(二)</h2><p>向量方程</p><p>线性方程组的重要性质都可用向量概念与符号来描述。</p><p><strong>R</strong><sup>2</sup>中的向量:</p><p>　　仅含一列的矩阵称为列向量，或简称向量，包含两个元素的向量如下：</p><p>　　<img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114203419813-1752537434.png" alt="" loading="lazy" /><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114203438965-2116671834.png" alt="" loading="lazy" /><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114203521345-1191418457.png" alt="" loading="lazy" /></p><hr><p>&nbsp;　&nbsp; 其中w<sub>1</sub>和w<sub>2</sub>是任意实数，所有两个元素的向量集记为<strong>R</strong><sup>2</sup>，<strong>R</strong>表示向量中的元素是实数，而指数2表示每个向量包含两个元素.&nbsp;</p><p>　　给定<strong>R</strong><sup>2</sup>中两个向量u和v，它们的和u+v是把u和v对应元素相加所得的向量，如</p><p>　　<img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114203944587-551626870.png" alt="" loading="lazy" /></p><hr><div class="cnblogs_code"><pre><span style="color: #000000;">\begin{bmatrix}</span><span style="color: #800080;">1</span><span style="color: #000000;">\\ </span>-<span style="color: #800080;">2</span><span style="color: #000000;">\\\end{bmatrix}</span>+<span style="color: #000000;">\begin{bmatrix}</span><span style="color: #800080;">2</span><span style="color: #000000;">\\ </span><span style="color: #800080;">5</span><span style="color: #000000;">\\\end{bmatrix}</span>=<span style="color: #000000;">\begin{bmatrix}</span><span style="color: #800080;">1</span>+<span style="color: #800080;">2</span><span style="color: #000000;">\\ </span>-<span style="color: #800080;">2</span>+<span style="color: #800080;">5</span><span style="color: #000000;">\\\end{bmatrix}</span>=<span style="color: #000000;">\begin{bmatrix}</span><span style="color: #800080;">3</span><span style="color: #000000;">\\ </span><span style="color: #800080;">3</span><span style="color: #000000;">\\\end{bmatrix}</span></pre></div><hr><p>　　给定向量u和实数c,u与c的标量乘法（或数乘）是把u的每个元素乘以c,所得向量记为cu，例如：</p><p>　　若<img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114204144474-273683973.png" alt="" loading="lazy" />;, c = 5,则</p><hr><p>&nbsp; &nbsp; &nbsp; &nbsp;<img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114204235817-645942824.png" alt="" loading="lazy" /></p><hr><div class="cnblogs_code"><pre>cu = <span style="color: #800080;">5</span><span style="color: #000000;">\begin{bmatrix}</span><span style="color: #800080;">3</span><span style="color: #000000;">\\ </span>-<span style="color: #800080;">1</span><span style="color: #000000;">\\\end{bmatrix}</span>=<span style="color: #000000;">\begin{bmatrix}</span><span style="color: #800080;">15</span><span style="color: #000000;">\\ </span>-<span style="color: #800080;">5</span><span style="color: #000000;">\\\end{bmatrix}</span></pre></div><hr><p><strong>&nbsp;R</strong><sup>2</sup>的几何表示</p><p>　　考虑平面上的直角坐标系，因为平面上每个点由实数的有序对确定，所以可把几何点(a,b) 与列向量<img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114204443579-1598459939.png" alt="" loading="lazy" />等同，因此我们可把R<sup>2</sup>看作平面上所有点的集合</p><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114204712781-911184167.png" alt="" loading="lazy" />&nbsp;&nbsp;<hr><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114204820571-445091784.png" alt="" loading="lazy" /></p></p><hr><p>&nbsp;　　两个向量的和的几何意义</p><p>　　<img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114205154150-1250560095.png" alt="" loading="lazy" /></p><hr><p>　　<strong>R</strong><sup>3</sup>中的向量</p><p>　　<img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114205719156-1126824442.png" alt="" loading="lazy" /></p><hr><p>　　<strong>R</strong><sup>n</sup>中的代数性质 （对<strong>R</strong><sup>n</sup>中一切向量u,v,w以及标量c和d）：</p><p>　　1. u + v = v + u</p><p>　　2.(u+v)+w = u+(v+w)</p><p>　　3.(u+0)=0+u=u</p><p>　　4.u+(-u) = -u+u =0</p><p>　　5.c(u+v)=cu+cv</p><p>　　6.(c+d)u=cu+du</p><p>　　7.c(du)=(cd)u</p><p>　　8.1u=u</p><hr><p>　　线性代数的一个主要思想是研究可以表示为某一个固定向量集合{v<sub>1</sub>,v<sub>2</sub>,....v<sub>p</sub>}的线性组合的所有向量</p><p>　　Span{v} 与 Span{u,v}的几何解释</p><p>　　设v是<strong>R</strong><sup>3</sup>中的向量，那么Span{v}就是v的所有标量倍数的集合，也就是<strong>R</strong><sup>3</sup>中通过v和0的直线上所有点的集合</p><p>　　</p><p>&nbsp;　　<img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114210420986-390914887.png" alt="" loading="lazy" /></p><hr><p>　　　若u和v是<strong>R</strong><sup>3</sup>中的非零向量，v不是u的倍数，则Span{u,v}是<strong>R</strong><sup>3</sup>中包含u,v和0的平面，特别地，Span{u,v}包含<strong>R</strong><sup>3</sup>中通过u与0的直线，也包含通过v与0的直线，反正就是确定了一个平面。</p><p>　　　　</p><p>&nbsp;　　<img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114210841656-276500780.png" alt="" loading="lazy" /></p><hr><p>&nbsp;　　蓝色范围在概念上无限扩充。</p><p>&nbsp;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;线性代数及其应用-二&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#线性代数及其应用-二&quot;&gt;¶&lt;/a&gt;线性代数及其应用(二)&lt;/h2&gt;
&lt;p&gt;向量方程&lt;/p&gt;
&lt;p&gt;线性方程组的重要性质都可用向量概念与符号来描述。&lt;/p&gt;
&lt;p&gt;&lt;strong</summary>
      
    
    
    
    <category term="数学" scheme="http://example.com/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="线性代数" scheme="http://example.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>线性代数及其应用(一)</title>
    <link href="http://example.com/2021/03/26/lial1/"/>
    <id>http://example.com/2021/03/26/lial1/</id>
    <published>2021-03-26T10:58:34.458Z</published>
    <updated>2021-03-26T11:00:26.140Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线性代数及其应用-一"><a class="header-anchor" href="#线性代数及其应用-一">¶</a>线性代数及其应用(一)</h2><p>线性方程组：</p><p>包含变量x<sub>1</sub>,x<sub>2</sub>，&hellip;&hellip;，x<sub>n</sub>的线性方程是形如</p><p>　　　　　　　　　　a<sub>1</sub>x<sub>2</sub> +a<sub>2</sub>x<sub>2</sub>+...+a<sub>3</sub>x<sub>3</sub>&nbsp; = b&nbsp;</p><p>的方程，其中b与系数a<sub>1&nbsp; &nbsp;</sub>，a<sub>2&nbsp;</sub>&nbsp;，&hellip;&hellip; ，a<sub>n是实数或者复数，通常是已知数，下标n可以是任意正整数。</sub><sub><br /></sub></p><hr><p>线性方程组的解有下列三种情况：</p><p>①无解</p><p>②有唯一解</p><p>③有无穷多解</p><hr><p>若一个线性方程组有一个解或无穷多个解，则称它是相容的，若它无解，则称它是不相容的。</p><hr><p>初等行变换：</p><p>①（倍加变换）把某一行换成它本身与另一行的倍数的和</p><p>②（对换变换）把两行对换</p><p>③（倍乘对换）把某一行的所有元素乘以同一个非零数</p><hr><p>行变换可以施与任何矩阵，不仅仅是对于线性方程组的增广矩阵，若其中一个矩阵可以经过一系列初等行变换变换成另外一个矩阵，则我们称这两个矩阵是等价的。</p><p>若两个线性方程组的增广矩阵是行等价的，则它们具有相同的解集。</p><hr><p>行简化与阶梯形矩阵</p><p>定义：一个矩阵称为阶梯形（或行阶梯形），则它有已下三个性质：</p><p>①每一非零行都在每一零行之上</p><p>②某一行的先导元素所在的列位于前一行先导元素的右边</p><p>③某一先导元素所在列下方元素都是零</p><p>一个矩阵称为简化阶梯形，则它满足以下性质：</p><p>①每一非零行的先导元素是1</p><p>②每一先导元素1是该元素所在列的唯一非零元素</p><hr><p>通常将矩阵变换成简化阶梯形矩阵的过程称为高斯消元法。（计算机程序通常选择一列中绝对值最大的元素作为主元，可以减少舍入误差）</p><p>但某些条件下高斯消元法不适用，使用的是部分主元法（列主元高斯消元法）</p><hr><p>原因：</p><p>&nbsp;</p><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210111155846873-924934418.png" alt="" loading="lazy" /></p><hr><p>&nbsp;<img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210111155905395-20983245.png" alt="" loading="lazy" /></p><hr><p>&nbsp;图片来自：<a href="https://www.zhihu.com/question/33862337">https://www.zhihu.com/question/33862337</a></p><hr><p>部分主元法思想：在进行第k(k=1,2,3...n-1)步消元时，从第k列的a<sub>kk</sub>及其以下的各元素中选取绝对值最大的元素，然后通过行变换将它交换到主元素a<sub>kk</sub>的位置上，再进行消元。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;线性代数及其应用-一&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#线性代数及其应用-一&quot;&gt;¶&lt;/a&gt;线性代数及其应用(一)&lt;/h2&gt;
&lt;p&gt;线性方程组：&lt;/p&gt;
&lt;p&gt;包含变量x&lt;sub&gt;1&lt;/sub&gt;,x&lt;sub&gt;2&lt;/sub&gt;，&amp;hell</summary>
      
    
    
    
    <category term="数学" scheme="http://example.com/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="线性代数" scheme="http://example.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++关于数据和函数</title>
    <link href="http://example.com/2021/03/26/C++datafuc/"/>
    <id>http://example.com/2021/03/26/C++datafuc/</id>
    <published>2021-03-26T10:51:03.688Z</published>
    <updated>2021-03-26T10:55:26.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-关于数据和函数"><a class="header-anchor" href="#C-关于数据和函数">¶</a>C++关于数据和函数</h2><p><span style="color: #000000; font-size: 14pt;">C++关于数据和函数</span></p><p>C语言在设计程序的时候会准备一些数据和函数，函数用来处理你创造的数据，这样会有一些缺点，由于语言没有提供足够的关键字，所以这些数据一定是全局的，所以所有的函数都可以处理这些数据，在后期会造成很大的影响的，所以面向对象语言C++出现了，基本思想是把数据和处理这些数据的函数包装在一起，也就是&ldquo;类&rdquo;，类其实和结构体是差不多的。</p><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210111195119606-1812816107.png" alt="" loading="lazy" /></p><hr><p>类是否涉及指针，一定要特别注意</p><p>Class 的 两个经典分类：</p><p>&middot;Class without pointer member(s)</p><p>&middot;Class with pointer member(s)</p><hr><p><span style="font-size: 14pt;">C++ program 代码基本形式</span></p><p>&nbsp;</p><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210111195754227-2039798270.png" alt="" loading="lazy" /></p><hr><p>&nbsp;.h 头文件 与 .cpp 代码程序</p><p>用#include的方法使用头文件，标准库也是类似。</p><p>使用自己的写的头文件使用双引号"",默认库使用尖括号&lt;&gt;</p><p>延伸文件名不一定是.h或.cpp</p><p>也可能是.hpp甚至是无延伸名</p><p>在不同的平台上可能不同。</p><p>Header头文件中的防卫式声明</p><p>#ifndef _XXX_&nbsp; &nbsp; &nbsp; &nbsp;//if not define 如果没有被定义（引用）过</p><p>#define _XXX_&nbsp; &nbsp; &nbsp; //则执行下列代码直到#endif</p><p>...</p><p>...</p><p>#endif&nbsp; //若第一行判定被定义过，则直接跳到#endif</p><p>作用是避免多重调用,出现重定义错误！</p><hr><p>比如 我在 Main.cpp 中&nbsp;</p><div class="cnblogs_code"><pre>#include<span style="color: #800000;">"</span><span style="color: #800000;">op1.h</span><span style="color: #800000;">"</span><span style="color: #000000;">#include</span><span style="color: #800000;">"</span><span style="color: #800000;">op2.h</span><span style="color: #800000;">"</span><span style="color: #000000;">.........</span></pre></div><p>而在op2.h中</p><div class="cnblogs_code"><pre>#include<span style="color: #800000;">"</span><span style="color: #800000;">op1.h</span><span style="color: #800000;">"</span><span style="color: #000000;">.........</span></pre></div><p>&nbsp;这样就形成了多重调用，因为op2.h中包含了op1.h，而在Main.cpp中既调用了op2.h也调用了op1.h。</p><p>&nbsp;<span style="color: #ff0000;">所以要养成写任何一个头文件都要使用#ifndef来避免重定义的习惯。</span></p><hr><p>既然有 #ifndef ，所以也有#ifdef</p><p>当在不同平台下编写代码时，由于环境不同，所以要使用的头文件也会不同，这时就可以用到#ifdef</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> OS_Win</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> OS_Linux</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这样就实现了windows环境下调用windows.h 而Linux环境下则调用linux.h。</p><p>Class 的声明（拿complex来举例）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">complex</span> (<span class="keyword">double</span> r = <span class="number">0</span> , <span class="keyword">double</span> i = <span class="number">0</span> ) <span class="comment">//构造函数</span></span><br><span class="line">    : <span class="built_in">re</span>(r),<span class="built_in">im</span>(i)</span><br><span class="line">   &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    complex&amp; <span class="keyword">operator</span> += (<span class="keyword">const</span> complex&amp;); <span class="comment">//重载+=</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">real</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> re;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> im;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> re,im;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>public: 下的函数或者数据都是可以直接给外界访问的，而private：下的函数或数据只能内部访问。实现数据与函数封装。</p><hr><p>class template(模板）</p><p>当你使用大量同一种数据类型的变量的时候，突然想改变这些变量的数据类型，那么一条一条代码去改是很难实现的，就比如上面有变量re和im，我想同时改变它们两个的数据类型，首先是变量声明那改成另一种数据类型，但是还有相关函数呢，返回的也是double类型，也需要更改，而且构造函数中传入的参数也是double类型，几乎所有地方都要修改，这样就显得极其麻烦，而且如果想通过不同的情况随时更改无法实现，灵活性也极差。</p><p>那么就使用到了&ldquo;模板&rdquo;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">complex</span> (T r = <span class="number">0</span> , T = <span class="number">0</span> ) <span class="comment">//构造函数</span></span><br><span class="line">    : <span class="built_in">re</span>(r),<span class="built_in">im</span>(i)</span><br><span class="line">   &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    complex&amp; <span class="keyword">operator</span> += (<span class="keyword">const</span> complex&amp;); <span class="comment">//重载+=</span></span><br><span class="line">    <span class="function">T <span class="title">real</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> re;&#125;</span><br><span class="line">    <span class="function">T <span class="title">imag</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> im;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T re;</span><br><span class="line">    T im;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">...主函数...</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">complex&lt;<span class="keyword">double</span>&gt; <span class="title">c1</span><span class="params">(<span class="number">2.5</span>,<span class="number">1.5</span>)</span></span>;</span><br><span class="line">    <span class="function">complex&lt;<span class="keyword">int</span>&gt; <span class="title">c1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就想使用double类型就用double模板，使用int类型就用int模板。灵活性强。</p><hr><p>关于 避免头文件重定义的补充：</p><p>我们已经知道一种方法 #ifndef</p><p>还有一种方法是 #pragma once</p><p>那么这两种方法有什么区别呢？</p><p>#ifndef 因为要定义宏名，如果出现两个头文件定义的宏名相同的话，可能会导致使用该头文件，但编译器找不到。</p><p>#pragma once则由编译器提供保证：同一个文件不会被包含多次。且这个文件是物理上的文件，缺点是如果物理文件被拷贝多次会导致无法避免重定义，且不支持跨平台。</p><hr><p>所以两种方法的使用需要根据情况来把握。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-关于数据和函数&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#C-关于数据和函数&quot;&gt;¶&lt;/a&gt;C++关于数据和函数&lt;/h2&gt;
&lt;p&gt;&lt;span style=&quot;color: #000000; font-size: 14pt;&quot;&gt;C++关于数据</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++学习" scheme="http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>C++ 重载</title>
    <link href="http://example.com/2021/03/26/C++opcz/"/>
    <id>http://example.com/2021/03/26/C++opcz/</id>
    <published>2021-03-26T10:46:25.415Z</published>
    <updated>2021-03-26T10:50:22.917Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-重载"><a class="header-anchor" href="#C-重载">¶</a>C++ 重载</h2><p>操作符就是一种函数，是可以让你重新定义的<br />比如说相加，与其自己写个相加函数 plus(u,v); 将u,v相加，<br />用 "+" 号 显得更为方便，可读性更高，所以C++就出现了重载运算符这个功能。<br />并且可以实现将各种你需要的属性相加。</p><p>一般来说，重载操作符的对象会有接收者和传递者</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> complex&amp;</span><br><span class="line">complex::<span class="keyword">operator</span> += (<span class="keyword">this</span>,<span class="keyword">const</span> complex&amp; r)&#123;</span><br><span class="line"><span class="keyword">return</span> __doapl(<span class="keyword">this</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面那个this,是不需要写的  比如 complex c1,c2;<br />c1 += c2;<br />c1就是this。代表操作对象中的接收者。<br />所以一般会这么写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> complex&amp;</span><br><span class="line">complex::<span class="keyword">operator</span> += (<span class="keyword">const</span> complex&amp; r)&#123; <span class="comment">//省略了this</span></span><br><span class="line"><span class="keyword">return</span> __doapl(<span class="keyword">this</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>return by reference语法分析<br />传递者无需知道接收者是以什么形式接收</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> complex&amp; __doapl(complex * ths,<span class="keyword">const</span> complex&amp; r)&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> *ths;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> complex&amp;</span><br><span class="line">complex::<span class="keyword">operator</span> += (<span class="keyword">const</span> complex&amp; r)&#123;</span><br><span class="line"><span class="keyword">return</span> __doapl(<span class="keyword">this</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>可以看到 第一个函数明明是 complex&amp; __doapl(...)<br />返回的却是一个value,return *ths, 这里是没有错误的，因为C++有个特性，就是return by reference,一般来说返回一个引用，会比返回一个值快很多，接收者与其接收其值，不如接收它的引用（也就是地址），而且传递者也不需要知道接收者如何接收，这样下来整个程序会快很多，避免了很多转换。<br />complex::operator += (const complex&amp; r) 也是一样，接收的是 c2 的引用，而不需要接收c2的值，直接通过引用去得到它的值，比起创建一个临时空间去转换去获取它的值要快的多。</p><hr><p>temp object(临时对象) typename();<br />刚刚说到了return by reference 比传value快，但下面这些情况，是一定不能return by reference的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="function">complex <span class="title">c1</span><span class="params">(<span class="number">2</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">complex c2;</span><br><span class="line">c2 = c1 + c2;</span><br><span class="line">c2 = c1 + <span class="number">5</span>;</span><br><span class="line">c2 = <span class="number">7</span> + c1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对应 c1 + c2</span></span><br><span class="line"><span class="keyword">inline</span> complex</span><br><span class="line"><span class="keyword">operator</span> + (<span class="keyword">const</span> complex&amp; x,<span class="keyword">const</span> complex&amp; y)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">complex</span> (<span class="built_in">real</span>(x) + <span class="built_in">real</span>(y) , <span class="built_in">imag</span>(x) + <span class="built_in">imag</span>(y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对应 c1 + 5</span></span><br><span class="line"><span class="keyword">inline</span> complex</span><br><span class="line"><span class="keyword">operator</span> + (<span class="keyword">const</span> complex&amp; x,<span class="keyword">double</span> y)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">complex</span> (<span class="built_in">real</span>(x) + y , <span class="built_in">imag</span>(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//对应 5 + c1</span></span><br><span class="line"><span class="keyword">inline</span> complex</span><br><span class="line"><span class="keyword">operator</span> + (<span class="keyword">double</span> x,<span class="keyword">const</span> complex&amp; y)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">complex</span> (x + <span class="built_in">real</span>(y) , <span class="built_in">imag</span>(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里也看出来 + 操作也分很多种不同情况。<br />为什么这里不能传引用呢，可以跟刚才的对比一下，<br />因为刚才我们传引用之后进行 += 操作之后，是将结果直接传给了C1，而现在我们没有一个地方存放结果，如果传引用，函数一结束，直接死亡，就等于什么也没做，所以我们需要一个临时complex对象，去存放结果，再将临时对象的结果返回到 c2 , 这样才是正确的，然后销毁临时对象。</p><p>注：typename() 就等于是创建临时变量，像上面的 complex( ... , ... )，也可以是int(7),double(3.65)等等...</p><hr><p>最后是关于返回类型的注意事项<br />比如说：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> complex&amp;</span><br><span class="line">complex::<span class="keyword">operator</span> += (<span class="keyword">const</span> complex&amp; r)&#123;</span><br><span class="line"><span class="keyword">return</span> __doapl(<span class="keyword">this</span>,r);</span><br><span class="line">&#125;</span><br><span class="line">改成：</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">complex::<span class="keyword">operator</span> += (<span class="keyword">const</span> complex&amp; r)&#123;</span><br><span class="line"><span class="keyword">return</span> __doapl(<span class="keyword">this</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会引起什么问题呢<br />如果说是 c1+=c2; 这样依然不会有任何问题，因为c2赋值到c1上（也就是执行__doapl()之后就完成了）<br />不用再管接下来返回的是什么类型了，所以改成void是没有问题的。<br />但如果是 c3 += c2 += c1;呢，当c1 赋值到 c2 上后，c2必须还要以 complex 类型 加到c3身上，如果返回的是void类型，那么是无法加到c3上面的，所以设计上考虑周全一点，还是会以第一种形式设计重载。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-重载&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#C-重载&quot;&gt;¶&lt;/a&gt;C++ 重载&lt;/h2&gt;
&lt;p&gt;操作符就是一种函数，是可以让你重新定义的&lt;br /&gt;比如说相加，与其自己写个相加函数 plus(u,v); 将u,v相加，&lt;br /&gt;用</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++学习" scheme="http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>C++ stack与heap</title>
    <link href="http://example.com/2021/03/26/C++stackheap/"/>
    <id>http://example.com/2021/03/26/C++stackheap/</id>
    <published>2021-03-26T09:09:14.141Z</published>
    <updated>2021-03-26T09:13:39.539Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-stack与heap"><a class="header-anchor" href="#C-stack与heap">¶</a>C++ stack与heap</h2><p>stack(栈) heap(堆)<br />Stack,是存在于某作用域(scope)的一块内存空间(memory space).例如当你调用函数，函数本身即会形成一个stack用来放置它所接收的参数，以及返回地址。</p><p>在函数本身(function body)内声明的任何变量，其所使用的内存块都取自于上述stack.</p><p>Heap，或者说system heap,是指由操作系统提供的一块global内存空间，程序可动态分配(dynamic allocated)从中获得若干区块(blocks)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span>...&#125;;</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;<span class="comment">// c1所占用的空间来自stack</span></span><br><span class="line">Complex * p = <span class="keyword">new</span> <span class="built_in">Complex</span>(<span class="number">3</span>); </span><br><span class="line"><span class="comment">//Complex(3)是个临时对象，其所占用的空间是以new自heap动态分配而得，并由p指向</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>stack objects 的生命周期</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span>...&#125;;</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c1便是所谓stack object,其生命在作用域(scope)结束时结束。<br />这种作用域内的object,又称为auto object,因为它会被自动释放。</p><p>static local objects 的生命周期</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span>...&#125;;</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Complex <span class="title">c2</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c2便是所谓static object,其生命在作用域(scope)结束时仍然存在，直到整个程序结束.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span>...&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="function">Complex <span class="title">c3</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>c3就是global object,其生命在整个程序结束之后才结束，也可以把它视为一种static object,其作用域是整个程序.</p><p>heap objects 的生命周期</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span>...&#125;;</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">Complex* p = <span class="keyword">new</span> Complex;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>p所指的是heap object,其生命在它被deleted时结束。</p><div class="cnblogs_code"><pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Complex{...};...<p>{<br>Complex</span>* p = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Complex;<br>}</span></pre></p></div><hr><p>以上出现内存泄露(memory leak)，因为当作用域结束，p所指的heap object仍然存在，但指针<br />p的生命却结束了，作用域之外再也看不到p(也就没机会delete p)了。<br />尽可能避免这种情况。</p><p>new:先分配memory，再调用ctor</p><p>Complex * pc = new Complex(1,2);</p><p>三个步骤。<br />编译器转化为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Complex * pc;</span><br><span class="line"><span class="comment">// operator new是C++中的一个特殊函数，其本质也是调用了malloc分配内存</span></span><br><span class="line"><span class="number">1.</span><span class="keyword">void</span> * mem = <span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Complex));</span><br><span class="line"><span class="number">2.</span>pc = <span class="keyword">static_cast</span>&lt;Complex*&gt;(mem); <span class="comment">//将mem指针转为Complex类型的指针</span></span><br><span class="line"><span class="number">3.</span>pc-&gt;Complex::<span class="built_in">Complex</span>(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">//构造函数 本质 Complex::Complex(pc,1,2); 这里的pc相当于this,是不可见的</span></span><br></pre></td></tr></table></figure><p>delete: 先调用 dtor,再释放memory</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String * ps = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> ps;</span><br></pre></td></tr></table></figure><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String::~<span class="built_in">String</span>(ps); <span class="comment">//析构函数</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(ps)</span></span>; <span class="comment">//释放内存，operator delete()是C++中的一个特殊函数其内部调用free(ps)</span></span><br></pre></td></tr></table></figure><p>array new 一定要搭配 array delete</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String * p = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span>[] p; <span class="comment">//唤起3次dtor</span></span><br><span class="line"></span><br><span class="line">String * p = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> p; <span class="comment">//唤起1次dtor</span></span><br></pre></td></tr></table></figure><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210113170228948-1252176890.png" alt="" loading="lazy" /></p><p>&nbsp;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-stack与heap&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#C-stack与heap&quot;&gt;¶&lt;/a&gt;C++ stack与heap&lt;/h2&gt;
&lt;p&gt;stack(栈) heap(堆)&lt;br /&gt;Stack,是存在于某作用域(scope)的</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++学习" scheme="http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>C++引用小结</title>
    <link href="http://example.com/2021/03/26/C++refer/"/>
    <id>http://example.com/2021/03/26/C++refer/</id>
    <published>2021-03-26T09:05:54.114Z</published>
    <updated>2021-03-26T09:08:38.497Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-引用小结"><a class="header-anchor" href="#C-引用小结">¶</a>C++引用小结</h2><p>从之前的博客中有提到，C++有两种特性</p><p>return by value&nbsp; &nbsp;and&nbsp; &nbsp;return by reference</p><p>一种是返回值，一种是返回引用</p><p>并且，在一般情况下，传引用比传值效率更高。</p><hr><p>先说说引用是什么，引用用的是&amp;符号，&amp;符号既可以用来当引用，也可以用来当取地址符，只不过使用方法不同。</p><p>引用的本质是别名。</p><p>引用的基本使用方法是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> &amp; a = b;</span><br></pre></td></tr></table></figure><p>此时a就是b的引用，也就是b的别名，那可能会发现一个问题，我为什么不直接用b，而去特意创建一个别名去使用b呢。</p><p>这里去思考一下typedef的作用就知道了。</p><hr><p>我们可以用它来接收返回值，并且创建引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> complex&amp;</span><br><span class="line">__doaml (complex* ths, <span class="keyword">const</span> complex&amp; r)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">double</span> f = ths-&gt;re * r.re - ths-&gt;im * r.im;</span><br><span class="line">  ths-&gt;im = ths-&gt;re * r.im + ths-&gt;im * r.re;</span><br><span class="line">  ths-&gt;re = f;</span><br><span class="line">  <span class="keyword">return</span> *ths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传递者是*ths，是一个&ldquo;实体&rdquo;，而接收者是 complex&amp; , 也就是一个引用，其实这里也可以直接接收值，但如果之后还要使用*ths,这里的用引用接收之后使用，效率会快上很多。</p><p>（可以把这整个函数想象成返回了一个 *ths 的引用）</p><hr><p>引用和指针是差不多的，因为</p><p>T&amp; ... = T* const ...&nbsp; 指针无法改变</p><p>const T&amp; ... = const T* const ... 指针无法改变，指针指向的值也无法改变</p><hr><p>所以引用就是一个不能改变指向的指针，传递的也是地址。</p><hr><p>并且引用能够解决 派生类切割问题。</p><p>比如说有两个类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     string name;</span><br><span class="line">     <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span>:</span> <span class="keyword">public</span> person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string classid;<span class="comment">//班级名</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printattribute</span><span class="params">(person p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; p.name;</span><br><span class="line">  cout &lt;&lt; p.classid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">//假设</span></span><br><span class="line">student s;</span><br><span class="line"><span class="built_in">printattribute</span>(s);</span><br></pre></td></tr></table></figure><p>当派生类对象s 传入到 printattribute()里去后，会切割掉自己原本有的属性，变成一个原原本本的基类，此时将没有classid这个属性。</p><p>如果传的是引用，则可以解决这个问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printattribute</span><span class="params">(<span class="keyword">const</span> person&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; p.name;</span><br><span class="line">  cout &lt;&lt; p.classid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样 p 的行为就和传入到函数的真实类型一致了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-引用小结&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#C-引用小结&quot;&gt;¶&lt;/a&gt;C++引用小结&lt;/h2&gt;
&lt;p&gt;从之前的博客中有提到，C++有两种特性&lt;/p&gt;
&lt;p&gt;return by value&amp;nbsp; &amp;nbsp;and&amp;nbsp</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++学习" scheme="http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>C++组合与继承</title>
    <link href="http://example.com/2021/03/26/C++zuhejicheng/"/>
    <id>http://example.com/2021/03/26/C++zuhejicheng/</id>
    <published>2021-03-26T08:55:49.033Z</published>
    <updated>2021-03-26T08:59:18.739Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-组合与继承"><a class="header-anchor" href="#C-组合与继承">¶</a>C++组合与继承</h2><p>组合与继承</p><p>Composition(复合)，表示has-a<br />复合关系简单来说，就是一个类中有另外一个类，A类中需要实现的东西，完全可以由B类中的方法来实现的话，就不需要在A类中去写，而直接去调用B类中的方法就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Sequence</span> =</span> deque&lt;T&gt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">queue</span>&#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">sequence c; <span class="comment">//底层容器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">empty</span>();&#125;</span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">size</span>();&#125;</span><br><span class="line"><span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">front</span>();&#125;</span><br><span class="line"><span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">back</span>();&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span> </span>&#123;c.<span class="built_in">push_back</span>(x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;c.<span class="built_in">pop_front</span>();&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为单向队列类queue中的一些操作完全可以由双端队列类deque中的方法去实现，所以可以在queue类中直接加入底层容器去调用deque中的方法，而不是自己实现，这就是复合。</p><hr><p>内存关系：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">queue</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">deque&lt;T&gt; c;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">deque</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Itr&lt;T&gt; start;</span><br><span class="line">Itr&lt;T&gt; finish;</span><br><span class="line">T** map;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> map_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Itr</span>&#123;</span></span><br><span class="line">T* cur;</span><br><span class="line">T* first;</span><br><span class="line">T* last;</span><br><span class="line">T** node;</span><br><span class="line">....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>算内存，由内而外，首先看结构体Itr，一个指针4字节，所以sizeof(Itr) = 4*4 =16<br />然后在 class deque中，有两个Itr结构体 加一个指针变量一个整形变量，所以sizeof(deque) = 16 * 2 + 4 + 4 = 40;<br />同理，所以sizeof(queue) = 40;</p><p>Composition(复合)关系下的构造和析构</p><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114110805972-646031218.png" alt="" loading="lazy" /></p><hr><p>构造由内而外<br />Container 的构造函数首先调用 Component 的 default 构造函数，然后才执行自己。</p><div class="cnblogs_code"><pre>Container::Container(...): Component() {...}; <span style="color: #008000;">//</span><span style="color: #008000;">因为Component的构造函数可能不止一个，编译器不知道调用哪个，所以只会调用缺省构造函数，除非自己指定参数。</span></pre></div><p>析构由外而内<br />Container 的析构函数首先执行自己，然后才调用Component的析构函数</p><div class="cnblogs_code"><pre>Container::~Container(...){... ~Component()};</pre></div><p>组装都是由内而外的，拆开肯定只能由外而内。</p><p><br />Delegation(委托).Composition by reference;<br />委托其实跟复合很像，说实在点也就是定义上有点区别。<br />不过委托就是Composition(复合) by reference，看这个应该就能明白了。</p><hr><h2 id="code￼2"><a class="header-anchor" href="#code￼2">¶</a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file String.hpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringRep</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">String</span>();</span><br><span class="line"><span class="built_in">String</span>(<span class="keyword">const</span> <span class="keyword">char</span> * s);</span><br><span class="line"><span class="built_in">String</span>(<span class="keyword">const</span> String&amp; s);</span><br><span class="line">String &amp;<span class="keyword">operator</span> = (<span class="keyword">const</span> String&amp; s);</span><br><span class="line">~<span class="built_in">String</span>();</span><br><span class="line">....</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">StringRep * rep; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file String.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;String.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringRep</span>&#123;</span></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span>;</span></span><br><span class="line"><span class="built_in">StringRep</span>(<span class="keyword">const</span> <span class="keyword">char</span> * s);</span><br><span class="line">~<span class="built_in">StringRep</span>();</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">char</span> * rep;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String::<span class="built_in">String</span>()&#123;...&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>通过调用 StringRep指针来获取到字符串"Hello"，通过下图就很明显能够看出。</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;<img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114110929461-942601926.png" alt="" loading="lazy" /></p><hr><p><br />这种模式的优点就是无论你怎么修改StringRep 对客户所需要看到的Hello都不影响，甚至可以更换委托对象。维护和更新起来特别方便。<br />可以说这两者之间就是 Handle 与 Body 的关系。</p><p>Inheritance(继承) ,表示is-a</p><div class="cnblogs_code"><pre><span style="color: #0000ff;">struct</span><span style="color: #000000;"> _List_node_base{_List_node_base</span>*<span style="color: #000000;"> _M_next;_List_node_base</span>*<span style="color: #000000;"> _M_prev;};<p>template</span>&lt;typename _Tp&gt;<br><span style="color: #0000ff;">struct</span><span style="color: #000000;"> _List_node<br>:</span><span style="color: #0000ff;">public</span><span style="color: #000000;"> _List_node_base<br>{<br>_Tp _M_data;<br>};</span></pre></p></div><hr><p>语法上继承有3种方法，最常用的就是 :public ...<br />其实struct和class是非常相似的，所以这里拿struct举例，继承是is-a的关系<br />继承在面向对象中的概念来说，就是父类与子类，比如说人类分男人，女人，人类是父类，男人与女人是子类。<br />拥有父类-人类的属性的同时，多了自己的属性。</p><p>构造由内而外</p><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114110901434-1450263716.png" alt="" loading="lazy" /></p><hr><p><br />Derived 的构造函数首先调用Base的 default 构造函数，然后才执行自己。</p><div class="cnblogs_code"><pre>Deruved::Derived(...) : Base() {...};</pre></div><p>析构由外而内<br />Derived 的析构函数首先执行自己，然后才调用Base的析构函数。</p><div class="cnblogs_code"><pre>Derived::~Derived(...){...~Base()};</pre></div><hr><p>注意：base class 的 dtor必须是virtual,否则会出现 undefined behaviod<br />养成习惯，每当创建的类有可能会作为基类衍生子类时，最好把这个类的析构函数设为虚函数(virtual)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-组合与继承&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#C-组合与继承&quot;&gt;¶&lt;/a&gt;C++组合与继承&lt;/h2&gt;
&lt;p&gt;组合与继承&lt;/p&gt;
&lt;p&gt;Composition(复合)，表示has-a&lt;br /&gt;复合关系简单来说，就是一个类中有另外</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++学习" scheme="http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>C++虚函数与多态</title>
    <link href="http://example.com/2021/03/26/C++vir2/"/>
    <id>http://example.com/2021/03/26/C++vir2/</id>
    <published>2021-03-26T08:52:43.991Z</published>
    <updated>2021-03-26T08:55:21.783Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-虚函数与多态"><a class="header-anchor" href="#C-虚函数与多态">¶</a>C++虚函数与多态</h2><p>C++ 虚函数与多态</p><p>Inheritance(继承)with virtual functions(虚函数)</p><p>non-virtual函数：你不希望derived class 重新定义(override,覆写)它<br />它已有默认定义。</p><p>pure virtual函数：你希望derived class 一定要重新定义(override,覆写)它，<br />你对他没有默认定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>; <span class="comment">// pure virtual</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(<span class="keyword">const</span> std::string&amp; msg)</span></span>; <span class="comment">// impure virtual</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">objectID</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// non-virtual</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span><span class="keyword">public</span> Shape&#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ellipse</span>:</span><span class="keyword">public</span> Shape&#123;...&#125;;</span><br></pre></td></tr></table></figure><p>形状为基类，子类为矩形，椭圆形，error()是打印错误信息的函数，那么设为虚函数的意义是，也许在子类中，我们不同的形状需要打印不同的错误信息，更为精确的错误信息的话，那么我们就可以在子类中去覆写error()函数，这样，在调用error()函数的时候调用的就是对应子类中的error()函数，那么draw()与error()有什么区别呢，可以看到 error()中是有默认操作的， const std::string&amp; msg , 而draw()中是没有任何操作的(一般在函数原型后面加"=0"就意味着纯虚函数)，这就是纯虚函数，如果父类中的一个函数为纯虚函数的话，那么这个函数是必须在子类中去覆写的。</p><p>Inheritance(继承) with virtual<br />Template Method 模板方法</p><div class="cnblogs_code"><pre><span style="color: #000000;">CDocument::OnFileOpen(){...Serialize()...};</span></pre></div><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyDoc</span>:</span></span><br><span class="line"><span class="keyword">public</span> CDocument</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="title">Serialize</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><div class="cnblogs_code"><pre><span style="color: #000000;">main(){CMyDoc myDoc;...myDoc.OnFileOpen();}</span></pre></div><hr><p>模板方法具体就是定义一个模板结构，将具体内容延迟到子类去实现。（基于"继承"）<br />在main中，我们通过子类对象myDoc调用父类中的函数OnFileOpen(),打开一个文件，<br />进入到OnFileOpen()中，首先执行了打开所有文件都需要进行的操作，然后具体打开操作需要在<br />Serialize()中实现，但每个应用如何打开只有对应的应用才知道，所以在子类中覆写 Serialize()方法，这样在OnFileOpen()中的Serialize()调用的其实是子类中的Serialize()方法，<br />灵活性也大大提高了。</p><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114192843446-885101246.png" alt="" loading="lazy" /></p><hr><p>模拟过程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDocument</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnFileOpen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//每个cout 输出代表一个实际动作</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;dialog...&quot;</span> &lt;&lt;endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;check file status...&quot;</span> &lt;&lt;endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;open file...&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="built_in">Serialize</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;close file...&quot;</span> &lt;&lt;endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;update all views...&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Serialize</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyDoc</span>:</span> <span class="keyword">public</span> CDocument</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Serialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//只有应用程序知道如何读取自己的文件格式</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;CMyDoc::Serialize()&quot;</span> &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CMyDoc myDoc; <span class="comment">//假设对应[File/Open]</span></span><br><span class="line">myDoc.<span class="built_in">OnFileOpen</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-虚函数与多态&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#C-虚函数与多态&quot;&gt;¶&lt;/a&gt;C++虚函数与多态&lt;/h2&gt;
&lt;p&gt;C++ 虚函数与多态&lt;/p&gt;
&lt;p&gt;Inheritance(继承)with virtual functions(虚</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++学习" scheme="http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>C++复合与继承下的ctor和dtor顺序</title>
    <link href="http://example.com/2021/03/26/C++ctordtor/"/>
    <id>http://example.com/2021/03/26/C++ctordtor/</id>
    <published>2021-03-26T08:50:28.927Z</published>
    <updated>2021-03-26T08:51:57.932Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-复合与继承下的ctor和dtor顺序"><a class="header-anchor" href="#C-复合与继承下的ctor和dtor顺序">¶</a>C++复合与继承下的ctor和dtor顺序</h2><p>了解到复合关系与继承关系，我们知道了复合关系下：先构造内部，再构造外部</p><p>　　　　　　　　　　　　　　　　　　继承关系下：先构造父类，再构造子类</p><hr><p>那么在既有复合关系，又有继承关系的情况下，构造与析构的顺序分别是怎样呢，基于这个问题，写一段简单的代码观察。</p><h2 id="code￼0"><a class="header-anchor" href="#code￼0">¶</a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;B&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;B&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    B b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>() &#123; cout &lt;&lt; <span class="string">&quot;C&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">C</span>() &#123; cout &lt;&lt; <span class="string">&quot;C&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    C * c = <span class="keyword">new</span> <span class="built_in">C</span>();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> c;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><p>运行结果如下：</p><div class="cnblogs_code"><pre><span style="color: #000000;">ABCCBA</span></pre></div><hr><p>可知，在复合关系与继承关系同时存在时，先构造父类，再去构造派生类以及它的内部类，而析构顺序则与构造顺序刚好相反。</p><p>补充一下类对象的创建与释放过程：</p><p>详细说明：<a href="https://blog.csdn.net/m0_37622246/article/details/99681188">https://blog.csdn.net/m0_37622246/article/details/99681188</a></p><p>类的创建过程</p><p>1、从堆栈中分配类所需要的空间。<br />2、根据需求传递或不传递参数调用构造函数，完成如下任务：</p><p><strong>①根据继承表依次调用父类的构造函数。</strong></p><p><strong>②根据成员变量的顺序依次调用成员变量的构造函数。</strong></p><p><strong>③执行构造函数体中的代码。</strong></p><p> 注意：执行构造函数的代码是整个构造函数的最后一步，要保证构造函数代码所需要的一切资源和先决条件在该代码执行前已经准备充分，并得到正确的初始化。</p><hr><p>类的释放过程</p><p>析构函数负责释放在构造函数期间获取的所有资源，它的执行过程：</p><p><strong>①先执行析构函数本身代码 </strong></p><p><strong>②调用成员类的析构函数 </strong></p><p><strong>③调用父类的析构函数</strong></p><p>如果一个类没实现析构函数，编译器会自动生成一个具有析构功能的二进制指令，它负责释放编译器能够看得到的资源（成员变量、类成员、父类成员），这就是缺省析构。</p><p>如果类中没有动态资源，也不需要做善后工作，缺省析构就完全够用了，不需要再定义新析构函数。<br />注意：缺省析构无法释放动态资源（堆内存）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-复合与继承下的ctor和dtor顺序&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#C-复合与继承下的ctor和dtor顺序&quot;&gt;¶&lt;/a&gt;C++复合与继承下的ctor和dtor顺序&lt;/h2&gt;
&lt;p&gt;了解到复合关系与继承关系，我们知道了复合关</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++学习" scheme="http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Composite模式与Prototype模式</title>
    <link href="http://example.com/2021/03/26/C++design/"/>
    <id>http://example.com/2021/03/26/C++design/</id>
    <published>2021-03-26T08:44:28.650Z</published>
    <updated>2021-03-26T08:48:42.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Composite模式与Prototype模式"><a class="header-anchor" href="#Composite模式与Prototype模式">¶</a>Composite模式与Prototype模式</h2><p>这两种模式都是基于 Delegation(委托) + Inheritance(继承)&nbsp; 而来的，</p><p>首先讲一下Composite模式，也就是组合模式，是一个经典的设计模式。</p><hr><p><strong>组合模式是什么？</strong></p><p><strong>组合模式是指将对象组合成树形结构以表示"部分-整体"的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。</strong></p><hr><p>假如我们面临一个场景，需要做一个文件类，那么我们知道，打开一个文件，文件既可以是文件夹，也可以是单体文件，为了便于识别，个体文件我们叫做Primitive,文件夹我们叫做Composite，由于文件夹里可以存放Primitive，也可以再存放Composite，形成一个递归结构，如果消耗时间去进行if-else判断显得愚钝并且效率极低，而且用户不管你如何设计，文件夹和文件如果都能当做一种东西来操作的话，是最好不过的，组合模式的目的就是让用户不再区分操作的是组合对象还是个体对象，而是以一个统一的方式来操作，实现这个目标的关键点就是设计一个抽象的基类，让它既可以代表组合对象也可以代表个体对象，这样一来，用户就不需要区分这两种对象了，只需要全部通过Compostie对象进行统一操作就行了。</p><p>（其实文件系统就是组合模型的典型应用）</p><p>&nbsp;</p><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210115204048564-983255842.png" alt="" loading="lazy" /></p><p>伪代码实现模拟：</p><h2 id="code￼0"><a class="header-anchor" href="#code￼0">¶</a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Primitive</span>:</span><span class="keyword">public</span> Component</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Primitive</span>(<span class="keyword">int</span> val):<span class="built_in">Component</span>(val)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></h2><h2 id="code￼1"><a class="header-anchor" href="#code￼1">¶</a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Component</span>(<span class="keyword">int</span> val)&#123;value = val;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component*)</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Composite</span>:</span> <span class="keyword">public</span> Component</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;Component*&gt; c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Composite</span>(<span class="keyword">int</span> val):<span class="built_in">Component</span>(val)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Component* elem)</span></span>&#123;</span><br><span class="line">        c.<span class="built_in">push_back</span>(elem);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样Composite类 通过父类指针既能接收primitive类也能接收自己。</p><p>通过下面代码就可以更加清晰看出来：</p><h2 id="code￼3"><a class="header-anchor" href="#code￼3">¶</a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Component</span>() &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component*)</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(string path)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Composite</span> :</span> <span class="keyword">public</span> Component&#123;</span><br><span class="line">    string name;</span><br><span class="line">    vector&lt;Component*&gt; c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Composite</span>(string str) :<span class="built_in">Component</span>() &#123; name = str; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Component* comp)</span> </span>&#123;</span><br><span class="line">        c.<span class="built_in">push_back</span>(comp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(string path)</span> </span>&#123;</span><br><span class="line">        vector&lt;Component*&gt;::iterator it = c.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">for</span> (; it != c.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">            Component * comp = *it;</span><br><span class="line">            string ss = path + <span class="string">&quot;\\&quot;</span> + name;</span><br><span class="line">            comp-&gt;<span class="built_in">print</span>(ss);</span><br><span class="line">            <span class="keyword">delete</span> comp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Primitive</span> :</span> <span class="keyword">public</span> Component &#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Primitive</span>(string str) :<span class="built_in">Component</span>() &#123; name = str; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(string path)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; path &lt;&lt; <span class="string">&quot;\\&quot;</span> &lt;&lt; name &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;创建目录中...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Composite * rootdir = <span class="keyword">new</span> <span class="built_in">Composite</span>(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">    Composite * dis_o = <span class="keyword">new</span> <span class="built_in">Composite</span>(<span class="string">&quot;cdcd&quot;</span>);</span><br><span class="line">    Composite * dis_s = <span class="keyword">new</span> <span class="built_in">Composite</span>(<span class="string">&quot;asda&quot;</span>);</span><br><span class="line">    rootdir-&gt;<span class="built_in">add</span>(dis_o);</span><br><span class="line">    rootdir-&gt;<span class="built_in">add</span>(dis_s);</span><br><span class="line">    dis_o-&gt;<span class="built_in">add</span>(<span class="keyword">new</span> <span class="built_in">Primitive</span>(<span class="string">&quot;file1&quot;</span>));</span><br><span class="line">    dis_s-&gt;<span class="built_in">add</span>(<span class="keyword">new</span> <span class="built_in">Primitive</span>(<span class="string">&quot;file2&quot;</span>));</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输出目录&quot;</span> &lt;&lt; endl;</span><br><span class="line">    rootdir-&gt;<span class="built_in">print</span>(<span class="string">&quot;cmd:&quot;</span>);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><p>输出结果：</p><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210116112054819-1692135074.png" alt="" loading="lazy" /></p><hr><p>看得出来我们只需要对Composite类进行操作，就又可以存放自己，又可以存放Primitive类，这就是组合模式的便利之处了。</p><hr><p>接下来说Prototype模式，也就是原型模式，这个模式强大之处在于它能够在你不知道你以后要设计什么类的情况下，获取一个这个类的副本，实现一系列操作。</p><p>假如我们设计了一个框架，我们不知道以后使用人员会写入什么派生类，也总不可能去用string获取类名创建，这样是不符合C++编译标准的，那么此时就要用Prototype模式了，利用使用人员写的子类自己创建自己，然后传到自己的框架基类，获取一个副本，以实现对子类对象的操作。</p><hr><p>如下图：</p><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210116113439075-742580494.png" alt="" loading="lazy" /></p><p>&nbsp;</p><p><span style="background-color: #ffff00;">&nbsp;下划线代表静态变量，-是私有类型，#是保护类型</span></p><p>假如上面的Image类是我们自己写的，但是我们写的时候并没有LandSatImage类与SpotImage类，这些类有可能是在交付到客户手上，客户自己写的，那么我们如何去用我们自己的类来实现构造当时并不存在的类呢。</p><hr><p>可以看到 LandSatImage类，创建了一个静态的自己，那么此时，一定会调用本身的构造函数 LandSatImage(),可以看到构造函数中有addPrototype(this); 这个是父类中的一个静态函数，作为子类是可以直接调用的，这么做是为了把自己传到父类去，传完之后那么现在就全部完成了吗？还没有，此时相当于（粗略理解） 我把自己的类的指针给了父类，然后父类拿到现在这个类的指针后，保存到prototypes[]中，还要利用这个指针创建一个实例化对象，才算真正的使用，clone()的作用就是返回一个实例化对象，上图描写的很清楚，return new LandSatImage, 那么上面的 prototypes[i]-&gt;clone() 其实就相当于 LandSatImage a = new LandSatImage();所以我们获得了一个实例化对象，就可以对他进行操作了，还要注意一个很重要的点，可以看到LandSatImage中有两个构造函数，那么作用是什么呢，因为prototypes[i]-&gt;clone()调用了LandSatImage中的clone()函数，然后return new LandSatImage;此时因为创建了一个LandSatImage对象，所以还会调用构造函数，那么如果只有第一个构造函数的话，就会套娃，无限addPrototype(this); 所以用第二个构造函数，加一个数字，这样就会避免调用第一个构造函数，所以其实是在clone()函数中应该写return new LandSatImage(1);（任何数字都行）这样就不会再次调用第一个构造函数了。</p><hr><p>实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ImageType</span> &#123;</span></span><br><span class="line">    LSAT,SPOT</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Image</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Image *<span class="title">findAndClone</span><span class="params">(ImageType)</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//规定子类必须实现clone()函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Image * <span class="title">clone</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//获得子类的文件格式</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ImageType <span class="title">returnType</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addPrototype</span><span class="params">(Image * image)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _prototypes[_nextSlot++] = image;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Image * _prototypes[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> _nextSlot;</span><br><span class="line">&#125;;</span><br><span class="line">Image * Image::_prototypes[];</span><br><span class="line"><span class="keyword">int</span> Image::_nextSlot;</span><br><span class="line"><span class="function">Image * <span class="title">Image::findAndClone</span><span class="params">(ImageType type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _nextSlot; i++)</span><br><span class="line">        <span class="comment">//保证副本格式正确</span></span><br><span class="line">        <span class="keyword">if</span> (_prototypes[i]-&gt;<span class="built_in">returnType</span>() == type)</span><br><span class="line">            <span class="keyword">return</span> _prototypes[i]-&gt;<span class="built_in">clone</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LandSatImage</span> :</span><span class="keyword">public</span> Image</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//返回当前文件格式</span></span><br><span class="line">    <span class="function">ImageType <span class="title">returnType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LSAT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;LandSatImage::draw&quot;</span> &lt;&lt; _id &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建对象</span></span><br><span class="line">    <span class="function">Image * <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">LandSatImage</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">LandSatImage</span>(<span class="keyword">int</span> dummy) &#123;</span><br><span class="line">        _id = _count++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> LandSatImage _landSatImage;</span><br><span class="line">    <span class="built_in">LandSatImage</span>() &#123;</span><br><span class="line">        <span class="built_in">addPrototype</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> _id;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> _count;</span><br><span class="line">&#125;;</span><br><span class="line">LandSatImage LandSatImage::_landSatImage;</span><br><span class="line"><span class="keyword">int</span> LandSatImage::_count = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>以上就是个人对两种模式一点理解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Composite模式与Prototype模式&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#Composite模式与Prototype模式&quot;&gt;¶&lt;/a&gt;Composite模式与Prototype模式&lt;/h2&gt;
&lt;p&gt;这两种模式都是基于 Del</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++学习" scheme="http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Conversion function 转换函数</title>
    <link href="http://example.com/2021/03/26/C++cvfunc/"/>
    <id>http://example.com/2021/03/26/C++cvfunc/</id>
    <published>2021-03-26T08:37:57.084Z</published>
    <updated>2021-03-26T08:42:47.288Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Conversion-function-转换函数"><a class="header-anchor" href="#Conversion-function-转换函数">¶</a>Conversion function 转换函数</h2><p>Conversion function个人理解为是一个跟重载配合使用的重要结构，我们经常会对一些对象进行类型转换，比如把一个Double类型转为Int类型，或是float类型转Double类型，那么当我们构建自己的类的时候，我们希望当它与某种类型进行相加相减之类的操作时，能够自动将自己转换为对应的类型，亦是将另外一种类型转换成跟自己相同的类型，然后进行你设定好的操作。</p><hr><p>一般来说，设定这种转化函数，必须是符合逻辑的，不能随意改变，否则会对程序整体造成不好的影响。</p><p>就拿分数类来进行解释。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Fraction</span>(<span class="keyword">int</span> num,<span class="keyword">int</span> den = <span class="number">1</span>):<span class="built_in">m_numerator</span>(num),<span class="built_in">m_denominator</span>(den)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>)m_numerator / m_denominator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_numerator; <span class="comment">// 分子</span></span><br><span class="line">    <span class="keyword">int</span> m_denominator; <span class="comment">//分母</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>比如上面的代码，我们分数类有两个属性，一个分子，一个分母，且都是int类型，那么假如，我们想把这个分数类的对象与某个整数，或者是浮点数相加，那么该怎么做呢，比如下面这个操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">4</span> + f;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>很明显，我们想要得到的结果是 3/5 + 4的结果，可是 4 是一个整形，而f是你自己构建的类的对象，两种完全不相同的东西，如何相加呢。</p><p>可以再回到我们最上面那一段代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (<span class="keyword">double</span>)m_numerator / m_denominator;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><hr><p>可能之前对重载有些许过了解的人，会对这段代码产生疑惑，一般是重载一个运算符，那么operator double() 是什么意思呢，其实很简单，<span style="background-color: #ffff00;">意思就是，当对象与其他类型的变量进行运算时，编译器会先找你的类里面，有没有相关的设定，可以让你的对象变为一个类型并且能够符合当前的状况，比如运行到 double d = 4 + f;这里，编译器就开始找你的Fraction类里有什么可以使用的类型，operator double()就是表示，我这个类的对象，可以作为一个double类型使用</span>，并且作为double类型使用时，应该变成一个什么样的double值，很明显，一个分数如何变成double值，当然是分子除以分母。</p><hr><p>好了，那么新的问题又来了，万一它其中有多个重载类型呢，那将会发生什么。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Fraction</span>(<span class="keyword">int</span> num,<span class="keyword">int</span> den = <span class="number">1</span>):<span class="built_in">m_numerator</span>(num),<span class="built_in">m_denominator</span>(den)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>)m_numerator / m_denominator;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)m_numerator / m_denominator;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_numerator; <span class="comment">// 分子</span></span><br><span class="line">    <span class="keyword">int</span> m_denominator; <span class="comment">//分母</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>看到这段代码，我们发现，又多了一个operator int()，最开始说了，C++能处理的，都会自己处理，因为遇到的都是<span style="background-color: #ffff00;">它觉得是这样，或者只能是这样的状况，</span>那么当前这种情况下， 它再次遇到 double d = 4 + f;时，它找你的类中相应的转换函数，发现既可转换成 double，也可以转换成int,而且这两个都能与4相加，C++并不知道你到底想要f以什么样的类型面对这个4，所以就会报错。</p><hr><p>遇到这种状况很简单，要么你告诉编译器你想做什么，要么就把可能性排掉只剩下一种（逻辑正确性就体现在这，如果逻辑思路正确，一般是不会分出很多种情况）。</p><p>我们当然可以告诉编译器我们想做什么，只需要：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">4</span> + (<span class="keyword">int</span>)f;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">4</span> + (<span class="keyword">double</span>)f;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样编译器就知道你想要f以什么样的姿势面对这个整形变量了。</p><p>我们也能得到想要的值。</p><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210116205040999-296608350.png" alt="" loading="lazy" /></p><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210116205018203-1003251894.png" alt="" loading="lazy" /></p><hr><p>那么Fraction类对象能转化为其他的类型，那么是否能将这个"4"转换为Fraction类型呢，答案是可以的.</p><p>non-explicit-one-argument ctor</p><p>看下面这一段代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Fraction</span>(<span class="keyword">int</span> num,<span class="keyword">int</span> den = <span class="number">1</span>):<span class="built_in">m_numerator</span>(num),<span class="built_in">m_denominator</span>(den)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    Fraction <span class="keyword">operator</span>+ (<span class="keyword">const</span> Fraction&amp; f) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Fraction</span>(...);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_numerator; <span class="comment">// 分子</span></span><br><span class="line">    <span class="keyword">int</span> m_denominator; <span class="comment">//分母</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>此时再遇到&nbsp;</p><div class="cnblogs_code"><pre>Fraction f(<span style="color: #800080;">3</span>,<span style="color: #800080;">5</span><span style="color: #000000;">);Fraction d2 </span>= f + <span style="color: #800080;">4</span>;</pre></div><p>会如何，我们想得到一个Fraction类的对象，并且得到相应的值，是f + 4,此时应该怎么做，很明显，我们应该把4变成Fraction类，理所当然4就是 4/1，所以在 operator+ 中，我们直接调用构造函数，创建并返回一个分子为4，分母为1的Fraction类对象，因为Fraction(int num,int den = 1)可以看出，构造函数分母初始化为1,传值为4会赋值给num，所以得到4/1,具体相加的操作可以继续在重载函数中实现，这里就不具体操作了。</p><hr><p>刚刚可以看到上面有个non-explicit-one-argument ctor ，这是什么意思呢，其实就是构造函数是非explicit类型，explicit是用来干什么的，之前说了，编译器觉得你想要干什么，会帮你去做，不加explicit就是让编译器能干就干，如果加上explicit就是让编译器不要去揣测，放这别去碰这个构造函数。</p><p>由于我们之前没有加explicit,所以当你把4变成一个Fraction类对象时，编译器看到分母den = 1 有初始值，所以会把4当做没有初始值的num,并调用构造函数。</p><p>而如果我们加上explicit,编译器就不会做这个动作，并且也我们也就无法实现上面那个操作了。</p><hr><p>这里可以用两个例子来说明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Fraction</span>(<span class="keyword">int</span> num,<span class="keyword">int</span> den = <span class="number">1</span>):<span class="built_in">m_numerator</span>(num),<span class="built_in">m_denominator</span>(den)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>)m_numerator / m_denominator;</span><br><span class="line">    &#125;</span><br><span class="line">    Fraction <span class="keyword">operator</span>+ (<span class="keyword">const</span> Fraction&amp; f) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Fraction</span>(...);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_numerator; <span class="comment">// 分子</span></span><br><span class="line">    <span class="keyword">int</span> m_denominator; <span class="comment">//分母</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>比如说这串代码，当它遇到&nbsp;</p><div class="cnblogs_code"><pre>Fraction f(<span style="color: #800080;">3</span>,<span style="color: #800080;">5</span><span style="color: #000000;">);Fraction d2 </span>= f + <span style="color: #800080;">4</span>;</pre></div><p>它也是无法执行的，因为编译器不知道你是要将4转为Fraction类，还是要将f转为double型，编译器就会报错：</p><div class="cnblogs_code"><pre>Error:ambiguous</pre></div><p>而如果你加上 explicit ，也就是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Fraction</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> den = <span class="number">1</span>)</span>:m_numerator(num),m_denominator(den)&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>)m_numerator / m_denominator;</span><br><span class="line">    &#125;</span><br><span class="line">    Fraction <span class="keyword">operator</span>+ (<span class="keyword">const</span> Fraction&amp; f) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Fraction</span>(...);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_numerator; <span class="comment">// 分子</span></span><br><span class="line">    <span class="keyword">int</span> m_denominator; <span class="comment">//分母</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时，编译器就不会把 4 变为 4/1 了，因为编译器不会去揣测你的意思了，它不会去调用这个构造函数去把4变成4/1，然后由于我们要得到的d2 是 Fraction类型的，f变为double类型与4相加，会出现什么情况，</p><p>想象一样 Fraction d2 = 4.6 ;&nbsp; 这样能行吗，肯定不行，所以我们会看到这种报错：</p><div class="cnblogs_code"><pre>Error:conversion <span style="color: #0000ff;">from</span> <span style="color: #800000;">"</span><span style="color: #800000;">double</span><span style="color: #800000;">"</span> to <span style="color: #800000;">"</span><span style="color: #800000;">Fraction</span><span style="color: #800000;">"</span> requested</pre></div><hr><p>以上就是对Conversion function转换函数的一点粗略理解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Conversion-function-转换函数&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#Conversion-function-转换函数&quot;&gt;¶&lt;/a&gt;Conversion function 转换函数&lt;/h2&gt;
&lt;p&gt;Conversion</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++学习" scheme="http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>C++仿函数与仿指针</title>
    <link href="http://example.com/2021/03/26/C++pointerfunc/"/>
    <id>http://example.com/2021/03/26/C++pointerfunc/</id>
    <published>2021-03-26T08:31:45.077Z</published>
    <updated>2021-03-26T08:36:59.750Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-仿函数与仿指针"><a class="header-anchor" href="#C-仿函数与仿指针">¶</a>C++仿函数与仿指针</h2><p>首先说明一下仿指针与仿函数是什么，指针我们知道是一个地址，我们可以利用指针来访问它所指向的value，仿指针就是用一个类去实现指针的作用，那么我们为什么要特地写一个类去实现指针呢，因为在我们开发过程中，我们希望指针可以有更多功能，而不仅仅是指向一个地址，那么我们就可以通过一个类去实现指针的功能的前提下，给它加上更多的功能，来满足我们的需求，比如说我们每使用一次指针，都要去释放掉这个指针，如果忘记释放，就会造成内存泄露，但我们无法使指针自己释放，但是如果是指针类，我们就可以在析构函数中加上delete语句，那么以后使用这个指针，就再也不用管它的释放问题了，C++特性中的智能指针其实就是这种原理，仿函数也是类似道理。</p><hr><p><span style="font-size: 14pt;">_ pointer-like classes</span></p><p>简单用代码实现一个智能指针，其实就是老版本的shared_ptr指针，可以明白其中的运作原理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shared_ptrc</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *px;</span><br><span class="line">    &#125; </span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shared_ptrc</span>(T* p) : <span class="built_in">px</span>(p)&#123;&#125;</span><br><span class="line">    ~<span class="built_in">shared_ptrc</span>() &#123; <span class="keyword">delete</span> px; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T*      px;</span><br><span class="line">    <span class="keyword">long</span>* pn;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Foo::method&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">shared_ptrc&lt;Foo&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> Foo)</span></span>;</span><br><span class="line">    <span class="function">Foo <span class="title">f</span><span class="params">(*sp)</span></span>;</span><br><span class="line"></span><br><span class="line">    sp-&gt;<span class="built_in">method</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先从它的重载说起， 可以看到</p><div class="cnblogs_code"><pre>    T&amp; <span style="color: #0000ff;">operator</span>*() <span style="color: #0000ff;">const</span><span style="color: #000000;">    {        </span><span style="color: #0000ff;">return</span> *<span style="color: #000000;">px;    } </span></pre></div><p>重载了*号，并且无参数，这样就符合了指针的语法，我们平常建立一个指针比如int * p;&nbsp; *p代表就是它所指的value,再看这里，返回 *px,而px又是T类的指针(T * px),所以这里就是返回一个value，并且函数开头是T&amp;,</p><p>之前说了返回value的reference比直接返回value普遍要快很多，所以这里返回了一个reference。</p><p>我们再看</p><div class="cnblogs_code"><pre> T* <span style="color: #0000ff;">operator</span>-&gt;() <span style="color: #0000ff;">const</span><span style="color: #000000;">    {        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> px;    }</span></pre></div><p>当我们使用"-&gt;"时，是不是一般都是调用指针所指内容的方法或者属性，所以我们必须要返回指针类型，所以这里是 T* operator-&gt;() ,（如果这里不明白可以看之前说的引用与指针的区别）</p><p>所以现在来看，我们是不是就可以把shared_ptrc当作一个指针类型来使用了</p><div class="cnblogs_code"><pre> shared_ptrc&lt;Foo&gt; sp(<span style="color: #0000ff;">new</span> Foo);</pre></div><p>这样就是导入Foo模板，并且new一个Foo类对象，让shared_ptrc类中的px指针指向它，然后当我们使用完这个指针后，程序结束后，它会调用析构函数自动销毁，无需手动释放，这就是仿指针的基本用法。</p><p>迭代器其实也是一种仿指针，平常使用迭代器我们都有接触过，比如创建一个vector数组的迭代器，vector&lt;int&gt;::iterator it;我们经常会使用这种语法 it++,++it,使迭代器指针指向数组中的下一个内容，这其实就是在指针类中重载了++符号来实现的。</p><hr><p>为了更加了解仿指针，我们可以看一看C++的智能指针，这样也能使我们对使用指针的风险更加了解。</p><p>有4种智能指针：auto_ptr(C++11已弃用), unique_ptr,shared_ptr, weak_ptr&nbsp;</p><p>首先看看智能指针为我们解决的问题，其实跟上面所说的基本一样。</p><p>当我们使用普通指针时：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(string &amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    string * s = <span class="keyword">new</span> <span class="built_in">string</span>(str);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">error</span>())</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">exception</span>();</span><br><span class="line">    str = *s; </span><br><span class="line">    <span class="keyword">delete</span> s;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>当程序出错，抛出异常，可以很明显看到发生了一个严重的问题，s指针未被释放，程序就中止了，导致内存泄露。</p><p>而我们如果使用智能指针auto_ptr</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(string &amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">auto_ptr&lt;string&gt; <span class="title">s</span><span class="params">(<span class="keyword">new</span> string(str))</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">error</span>())</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">exception</span>();</span><br><span class="line">    str = *s; </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>程序抛出异常，auto_ptr会调用内部析构函数，释放掉指针，这样就避免了内存泄漏。</p><p>然后说一下为什么auto_ptr会被抛弃，auto_ptr的工作模式<span style="background-color: #ffff00;">是拥有所有权。对于特定的对象，只能有一个智能指针可拥有，这样只有拥有对象的智能指针的析构函数会删除该对象。赋值操作会转让所有权。</span></p><p>可以看下面这一串代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  auto_ptr&lt;string&gt; test[<span class="number">3</span>] =</span><br><span class="line"> &#123;</span><br><span class="line">  auto_ptr&lt;string&gt; (<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;helloworld1&quot;</span>)),</span><br><span class="line">  auto_ptr&lt;string&gt; (<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;helloworld2&quot;</span>)),</span><br><span class="line">  auto_ptr&lt;string&gt; (<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;helloworld3&quot;</span>)),</span><br><span class="line"> &#125;;</span><br><span class="line"> auto_ptr&lt;string&gt; p;</span><br><span class="line"> p = test[<span class="number">2</span>]; <span class="comment">// test[2]所有权被p拿走，此时test[2]为一个空指针。</span></span><br><span class="line"></span><br><span class="line"> cout&lt;&lt;test[<span class="number">2</span>]&lt;&lt;endl; <span class="comment">//运行时报错</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出auto_ptr存在内存泄漏的潜在风险，所以不再使用auto_ptr，unique_ptr也是所有权模式，但是如果将上面auto_ptr换成unique_ptr的话，不会在运行程序时报错，而是会在编译时报错，这样也可以避免内存泄漏的潜在风险。</p><hr><p>shared_ptr与weak_ptr则是另外一种模式，这里就不详细说明了，以后专门再用一篇博客描述4种智能指针。</p><hr><p><span style="font-size: 14pt;">_ function-like classes</span></p><p>仿函数也是用一个模板类去实现的，实现原理与仿指针差不多，由于目前不经常使用，了解不是很深，就先把代码语法问题解决了，以后再补充说明仿函数的使用环境与时机。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">identity</span>&#123;</span></span><br><span class="line">    <span class="keyword">const</span> T&amp;</span><br><span class="line">    <span class="built_in"><span class="keyword">operator</span></span>() (<span class="keyword">const</span> T&amp; x) <span class="keyword">const</span> &#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">select1st</span>   &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> Pair::first_type&amp;</span><br><span class="line">    <span class="built_in"><span class="keyword">operator</span></span>() (<span class="keyword">const</span> Pair&amp; x) <span class="keyword">const</span></span><br><span class="line">    &#123; <span class="keyword">return</span> x.first;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">select2nd</span>  &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> Pair::second_type&amp;</span><br><span class="line">    <span class="built_in"><span class="keyword">operator</span></span>() (<span class="keyword">const</span> Pair&amp; x) <span class="keyword">const</span></span><br><span class="line">    &#123; <span class="keyword">return</span> x.second;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pair</span>&#123;</span></span><br><span class="line">    T1 first;</span><br><span class="line">    T2 second;</span><br><span class="line">    <span class="built_in">pair</span>() : <span class="built_in">first</span>(<span class="built_in">T1</span>()),<span class="built_in">second</span>(<span class="built_in">T2</span>())&#123;&#125;</span><br><span class="line">    <span class="built_in">pair</span>(<span class="keyword">const</span> T1&amp; a, <span class="keyword">const</span> T2&amp; b)</span><br><span class="line">        : <span class="built_in">first</span>(a),<span class="built_in">second</span>(b) &#123;&#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到select1st与select2nd可以当作函数来使用，分别返回pair的两个value。</p><p>&nbsp;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-仿函数与仿指针&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#C-仿函数与仿指针&quot;&gt;¶&lt;/a&gt;C++仿函数与仿指针&lt;/h2&gt;
&lt;p&gt;首先说明一下仿指针与仿函数是什么，指针我们知道是一个地址，我们可以利用指针来访问它所指向的value，仿指针</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++学习" scheme="http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>C++虚成员函数与动态联编</title>
    <link href="http://example.com/2021/03/26/C++vir1/"/>
    <id>http://example.com/2021/03/26/C++vir1/</id>
    <published>2021-03-26T08:25:14.590Z</published>
    <updated>2021-03-26T08:37:04.449Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-虚成员函数与动态联编"><a class="header-anchor" href="#C-虚成员函数与动态联编">¶</a>C++虚成员函数与动态联编</h2><p>本篇博客会说明一下虚函数与动态联编的联系，以及虚指针和虚函数表的基本概念。首先了解何为动态联编，何为静态联编。</p><p>当程序调用函数时，编译器负责告诉你将使用哪个可执行代码块，将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编。</p><p>在C语言中，每个函数名都对应一个不同的函数，所以用谁是谁，一对一，在编译过程就能完成联编，很明显的静态联编。而在C++中，由于函数重载的缘故，就不能简单的一对一去联编了，编译器必须查看函数名以及函数参数才能确定使用哪个函数(在C++中，编译器看到的并不是我们所定义的函数名，我们所定义的每个函数，都有一个函数签名，就算我们函数名相同，但我们参数不同，类型不同，甚至是const与non-const的关系，都会导致函数签名不相同)，不过，这种程度在C/C++编译器中也能够在编译过程完成联编，这种在编译过程完成联编的就叫做静态联编。但C++中有一个东西使得编译器很难在编译阶段确定你要使用哪一个函数，那就是虚函数，因为编译器不知道用户将选择哪种类型的对象，所以，编译器必须生成能够在程序运行时选择正确的虚函数的代码，这种称为动态联编。</p><hr><p>接下来观察虚函数与动态联编的联系：</p><p>假设我们有基类Baseclass,与子类Derivedclass，基类中有execf()方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Deriveclass dc;</span><br><span class="line">Baseclass * bc;</span><br><span class="line">bc = &amp;dc;</span><br><span class="line">bc-&gt;<span class="built_in">execf</span>();</span><br></pre></td></tr></table></figure><p>如果基类中没有将execf()声明为虚方法，则bc-&gt;execf()将会根据指针类型(Baseclass*)调用Baseclass::execf()。指针类型在编译时已知，因此编译器在编译时，将execf()关联到Baseclass::execf()，所以，编译器对非虚方法使用静态联编。</p><p>但如果在基类中将execf()声明为虚方法，则dc-&gt;execf()根据对象类型(Deriveclass)调用Deriveclass::execf()，在这个例子中，对象类型为BrassPlus,但通常只有在运行程序时才能确定对象类型。所以编译器生成的代码将在程序执行时，根据对象类型将execf()关联到Baseclass::execf()或者Deriveclass::execf()，所以编译器对虚方法使用动态联编。</p><hr><p>接下来说明一下虚指针与虚表（也称虚函数表）。</p><p>当我们定义一个类时，并创建一个对象，编译器会给每个对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针，这个指针就是虚指针，这个数组就是虚函数表。虚函数表中存储了为类对象进行声明的虚函数的地址，例如，基类对象包含一个指针，该指针指向基类中所有虚函数的地址表，派生类对象将包含一个指向独立虚表的指针，如果派生类提供了虚函数的新定义，该虚函数表将保存这个重定义虚函数的地址；如果派生类没有重新定义基类虚函数，派生类的虚表将保存函数原始的地址，也就是跟基类中这个虚函数的地址相同（无则不变，有则更新），如果派生类定义了新的虚函数（基类没有的），则该虚函数的地址也将被添加到虚表中。</p><hr><p>通过下面的代码和图片就能清晰理解其中的关系了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __TEST__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __TEST__</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data1, m_data2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span><span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data1, m_data4;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><hr><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210118144925838-1054333921.png" alt="" loading="lazy" /></p><hr><p>　　可以看到在B类对象中重新定义了A类中的虚函数vfunc1()，所以在B的虚表中vfunc2的地址从0x401ED0更新为0x401F80,而因为没有重新定义vfunc2(),所以地址仍然是0x401F10，C类对象也是如此。</p><p>　　调用虚函数时，程序查看存储在对象中的vtbl地址，然后转向相应的函数地址表，如果使用类声明中定义的第一个虚函数，则程序将使用数组中的第一个函数地址，并执行具有该地址的函数，如果使用类声明中的第三个函数，程序将使用地址为数组中第三个元素的函数。</p><p>　　在使用虚函数时，在内存和执行速度方面有一定的成本：</p><ul><li>每个对象都将增大，增大量为存储地址的空间</li><li>对于每个类，编译器都创建一个虚函数地址表（数组）</li><li>对于每个函数调用，都需要执行一项额外的操作，即到表中查找地址</li></ul><p>虽然非虚函数的效率比虚函数稍高，但不具备动态联编功能。</p><hr><p>对于虚析构函数的一些注意事项：</p><p>1.构造函数不能是虚函数，创建派生类对象时，将调用派生类的构造函数，而不是基类的构造函数，然后，派生类的构造函数将使用基类的一个构造函数，这种顺序不同于继承机制，因此，派生类不继承基类的构造函数。</p><p>2.析构函数应当是虚函数，除非类不用做基类，比如看下面代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A::ctor()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A::dtor()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;B::ctor()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;B::dtor()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A * p = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如 基类析构函数不是虚函数，当使用A类指针指向一个B类对象时，释放内存时，我们会发现以下结果：</p><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210118172345729-1793346312.png" alt="" loading="lazy" /></p><hr><p>&nbsp;B类的析构函数没有被调用，这样会造成严重的影响，因为delete p只删除了A类所拥有的内存空间，并没有释放掉B类对应的内存空间，并且也再也无法访问这片空间，这样就造成了内存泄漏。</p><p>那么我们将析构函数设为virtual呢。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A::ctor()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A::dtor()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;B::ctor()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;B::dtor()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A * p = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现我们成功调用了B类的析构函数。</p><hr><p>有关虚函数的注意事项：</p><ul><li>如果使用指向对象的引用或指针来调用虚方法，程序将使用为对象类型定义的方法，而不使用为引用或指针类型定义的方法，这称为动态联编，这种行为非常重要，因为这样基类指针或引用可以指向派生类对象。</li><li>如果定义的类将被用作基类，则应将那些要在派生类中重新定义的类方法声明为虚方法。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-虚成员函数与动态联编&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#C-虚成员函数与动态联编&quot;&gt;¶&lt;/a&gt;C++虚成员函数与动态联编&lt;/h2&gt;
&lt;p&gt;本篇博客会说明一下虚函数与动态联编的联系，以及虚指针和虚函数表的基本概念。首先了解何为动态</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++学习" scheme="http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>C++ volatlie变量</title>
    <link href="http://example.com/2021/03/26/C++volatlie/"/>
    <id>http://example.com/2021/03/26/C++volatlie/</id>
    <published>2021-03-26T08:19:13.233Z</published>
    <updated>2021-03-26T08:24:31.885Z</updated>
    
    <content type="html"><![CDATA[<h3><span style="background-color: #888888;">学习专用，转载自github:<a href="https://github.com/Light-City/CPlusPlusThings/tree/master/basic_content/volatile"><span style="background-color: #888888;">https://github.com/Light-City/CPlusPlusThings/tree/master/basic_content/volatile</span></a></span></h3><h2>1.volatile</h2><p>被&nbsp;<code>volatile</code>&nbsp;修饰的变量，在对其进行读写操作时，会引发一些可观测的副作用。而这些可观测的副作用，是由程序之外的因素决定的。</p><h2><a id="user-content-2volatile应用" class="anchor" href="https://github.com/Light-City/CPlusPlusThings/tree/master/basic_content/volatile#2volatile%E5%BA%94%E7%94%A8"></a>2.volatile应用</h2><p>（1）并行设备的硬件寄存器（如状态寄存器）。 假设要对一个设备进行初始化，此设备的某一个寄存器为0xff800000。</p><div class="highlight highlight-source-c++"><pre><span class="pl-k">int  *output = (<span class="pl-k">unsigned  <span class="pl-k">int *)<span class="pl-c1">0xff800000; <span class="pl-c"><span class="pl-c">//定义一个IO端口；  <span class="pl-k">int   <span class="pl-en">init(<span class="pl-k">void)  {      <span class="pl-k">int i;      <span class="pl-k">for(i=<span class="pl-c1">0;i&lt; <span class="pl-c1">10;i++)    {      *output = i;      }  }</span></span></span></span></span></span></span></span></span></span></span></span></span></pre></div><p>经过编译器优化后，编译器认为前面循环半天都是废话，对最后的结果毫无影响，因为最终只是将output这个指针赋值为 9，所以编译器最后给你编译编译的代码结果相当于：</p><div class="highlight highlight-source-c++"><pre><span class="pl-k">int  <span class="pl-en">init(<span class="pl-k">void)  {      *output = <span class="pl-c1">9;  }</span></span></span></span></pre></div><p>如果你对此外部设备进行初始化的过程是必须是像上面代码一样顺序的对其赋值，显然优化过程并不能达到目的。反之如果你不是对此端口反复写操作，而是反复读操作，其结果是一样的，编译器在优化后，也许你的代码对此地址的读操作只做了一次。然而从代码角度看是没有任何问题的。这时候就该使用volatile通知编译器这个变量是一个不稳定的，在遇到此变量时候不要优化。</p><p>（2）一个中断服务子程序中访问到的变量；</p><div class="highlight highlight-source-c++"><pre><span class="pl-k">static <span class="pl-k">int i=<span class="pl-c1">0;<p><span class="pl-k">int <span class="pl-en">main()<br>{<br><span class="pl-k">while(<span class="pl-c1">1)<br>{<br><span class="pl-k">if(i) <span class="pl-c1">dosomething();<br>}<br>}</p><p><span class="pl-c"><span class="pl-c">/* Interrupt service routine <span class="pl-c">*/<br><span class="pl-k">void <span class="pl-en">IRS()<br>{<br>i=<span class="pl-c1">1;<br>}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre></p></div><p>上面示例程序的本意是产生中断时，由中断服务子程序IRS响应中断，变更程序变量i，使在main函数中调用dosomething函数，但是，由于编译器判断在main函数里面没有修改过i，因此可能只执行一次对从i到某寄存器的读操作，然后每次if判断都只使用这个寄存器里面的&ldquo;i副本&rdquo;，导致dosomething永远不会被调用。如果将变量i加上volatile修饰，则编译器保证对变量i的读写操作都不会被优化，从而保证了变量i被外部程序更改后能及时在原程序中得到感知。</p><p>（3）多线程应用中被多个任务共享的变量。 当多个线程共享某一个变量时，该变量的值会被某一个线程更改，应该用 volatile 声明。作用是防止编译器优化把变量从内存装入CPU寄存器中，当一个线程更改变量后，未及时同步到其它线程中导致程序出错。volatile的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值。示例如下：</p><div class="highlight highlight-source-c++"><pre><span class="pl-k">volatile  <span class="pl-k">bool bStop=<span class="pl-c1">false;  <span class="pl-c"><span class="pl-c">//bStop 为共享全局变量  <span class="pl-c"><span class="pl-c">//第一个线程<span class="pl-k">void <span class="pl-en">threadFunc1(){    ...    <span class="pl-k">while(!bStop){...}}<span class="pl-c"><span class="pl-c">//第二个线程终止上面的线程循环<span class="pl-k">void <span class="pl-en">threadFunc2(){    ...    bStop = <span class="pl-c1">true;}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre></div><p>要想通过第二个线程终止第一个线程循环，如果bStop不使用volatile定义，那么这个循环将是一个死循环，因为bStop已经读取到了寄存器中，寄存器中bStop的值永远不会变成FALSE，加上volatile，程序在执行时，每次均从内存中读出bStop的值，就不会死循环了。</p><p>是否了解volatile的应用场景是区分C/C++程序员和嵌入式开发程序员的有效办法，搞嵌入式的家伙们经常同硬件、中断、RTOS等等打交道，这些都要求用到volatile变量，不懂得volatile将会带来程序设计的灾难。</p><h2><a id="user-content-3volatile常见问题" class="anchor" href="https://github.com/Light-City/CPlusPlusThings/tree/master/basic_content/volatile#3volatile%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"></a>3.volatile常见问题</h2><p>下面的问题可以看一下面试者是不是直正了解volatile。 （1）一个参数既可以是const还可以是volatile吗？为什么？ 可以。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。</p><p>（2）一个指针可以是volatile吗？为什么？ 可以。尽管这并不常见。一个例子是当一个中断服务子程序修该一个指向一个buffer的指针时。</p><p>（3）下面的函数有什么错误？</p><div class="highlight highlight-source-c++"><pre><span class="pl-k">int <span class="pl-en">square(<span class="pl-k">volatile <span class="pl-k">int *ptr) { <span class="pl-k">return *ptr * *ptr; } </span></span></span></span></span></pre></div><p>这段代码有点变态，其目的是用来返回指针ptr指向值的平方，但是，由于ptr指向一个volatile型参数，编译器将产生类似下面的代码：</p><div class="highlight highlight-source-c++"><pre><span class="pl-k">int <span class="pl-en">square(<span class="pl-k">volatile <span class="pl-k">int *ptr) { <span class="pl-k">int a,b; a = *ptr; b = *ptr; <span class="pl-k">return a * b; } </span></span></span></span></span></span></pre></div><p>由于*ptr的值可能被意想不到地改变，因此a和b可能是不同的。结果，这段代码可能返回的不是你所期望的平方值！正确的代码如下：</p><div class="highlight highlight-source-c++"><pre><span class="pl-k">long <span class="pl-en">square(<span class="pl-k">volatile <span class="pl-k">int *ptr) { <span class="pl-k">int a=*ptr; <span class="pl-k">return a * a; } </span></span></span></span></span></span></pre></div><h2><a id="user-content-4volatile使用" class="anchor" href="https://github.com/Light-City/CPlusPlusThings/tree/master/basic_content/volatile#4volatile%E4%BD%BF%E7%94%A8"></a>4.volatile使用</h2><ul><li><p>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。</p></li><li><p>volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</p></li><li><p>const 可以是 volatile （如只读的状态寄存器）</p></li><li><p>指针可以是 volatile</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3&gt;&lt;span style=&quot;background-color: #888888;&quot;&gt;学习专用，转载自github:&lt;a href=&quot;https://github.com/Light-City/CPlusPlusThings/tree/master/basic_content</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++学习" scheme="http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 1603.设计停车系统</title>
    <link href="http://example.com/2021/03/26/leetcode1603/"/>
    <id>http://example.com/2021/03/26/leetcode1603/</id>
    <published>2021-03-26T08:15:11.619Z</published>
    <updated>2021-03-26T08:16:22.752Z</updated>
    
    <content type="html"><![CDATA[<h4 class="css-10c1h40-Title eugt34i1" data-cypress="QuestionTitle"><a href="https://leetcode-cn.com/problems/design-parking-system/">1603. 设计停车系统</a></h4><div class="content__1Y2H"><div class="notranslate"><p>请你给一个停车场设计一个停车系统。停车场总共有三种不同大小的车位：大，中和小，每种尺寸分别有固定数目的车位。</p><p>请你实现&nbsp;<code>ParkingSystem</code>&nbsp;类：</p><ul><li><code>ParkingSystem(int big, int medium, int small)</code>&nbsp;初始化&nbsp;<code>ParkingSystem</code>&nbsp;类，三个参数分别对应每种停车位的数目。</li><li><code>bool addCar(int carType)</code>&nbsp;检查是否有&nbsp;<code>carType</code>&nbsp;对应的停车位。&nbsp;<code>carType</code>&nbsp;有三种类型：大，中，小，分别用数字&nbsp;<code>1</code>，&nbsp;<code>2</code>&nbsp;和&nbsp;<code>3</code>&nbsp;表示。一辆车只能停在&nbsp;&nbsp;<code>carType</code>&nbsp;对应尺寸的停车位中。如果没有空车位，请返回&nbsp;<code>false</code>&nbsp;，否则将该车停入车位并返回&nbsp;<code>true</code>&nbsp;。</li></ul><p>示例 1：</p>输入：<div class="cnblogs_code"><pre>[<span style="color: #800000;">"</span><span style="color: #800000;">ParkingSystem</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">addCar</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">addCar</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">addCar</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">addCar</span><span style="color: #800000;">"</span><span style="color: #000000;">][[</span><span style="color: #800080;">1</span>, <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span>], [<span style="color: #800080;">1</span>], [<span style="color: #800080;">2</span>], [<span style="color: #800080;">3</span>], [<span style="color: #800080;">1</span>]]</pre></div>输出：<div class="cnblogs_code"><pre>[<span style="color: #0000ff;">null</span>, <span style="color: #0000ff;">true</span>, <span style="color: #0000ff;">true</span>, <span style="color: #0000ff;">false</span>, <span style="color: #0000ff;">false</span>]</pre></div>解释：<pre>ParkingSystem parkingSystem = new ParkingSystem(1, 1, 0);parkingSystem.addCar(1); // 返回 true ，因为有 1 个空的大车位parkingSystem.addCar(2); // 返回 true ，因为有 1 个空的中车位parkingSystem.addCar(3); // 返回 false ，因为没有空的小车位parkingSystem.addCar(1); // 返回 false ，因为没有空的大车位，唯一一个大车位已经被占据了</pre><p>提示：</p><ul><li><code>0 &lt;= big, medium, small &lt;= 1000</code></li><li><code>carType</code>&nbsp;取值为&nbsp;<code>1</code>，&nbsp;<code>2</code>&nbsp;或&nbsp;<code>3</code></li><li>最多会调用&nbsp;<code>addCar</code>&nbsp;函数&nbsp;<code>1000</code>&nbsp;次</li></ul><p>简单题，没啥好说的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParkingSystem</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> big;</span><br><span class="line"><span class="keyword">int</span> medium;</span><br><span class="line"><span class="keyword">int</span> small;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ParkingSystem</span>(<span class="keyword">int</span> big, <span class="keyword">int</span> medium, <span class="keyword">int</span> small):<span class="built_in">big</span>(big),<span class="built_in">medium</span>(medium),<span class="built_in">small</span>(small) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">addCar</span><span class="params">(<span class="keyword">int</span> carType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(carType == <span class="number">1</span> &amp;&amp; big &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            big--;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carType == <span class="number">2</span> &amp;&amp; medium &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            medium--;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carType == <span class="number">3</span> &amp;&amp; small &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            small--;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your ParkingSystem object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * ParkingSystem* obj = new ParkingSystem(big, medium, small);</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;addCar(carType);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 class=&quot;css-10c1h40-Title eugt34i1&quot; data-cypress=&quot;QuestionTitle&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/design-parking-system/&quot;&gt;1603. </summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 92.反转链表 II</title>
    <link href="http://example.com/2021/03/26/leetcode92/"/>
    <id>http://example.com/2021/03/26/leetcode92/</id>
    <published>2021-03-26T08:13:06.955Z</published>
    <updated>2021-03-26T08:14:41.740Z</updated>
    
    <content type="html"><![CDATA[<h4 class="css-10c1h40-Title eugt34i1" data-cypress="QuestionTitle"><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h4><div class="content__1Y2H"><div class="notranslate">给你单链表的头节点&nbsp;<code>head</code>&nbsp;和两个整数&nbsp;<code>left</code>&nbsp;和&nbsp;<code>right</code>&nbsp;，其中&nbsp;<code>left &lt;= right</code>&nbsp;。请你反转从位置&nbsp;<code>left</code>&nbsp;到位置&nbsp;<code>right</code>&nbsp;的链表节点，返回&nbsp;反转后的链表&nbsp;。<p>示例 1：</p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg" alt="" /><pre>输入：head = [1,2,3,4,5], left = 2, right = 4输出：[1,4,3,2,5]</pre><p>示例 2：</p><pre>输入：head = [5], left = 1, right = 1输出：[5]</pre><p>提示：</p><ul><li>链表中节点数目为&nbsp;<code>n</code></li><li><code>1 &lt;= n &lt;= 500</code></li><li><code>-500 &lt;= Node.val &lt;= 500</code></li><li><code>1 &lt;= left &lt;= right &lt;= n</code></li></ul><hr><p>直接拿图举例，首先建立一个头结点，找到要反转的一段，记录下1这个结点，和5这个结点，然后切断1-&gt;4 , 2-&gt;5 ，将 4-&gt;3-&gt;2 反转，改变指针方向变为 4&lt;-3&lt;-2，然后利用记录下的结点，将1连接4,2连接5，完成，返回虚拟头结点的下一个结点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode * <span class="title">relist</span><span class="params">(ListNode * head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode * pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode * cur = head;</span><br><span class="line">        ListNode * tmp;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        ListNode * newhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        newhead-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        ListNode * cur = newhead;</span><br><span class="line">        ListNode * end = newhead;</span><br><span class="line">        ListNode * pre = newhead;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; left - <span class="number">1</span> ; i++)</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; right ; i++)</span><br><span class="line">            end = end-&gt;next;</span><br><span class="line"></span><br><span class="line">        ListNode * ls = pre-&gt;next; </span><br><span class="line">        ListNode * re = end-&gt;next;</span><br><span class="line"></span><br><span class="line">        pre-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        end-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        pre-&gt;next = <span class="built_in">relist</span>(ls);</span><br><span class="line">        ls-&gt;next = re;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 class=&quot;css-10c1h40-Title eugt34i1&quot; data-cypress=&quot;QuestionTitle&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-linked-list-ii/&quot;&gt;92. 反</summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 115.不同的子序列</title>
    <link href="http://example.com/2021/03/26/leetcode115/"/>
    <id>http://example.com/2021/03/26/leetcode115/</id>
    <published>2021-03-26T08:08:53.862Z</published>
    <updated>2021-03-26T08:12:44.348Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/distinct-subsequences/">115. 不同的子序列</a></p><div class="content__1Y2H"><div class="notranslate"><p>给定一个字符串&nbsp;<code>s</code>&nbsp;和一个字符串&nbsp;<code>t</code>&nbsp;，计算在&nbsp;<code>s</code>&nbsp;的子序列中&nbsp;<code>t</code>&nbsp;出现的个数。</p><p>字符串的一个&nbsp;子序列&nbsp;是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，<code>"ACE"</code>&nbsp;是&nbsp;<code>"ABCDE"</code>&nbsp;的一个子序列，而&nbsp;<code>"AEC"</code>&nbsp;不是）</p><p>题目数据保证答案符合 32 位带符号整数范围。</p><p>示例&nbsp;1：</p>输入:<div class="cnblogs_code"><pre>s = <span style="color: #800000;">"</span><span style="color: #800000;">rabbbit</span><span style="color: #800000;">"</span>, t = <span style="color: #800000;">"</span><span style="color: #800000;">rabbit</span><span style="color: #800000;">"</span></pre></div><p>输出：</p><div class="cnblogs_code"><pre><span style="color: #800080;">3</span> </pre></div><p>解释：</p><div class="cnblogs_code"><pre>如下图所示, 有 <span style="color: #800080;">3</span> 种可以从 s 中得到 <span style="color: #800000;">"</span><span style="color: #800000;">rabbit</span><span style="color: #800000;">"</span><span style="color: #000000;"> 的方案。(上箭头符号 </span>^<span style="color: #000000;"> 表示选取的字母)rabbbit</span>^^^^ ^^<span style="color: #000000;">rabbbit</span>^^ ^^^^<span style="color: #000000;">rabbbit</span>^^^ ^^^</pre></div><hr><p>示例&nbsp;2：</p><p>输入:</p><div class="cnblogs_code"><pre>s = <span style="color: #800000;">"</span><span style="color: #800000;">babgbag</span><span style="color: #800000;">"</span>, t = <span style="color: #800000;">"</span><span style="color: #800000;">bag</span><span style="color: #800000;">"</span></pre></div>输出:<div class="cnblogs_code"><pre><span style="color: #800080;">5</span> </pre></div><p>解释：</p><div class="cnblogs_code"><pre>如下图所示, 有 <span style="color: #800080;">5</span> 种可以从 s 中得到 <span style="color: #800000;">"</span><span style="color: #800000;">bag</span><span style="color: #800000;">"</span><span style="color: #000000;"> 的方案。 (上箭头符号 </span>^<span style="color: #000000;"> 表示选取的字母)babgbag</span>^^ ^<span style="color: #000000;">babgbag</span>^^    ^<span style="color: #000000;">babgbag</span>^    ^^<span style="color: #000000;">babgbag  </span>^  ^^<span style="color: #000000;">babgbag    </span>^^^</pre></div><p>提示：</p><ul><li><code>0 &lt;= s.length, t.length &lt;= 1000</code></li><li><code>s</code>&nbsp;和&nbsp;<code>t</code>&nbsp;由英文字母组成</li></ul><hr><p>这种题，难度还是困难，递归暴力肯定是第一个排除的，想都不要去想。</p><p>就从这道题开始我的字符串动归的学习之路吧，首先是看到这道题思考，要如何去使用动态规划去保证你能够得到你想要的结果。</p><p>第一件事就是建立dp数组，<span style="background-color: #ffff00;">一定要深刻理解dp数组中每一个元素的含义以及下标的含义。</span>不然永远学不会。</p><p>那么怎么去建立呢，抱歉，我也想不到，不过得到大佬的提示还是知道了要建立一个二维数组，原因是<span style="background-color: #ffff00;"> dp[i][j] 代表了 s字符串 0~i-1 中 包含了多少个 0~j-1 个t</span> ，又是熟悉的边界坑，有人可能会问，为什么dp数组的下标里明明是i,j，却代表的是字符串中i-1和j-1啊之类的，那是因为，dp数组为了把子串为空的情况考虑进去，比如说 s = &ldquo;bba&rdquo; 匹配 t = "b"&nbsp; 首先要考虑的不是 s中的"b" 是否匹配t中的 "b" 而是考虑 s 中的空字符 " " 是否匹配 t中的空字符 " "，然后才是s中的 "b" 是否匹配空字符等等，看到这应该明白了吧，也就是说dp数组扩充了边界，加入了s与t的子串为空的情况，因为s与t中又没有真正的空串,所以判断s,t的时候下标要减一，才能对应上dp[i][j]。</p><hr><p>先把动归的转移方程摆上来，方便下面的例子解释：</p><div class="cnblogs_code"><pre><span style="color: #0000ff;">if</span>(s[i - <span style="color: #800080;">1</span>] == t[j - <span style="color: #800080;">1</span><span style="color: #000000;">])      dp[i][j] </span>= dp[i-<span style="color: #800080;">1</span>][j-<span style="color: #800080;">1</span>] + dp[i-<span style="color: #800080;">1</span><span style="color: #000000;">][j];</span><span style="color: #0000ff;">else</span><span style="color: #000000;">      dp[i][j] </span>= dp[i-<span style="color: #800080;">1</span>][j];</pre></div><hr><p>其实这道题不难，难点是你不知道这个dp数组为什么这样求就是正确答案，不明白转移方程的含义，无法把大问题分成子问题，迭代过程不清晰，所以就是很懵，我们先从这一点开始理解，就是先抛弃那些逻辑关系，我们已经知道dp[i][j]代表了 s字符串 0~i-1 中 包含了多少个 0~j-1 个t&nbsp; 对吧，意思就是dp[i][j] 就是一个解，一个答案，那么我们这样想，假如我们已经知道了"bagg" 里面有多少个"bag" ，是dp[4][3] = 2 ，实质题目是求"baggg"里面有多少个"bag"，此时是不是就相当于往"bagg"后面多加了一个"g"，对吧，那么我们略过t中的"b"与"ba"，直接到判断"bag&rdquo;这里来，此时s[i-1] = "g" ,t[i-1] = "g" , 相同，所以等于dp[i-1][j-1] + dp[i-1][j];为什么是这两个相加呢。想象一下，假设我们加入的是一个&ldquo;？&rdquo;字符，先不管它是什么，现在是不是变成了&ldquo;bagg?&rdquo; ,但是，在之前我们已经得知了&ldquo;bagg&rdquo;里面有多少个"bag"，现在即使多了个字符，之前的答案是不是必须要加进来的，也就是dp[i-1][j],然后现在&ldquo;g&rdquo;进来了，它与"bag"最后一个字符串&ldquo;g&rdquo;相同，也就是说，我们可以拿它与最后一个&ldquo;g&rdquo;相匹配，也可以选择不与&ldquo;g&rdquo;相匹配，所以匹配与不匹配造成了两种结果，就是说"bag"可以用"ba&rdquo;跟这个"g&rdquo;组合成一个&ldquo;bag&rdquo; 它也可以跟另外两个"g&rdquo;组合，意思就是因为进来了这个"g",之前所有的&ldquo;ba&rdquo;又可以和这个"g"组成一个新的"bag",把这个&ldquo;g&rdquo;考虑进来，就得到了dp[i-1][j-1]，区别是j变成了j-1,因为&ldquo;g&rdquo;被用来匹配了，而不用&ldquo;g&rdquo;，就相当于进来了个&ldquo;z&rdquo;,变成了"baggz"，那此时dp[i][j]的结果必然就是跟不加&ldquo;z&rdquo;之前一样的为dp[i-1][j],是一个道理。所以必须要用dp[i-1][j-1]+dp[i-1][j]才是正确答案。</p><hr><p>所以思维方式必须是我们已知dp[i][j]的答案，然后判断下一个字符加进来时，会造成什么样的后果就行了，然后组成一个完整的字符串。</p><p>贴上代码观看：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">int</span> m = t.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">long</span>&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>,vector&lt;<span class="keyword">long</span>&gt;(m+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; i++)dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; i++)dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>])</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + dp[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/distinct-subsequences/&quot;&gt;115. 不同的子序列&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;content__1Y2H&quot;&gt;
&lt;div class=&quot;notranslate</summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
</feed>
