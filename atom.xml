<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-03-28T05:17:31.032Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode 第243场周赛 创新奇智&amp;力扣</title>
    <link href="http://example.com/2021/03/28/lcweek243/"/>
    <id>http://example.com/2021/03/28/lcweek243/</id>
    <published>2021-03-28T04:50:43.042Z</published>
    <updated>2021-03-28T05:17:31.032Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-第243场周赛-创新奇智-力扣"><a class="header-anchor" href="#Leetcode-第243场周赛-创新奇智-力扣">¶</a>Leetcode 第243场周赛 创新奇智&amp;力扣</h2><p>本次差点全AC了，还是差一点火候。</p><h3 id="第一题-字符串中不同整数的数目"><a class="header-anchor" href="#第一题-字符串中不同整数的数目">¶</a>第一题-字符串中不同整数的数目</h3><p>给你一个字符串 word ，该字符串由数字和小写英文字母组成。</p><p>请你用空格替换每个不是数字的字符。例如，“a123bc34d8ef34” 将会变成 &quot; 123  34 8  34&quot; 。注意，剩下的这些整数间至少要用一个空格隔开：“123”、“34”、“8” 和 “34” 。</p><p>返回对 word 完成替换后形成的 不同 整数的数目。</p><p>如果两个整数的 不含前导零 的十进制表示不同，则认为这两个整数也不同。</p><p>示例一：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：word = <span class="string">&quot;a123bc34d8ef34&quot;</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：不同的整数有 <span class="string">&quot;123&quot;</span>、<span class="string">&quot;34&quot;</span> 和 <span class="string">&quot;8&quot;</span> 。注意，<span class="string">&quot;34&quot;</span> 只计数一次。</span><br></pre></td></tr></table></figure><p>示例二</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><span class="line">输入：word = <span class="string">&quot;leet1234code234&quot;</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">示例三  </span><br><span class="line">```cpp</span><br><span class="line">输入：word = <span class="string">&quot;a1b01c001&quot;</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：<span class="string">&quot;1&quot;</span>、<span class="string">&quot;01&quot;</span> 和 <span class="string">&quot;001&quot;</span> 视为同一个整数的十进制表示，因为在比较十进制值时会忽略前导零的存在。</span><br><span class="line">```  </span><br><span class="line">提示：</span><br><span class="line"><span class="number">1</span> &lt;= word.length &lt;= <span class="number">1000</span>  </span><br><span class="line">word 由数字和小写英文字母组成</span><br><span class="line"></span><br><span class="line">----  </span><br><span class="line"></span><br><span class="line">该题只需要考虑两个东西，第一是提取数字，第二是去重。  </span><br><span class="line">利用vector提取数字，set去重</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">class Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">numDifferentIntegers</span>(string word) &#123;</span><br><span class="line"><span class="keyword">int</span> n = word.<span class="built_in">length</span>();</span><br><span class="line">set&lt;string&gt; s;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (word[i] &gt;= <span class="string">&#x27;0&#x27;</span>&amp;&amp;word[i] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;<span class="keyword">char</span>&gt; vc;</span><br><span class="line"><span class="keyword">while</span> (i &lt; n &amp;&amp; (word[i] &gt;= <span class="string">&#x27;0&#x27;</span>&amp;&amp;word[i] &lt;= <span class="string">&#x27;9&#x27;</span>))</span><br><span class="line">&#123;</span><br><span class="line">vc.<span class="built_in">push_back</span>(word[i++]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (vc.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; vc[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">vc.<span class="built_in">erase</span>(vc.<span class="built_in">begin</span>());</span><br><span class="line">&#125;</span><br><span class="line">string tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : vc)</span><br><span class="line">tmp += x;</span><br><span class="line">s.<span class="built_in">insert</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> s.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line">## 第二题-还原排列的最少操作步数  </span><br><span class="line"></span><br><span class="line">给你一个偶数 n​​​​​​ ，已知存在一个长度为 n 的排列 perm ，其中 perm[i] == i​（下标 从 <span class="number">0</span> 开始 计数）。</span><br><span class="line"></span><br><span class="line">一步操作中，你将创建一个新数组 arr ，对于每个 i ：</span><br><span class="line"></span><br><span class="line">如果 i % <span class="number">2</span> == <span class="number">0</span> ，那么 arr[i] = perm[i / <span class="number">2</span>]  </span><br><span class="line">如果 i % <span class="number">2</span> == <span class="number">1</span> ，那么 arr[i] = perm[n / <span class="number">2</span> + (i - <span class="number">1</span>) / <span class="number">2</span>]  </span><br><span class="line">然后将 arr​​ 赋值​​给 perm 。</span><br><span class="line"></span><br><span class="line">要想使 perm 回到排列初始值，至少需要执行多少步操作？返回最小的 非零 操作步数。</span><br><span class="line"></span><br><span class="line">示例一：  </span><br><span class="line">```cpp</span><br><span class="line">输入：n = <span class="number">2</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：最初，perm = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">第 <span class="number">1</span> 步操作后，perm = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">所以，仅需执行 <span class="number">1</span> 步操作</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">示例二:  </span><br><span class="line">```cpp</span><br><span class="line">输入：n = <span class="number">4</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：最初，perm = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">第 <span class="number">1</span> 步操作后，perm = [<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">第 <span class="number">2</span> 步操作后，perm = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">所以，仅需执行 <span class="number">2</span> 步操作</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">示例三:  </span><br><span class="line">```cpp</span><br><span class="line">输入：n = <span class="number">6</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">```  </span><br><span class="line">提示：  </span><br><span class="line"><span class="number">2</span> &lt;= n &lt;= <span class="number">1000</span>  </span><br><span class="line">n​​​​​​ 是一个偶数  </span><br><span class="line"></span><br><span class="line">----  </span><br><span class="line">我们只用考虑arr数组是否对应prem[i] = i 即可，否则则操作步数+<span class="number">1</span>。  </span><br><span class="line">```cpp</span><br><span class="line">class Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">reinitializePermutation</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">prem</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">prem[i] = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (j&lt;n)</span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">0</span>)arr[i] = prem[i/<span class="number">2</span>];</span><br><span class="line"><span class="keyword">else</span> arr[i] = prem[n / <span class="number">2</span> + (i <span class="number">-1</span>)/ <span class="number">2</span> ];</span><br><span class="line">&#125;</span><br><span class="line">prem = arr;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (prem[j] != j)</span><br><span class="line">&#123;</span><br><span class="line">cnt++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (j == n)<span class="keyword">return</span> cnt+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">----</span><br><span class="line">## 第三题-替换字符串中的括号内容  </span><br><span class="line"></span><br><span class="line">给你一个字符串 s ，它包含一些括号对，每个括号中包含一个 非空 的键。</span><br><span class="line"></span><br><span class="line">比方说，字符串 <span class="string">&quot;(name)is(age)yearsold&quot;</span> 中，有 两个 括号对，分别包含键 <span class="string">&quot;name&quot;</span> 和 <span class="string">&quot;age&quot;</span> 。</span><br><span class="line">你知道许多键对应的值，这些关系由二维字符串数组 knowledge 表示，其中 knowledge[i] = [keyi, valuei] ，表示键 keyi 对应的值为 valuei 。</span><br><span class="line"></span><br><span class="line">你需要替换 所有 的括号对。当你替换一个括号对，且它包含的键为 keyi 时，你需要：</span><br><span class="line"></span><br><span class="line">将 keyi 和括号用对应的值 valuei 替换。</span><br><span class="line">如果从 knowledge 中无法得知某个键对应的值，你需要将 keyi 和括号用问号 <span class="string">&quot;?&quot;</span> 替换（不需要引号）。</span><br><span class="line">knowledge 中每个键最多只会出现一次。s 中不会有嵌套的括号。</span><br><span class="line"></span><br><span class="line">请你返回替换 所有 括号对后的结果字符串。</span><br><span class="line">  </span><br><span class="line">示例一：  </span><br><span class="line">```cpp</span><br><span class="line">输入：s = <span class="string">&quot;(name)is(age)yearsold&quot;</span>, knowledge = [[<span class="string">&quot;name&quot;</span>,<span class="string">&quot;bob&quot;</span>],[<span class="string">&quot;age&quot;</span>,<span class="string">&quot;two&quot;</span>]]</span><br><span class="line">输出：<span class="string">&quot;bobistwoyearsold&quot;</span></span><br><span class="line">解释：</span><br><span class="line">键 <span class="string">&quot;name&quot;</span> 对应的值为 <span class="string">&quot;bob&quot;</span> ，所以将 <span class="string">&quot;(name)&quot;</span> 替换为 <span class="string">&quot;bob&quot;</span> 。</span><br><span class="line">键 <span class="string">&quot;age&quot;</span> 对应的值为 <span class="string">&quot;two&quot;</span> ，所以将 <span class="string">&quot;(age)&quot;</span> 替换为 <span class="string">&quot;two&quot;</span> 。</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">示例二：  </span><br><span class="line">```cpp</span><br><span class="line">输入：s = <span class="string">&quot;hi(name)&quot;</span>, knowledge = [[<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>]]</span><br><span class="line">输出：<span class="string">&quot;hi?&quot;</span></span><br><span class="line">解释：由于不知道键 <span class="string">&quot;name&quot;</span> 对应的值，所以用 <span class="string">&quot;?&quot;</span> 替换 <span class="string">&quot;(name)&quot;</span> 。</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">示例三：  </span><br><span class="line">```cpp</span><br><span class="line">输入：s = <span class="string">&quot;(a)(a)(a)aaa&quot;</span>, knowledge = [[<span class="string">&quot;a&quot;</span>,<span class="string">&quot;yes&quot;</span>]]</span><br><span class="line">输出：<span class="string">&quot;yesyesyesaaa&quot;</span></span><br><span class="line">解释：相同的键在 s 中可能会出现多次。</span><br><span class="line">键 <span class="string">&quot;a&quot;</span> 对应的值为 <span class="string">&quot;yes&quot;</span> ，所以将所有的 <span class="string">&quot;(a)&quot;</span> 替换为 <span class="string">&quot;yes&quot;</span> 。</span><br><span class="line">注意，不在括号里的 <span class="string">&quot;a&quot;</span> 不需要被替换。</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">----  </span><br><span class="line"></span><br><span class="line">看到找对应值的题，首先想到了map,然后题意告诉了我们并不需要保持map有序，所以使用unordered_map,将knowledge的值提取出来放入map,然后判断括号内的内容，找到了则替换成unordered_map[key],没找到则替换成‘？’.然后使用一个字符串保存所有结果。</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">class Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string <span class="built_in">evaluate</span>(string s, vector&lt;vector&lt;string&gt;&gt;&amp; knowledge) &#123;</span><br><span class="line">        unordered_map&lt;string,string&gt; maps;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(vector&lt;string&gt; x : knowledge)</span><br><span class="line">        &#123;</span><br><span class="line">            maps[x[<span class="number">0</span>]] = x[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ssize = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ssize ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                string tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">while</span>(s[i]!=<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp += s[i++];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(maps.<span class="built_in">find</span>(tmp)!=maps.<span class="built_in">end</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    res+=maps[tmp];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    res+=<span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res+=s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">----</span><br><span class="line">## 第四题-好因子的最大数目  </span><br><span class="line"></span><br><span class="line">时间不够没写出来，但看上去只需要维持一个素数表，利用空间换取时间，然后做到因数拆分就行了，对其因数加以判断就行了，需要注意的应该就是值太大要利用快速幂取模。  </span><br><span class="line"></span><br><span class="line">附上[大佬](https:<span class="comment">//leetcode-cn.com/problems/maximize-number-of-nice-divisors/solution/c-python3-jian-sheng-zi-zheng-shu-chai-f-0980/)题解：</span></span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">class Solution </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">maxNiceDivisors</span>(<span class="keyword">int</span> primeFactors) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> n = primeFactors;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> tmp = n / <span class="number">3</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">f</span>(<span class="number">3</span>, tmp) % <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">f</span>(<span class="number">3</span>, tmp<span class="number">-1</span>) * <span class="number">4</span> % <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">f</span>(<span class="number">3</span>, tmp) * <span class="number">2</span> % <span class="number">1000000007</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="built_in">f</span>(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> n)   </span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res *= a;</span><br><span class="line">                res %= <span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            a *= a;</span><br><span class="line">            a %= <span class="number">1000000007</span>;</span><br><span class="line">            n /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Leetcode-第243场周赛-创新奇智-力扣&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#Leetcode-第243场周赛-创新奇智-力扣&quot;&gt;¶&lt;/a&gt;Leetcode 第243场周赛 创新奇智&amp;amp;力扣&lt;/h2&gt;
&lt;p&gt;本次差点全A</summary>
      
    
    
    
    <category term="竞赛" scheme="http://example.com/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="Leetcode周赛复现" scheme="http://example.com/tags/Leetcode%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 173.二叉搜索树迭代器</title>
    <link href="http://example.com/2021/03/28/leetcode173/"/>
    <id>http://example.com/2021/03/28/leetcode173/</id>
    <published>2021-03-28T04:29:17.196Z</published>
    <updated>2021-03-28T04:48:05.421Z</updated>
    
    <content type="html"><![CDATA[<h2 id="173-二叉搜索树迭代器"><a class="header-anchor" href="#173-二叉搜索树迭代器">¶</a>173. 二叉搜索树迭代器</h2><p>实现一个二叉搜索树迭代器类BSTIterator ，表示一个按中序遍历二叉搜索树（BST）的迭代器：<br><kbd>BSTIterator(TreeNode root)</kbd> 初始化 BSTIterator 类的一个对象。BST 的根节点 root 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。<br><kbd>boolean hasNext()</kbd> 如果向指针右侧遍历存在数字，则返回 true ；否则返回 false 。<br><kbd>int next()</kbd>将指针向右移动，然后返回指针处的数字。<br>注意，指针初始化为一个不存在于 BST 中的数字，所以对 next() 的首次调用将返回 BST 中的最小元素。</p><p>你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 的中序遍历中至少存在一个下一个数字。</p><img src="https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png">  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[<span class="string">&quot;BSTIterator&quot;</span>, <span class="string">&quot;next&quot;</span>, <span class="string">&quot;next&quot;</span>, <span class="string">&quot;hasNext&quot;</span>, <span class="string">&quot;next&quot;</span>, <span class="string">&quot;hasNext&quot;</span>, <span class="string">&quot;next&quot;</span>, <span class="string">&quot;hasNext&quot;</span>, <span class="string">&quot;next&quot;</span>, <span class="string">&quot;hasNext&quot;</span>]</span><br><span class="line">[[[<span class="number">7</span>, <span class="number">3</span>, <span class="number">15</span>, null, null, <span class="number">9</span>, <span class="number">20</span>]], [], [], [], [], [], [], [], [], []]</span><br><span class="line">输出</span><br><span class="line">[null, <span class="number">3</span>, <span class="number">7</span>, <span class="literal">true</span>, <span class="number">9</span>, <span class="literal">true</span>, <span class="number">15</span>, <span class="literal">true</span>, <span class="number">20</span>, <span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">BSTIterator bSTIterator = <span class="keyword">new</span> <span class="built_in">BSTIterator</span>([<span class="number">7</span>, <span class="number">3</span>, <span class="number">15</span>, null, null, <span class="number">9</span>, <span class="number">20</span>]);</span><br><span class="line">bSTIterator.<span class="built_in">next</span>();    <span class="comment">// 返回 3</span></span><br><span class="line">bSTIterator.<span class="built_in">next</span>();    <span class="comment">// 返回 7</span></span><br><span class="line">bSTIterator.<span class="built_in">hasNext</span>(); <span class="comment">// 返回 True</span></span><br><span class="line">bSTIterator.<span class="built_in">next</span>();    <span class="comment">// 返回 9</span></span><br><span class="line">bSTIterator.<span class="built_in">hasNext</span>(); <span class="comment">// 返回 True</span></span><br><span class="line">bSTIterator.<span class="built_in">next</span>();    <span class="comment">// 返回 15</span></span><br><span class="line">bSTIterator.<span class="built_in">hasNext</span>(); <span class="comment">// 返回 True</span></span><br><span class="line">bSTIterator.<span class="built_in">next</span>();    <span class="comment">// 返回 20</span></span><br><span class="line">bSTIterator.<span class="built_in">hasNext</span>(); <span class="comment">// 返回 False</span></span><br></pre></td></tr></table></figure><p>提示：</p><p>树中节点的数目在范围 [1, 10^5] 内<br>0 &lt;= Node.val &lt;= 10^6<br>最多调用 10^5 次 hasNext 和 next 操作</p><hr><p>利用栈来实现迭代写法，因为是中序遍历，所以遍历顺序为<kbd>左-&gt;头-&gt;右</kbd></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode * cur;</span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BSTIterator</span>(TreeNode* root):<span class="built_in">cur</span>(root) &#123;</span><br><span class="line">        ans = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>) <span class="comment">//将cur指针不断指向当前节点的左子树</span></span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(cur);</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = s.<span class="built_in">top</span>(); <span class="comment">//得到最后一个左子树的结点</span></span><br><span class="line">        s.<span class="built_in">pop</span>(); <span class="comment">//弹出该结点</span></span><br><span class="line">        ans = cur-&gt;val;  <span class="comment">//得到父节点的值</span></span><br><span class="line">        cur = cur-&gt;right; <span class="comment">//符合 左-&gt;父节点-&gt;右</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!s.<span class="built_in">empty</span>() || cur != <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your BSTIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * BSTIterator* obj = new BSTIterator(root);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;next();</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;hasNext();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;173-二叉搜索树迭代器&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#173-二叉搜索树迭代器&quot;&gt;¶&lt;/a&gt;173. 二叉搜索树迭代器&lt;/h2&gt;
&lt;p&gt;实现一个二叉搜索树迭代器类BSTIterator ，表示一个按中序遍历二叉搜索树（BST）</summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>VS2017-OPENGL配置glfw+glad</title>
    <link href="http://example.com/2021/03/27/openglconf/"/>
    <id>http://example.com/2021/03/27/openglconf/</id>
    <published>2021-03-27T07:21:54.769Z</published>
    <updated>2021-03-27T08:32:05.566Z</updated>
    
    <content type="html"><![CDATA[<h2 id="VS2017-OPENGL配置glfw-glad"><a class="header-anchor" href="#VS2017-OPENGL配置glfw-glad">¶</a>VS2017-OPENGL配置glfw+glad</h2><p>之前配置的是glfw+glew,可是glad是目前比较新的，比glew更好用，所以这次配置一下glfw+glad的开发环境。(注：必须下载32位的哦)</p><hr><p>首先要去下载 <kbd>glfw</kbd> 与 <kbd>glad</kbd>，直接去官网下载就好了，glfw我们选择3.3版本的，glad下载的时候需要自己根据需求来选择,按照下图选择即可：<br><img src="https://note.youdao.com/yws/api/personal/file/WEB90ff75442785befb1ec5a4db95533f21?method=download&shareKey=9600c3ddbe6006b944057677ce1a4ca2"><br>选择完后往下翻点击generate生成下载链接，下载该zip就行了。放在自己熟悉的文件夹哦。</p><hr><p>然后打开VS，新建一个空项目，右键项目，点击属性-&gt;C/C+±&gt;附加包含目录，根据图片编辑附加包含目录：<br><img src="https://note.youdao.com/yws/api/personal/file/WEB1ce313627917875a74e043ce3939b78b?method=download&shareKey=0550ab7cdd41018536d58840eb5920aa"></p><hr><p>在上面的界面选择文件，打开之前下载的glfw文件夹，添加路径<kbd>…\glfw-3.3.2.bin.WIN32\include</kbd><br>然后我们再添加glad的路径,同样<kbd>…glad\include</kbd></p><hr><p>然后点击C/C++下面的<kbd>链接器</kbd>，点开<kbd>常规</kbd>，配置<kbd>附加库目录</kbd>:</p><img src="https://note.youdao.com/yws/api/personal/file/WEBa5c1a8f646a538c0d72be99042859656?method=download&shareKey=626ed05ecd16a80c79cce0ce95e892e7">  将<kbd>...\glfw-3.3.2.bin.WIN32\lib-vc2017</kbd>添加进去即可。<hr><p>最后点击<kbd>链接器</kbd>，点开<kbd>输入</kbd>:</p><img src="https://note.youdao.com/yws/api/personal/file/WEBf5d2b78d4938ca2f784c208a8e2bef20?method=download&shareKey=ba49dac7ec8ea2aaa6bd354e78f6db67">  然后输入： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">opengl32.lib</span><br><span class="line">glfw3.lib</span><br></pre></td></tr></table></figure><hr><p>点击确定后，打开存放glad的文件夹，找到src目录，复制里面的<kbd>glad.c</kbd>,将其放到该项目的源文件夹就全部完成了。</p><hr><p>下面来验证一下是否能够使用glfw+glad创建一个窗口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GLEW_STATIC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">glfwInit</span>();</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line">GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">glfwTerminate</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"><span class="built_in">glfwPollEvents</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">glfwTerminate</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果创建成功，则证明环境配置完成，如果遇到了</p><pre><code class="language-cpp">无法解析的外部符号 _glfwInit,该符号在函数 _main 中被引用</code></pre><p>这类报错，则证明glfw配置过程中出错，建议仔细检查。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;VS2017-OPENGL配置glfw-glad&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#VS2017-OPENGL配置glfw-glad&quot;&gt;¶&lt;/a&gt;VS2017-OPENGL配置glfw+glad&lt;/h2&gt;
&lt;p&gt;之前配置的是glfw</summary>
      
    
    
    
    <category term="OPENGL" scheme="http://example.com/categories/OPENGL/"/>
    
    
    <category term="环境配置" scheme="http://example.com/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 61.旋转链表</title>
    <link href="http://example.com/2021/03/27/leetcode61/"/>
    <id>http://example.com/2021/03/27/leetcode61/</id>
    <published>2021-03-27T04:42:17.133Z</published>
    <updated>2021-03-27T04:53:26.138Z</updated>
    
    <content type="html"><![CDATA[<h2 id="61-旋转链表"><a class="header-anchor" href="#61-旋转链表">¶</a>61. 旋转链表</h2><p>给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。</p><p>示例 1：<br><img src="https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], k = <span class="number">2</span>  </span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]  </span><br></pre></td></tr></table></figure><p>示例 2：<br><img src="https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], k = <span class="number">4</span>  </span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>提示：</p><p>链表中节点的数目在范围 [0, 500] 内<br>-100 &lt;= Node.val &lt;= 100<br>0 &lt;= k &lt;= 2 * 10^9</p><hr><p>对于这题我们可以直接先将链表连成环，然后断开旋转后的头尾结点就行了。</p><p>比如 1-&gt;2-&gt;3-&gt;4-&gt;5  我们将 5连上1 ，然后再将3,4断开，这样我们就得到了一个旋转后的链表。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">        ListNode * p = head;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        k=k%len;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>)<span class="keyword">return</span> head;<span class="comment">//如果不移动 直接返回表头</span></span><br><span class="line"></span><br><span class="line">        ListNode * q = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len - k - <span class="number">1</span> ; i++)&#123;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        p-&gt;next = head;</span><br><span class="line">        ListNode * newHead = q-&gt;next;</span><br><span class="line">        q-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;61-旋转链表&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#61-旋转链表&quot;&gt;¶&lt;/a&gt;61. 旋转链表&lt;/h2&gt;
&lt;p&gt;给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;br&gt;
&lt;i</summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 83.删除排序链表中的重复元素</title>
    <link href="http://example.com/2021/03/26/leetcode83/"/>
    <id>http://example.com/2021/03/26/leetcode83/</id>
    <published>2021-03-26T15:36:09.625Z</published>
    <updated>2021-03-26T15:37:42.698Z</updated>
    
    <content type="html"><![CDATA[<h2 id="83-删除排序链表中的重复元素"><a class="header-anchor" href="#83-删除排序链表中的重复元素">¶</a>83.删除排序链表中的重复元素</h2><h4 class="css-10c1h40-Title eugt34i1" data-cypress="QuestionTitle"><span style="font-size: 16px;"><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></span></h4><p><span style="font-size: 16px;">存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中&nbsp;没有重复出现&nbsp;的数字。</span></p><p><span style="font-size: 16px;">返回同样按升序排列的结果链表。</span></p><p><span style="font-size: 16px;">示例 1：</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p><span style="font-size: 16px;">示例 2：</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p><span style="font-size: 16px;">提示：</span></p><p><span style="font-size: 16px;">链表中节点数目在范围 [0, 300] 内</span><br /><span style="font-size: 16px;">-100 &lt;= Node.val &lt;= 100</span><br /><span style="font-size: 16px;">题目数据保证链表已经按升序排列</span></p><hr><p><span style="font-size: 16px;">跟昨天的题没啥区别，照样建新表。</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)<span class="keyword">return</span> head;</span><br><span class="line">        ListNode * newhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        newhead-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; maps;</span><br><span class="line">        ListNode * pre = head;</span><br><span class="line">        <span class="keyword">while</span>(pre != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            maps[pre-&gt;val]++;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pre = newhead;</span><br><span class="line">        ListNode * cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>( cur != <span class="literal">nullptr</span> &amp;&amp; maps[cur-&gt;val] &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode * node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(cur-&gt;val);</span><br><span class="line">                pre-&gt;next = node;</span><br><span class="line">                pre = pre-&gt;next;</span><br><span class="line">                node-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;83-删除排序链表中的重复元素&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#83-删除排序链表中的重复元素&quot;&gt;¶&lt;/a&gt;83.删除排序链表中的重复元素&lt;/h2&gt;
&lt;h4 class=&quot;css-10c1h40-Title eugt34i1&quot; d</summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 82.删除排序链表中的重复元素 II</title>
    <link href="http://example.com/2021/03/26/leetcode82/"/>
    <id>http://example.com/2021/03/26/leetcode82/</id>
    <published>2021-03-26T15:34:10.975Z</published>
    <updated>2021-03-26T15:35:59.171Z</updated>
    
    <content type="html"><![CDATA[<h2 id="82-删除排序链表中的重复元素-II"><a class="header-anchor" href="#82-删除排序链表中的重复元素-II">¶</a>82.删除排序链表中的重复元素 II</h2><h4 class="css-10c1h40-Title eugt34i1" data-cypress="QuestionTitle"><span style="font-size: 16px;"><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II</a></span></h4><p><span style="font-size: 16px;">存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中&nbsp;没有重复出现&nbsp;的数字。</span></p><p><span style="font-size: 16px;">返回同样按升序排列的结果链表。</span></p><p><span style="font-size: 16px;">示例 1：</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p><span style="font-size: 16px;">示例 2：</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p><span style="font-size: 16px;">提示：</span></p><p><span style="font-size: 16px;">链表中节点数目在范围 [0, 300] 内</span><br /><span style="font-size: 16px;">-100 &lt;= Node.val &lt;= 100</span><br /><span style="font-size: 16px;">题目数据保证链表已经按升序排列</span></p><hr><p><span style="font-size: 16px;">用哈希表保存出现的数值，将出现次数未超过一的值，建立结点赋给新链表。</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)<span class="keyword">return</span> head;</span><br><span class="line">        ListNode * newhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        newhead-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; maps;</span><br><span class="line">        ListNode * pre = head;</span><br><span class="line">        <span class="keyword">while</span>(pre != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            maps[pre-&gt;val]++;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pre = newhead;</span><br><span class="line">        ListNode * cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>( cur != <span class="literal">nullptr</span> &amp;&amp; maps[cur-&gt;val] &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode * node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(cur-&gt;val);</span><br><span class="line">                pre-&gt;next = node;</span><br><span class="line">                pre = pre-&gt;next;</span><br><span class="line">                node-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;82-删除排序链表中的重复元素-II&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#82-删除排序链表中的重复元素-II&quot;&gt;¶&lt;/a&gt;82.删除排序链表中的重复元素 II&lt;/h2&gt;
&lt;h4 class=&quot;css-10c1h40-Title eu</summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 456.132 模式</title>
    <link href="http://example.com/2021/03/26/leetcode456/"/>
    <id>http://example.com/2021/03/26/leetcode456/</id>
    <published>2021-03-26T15:10:36.906Z</published>
    <updated>2021-03-26T15:13:10.721Z</updated>
    
    <content type="html"><![CDATA[<h2 id="456-132-模式"><a class="header-anchor" href="#456-132-模式">¶</a>456.132 模式</h2><h4 class="css-10c1h40-Title eugt34i1" data-cypress="QuestionTitle"><span style="font-size: 16px;"><a href="https://leetcode-cn.com/problems/132-pattern/">456. 132 模式</a></span></h4><p><span style="font-size: 16px;">给你一个整数数组 nums ，数组中共有 n 个整数。132 模式的子序列 由三个整数 nums[i]、nums[j] 和 nums[k] 组成，并同时满足：i &lt; j &lt; k 和 nums[i] &lt; nums[k] &lt; nums[j] 。</span></p><p><span style="font-size: 16px;">如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false 。</span></p><p><span style="font-size: 16px;">&nbsp;</span></p><p><span style="font-size: 16px;">进阶：很容易想到时间复杂度为 O(n^2) 的解决方案，你可以设计一个时间复杂度为 O(n logn) 或 O(n) 的解决方案吗？</span></p><hr><p><span style="font-size: 16px;">示例 1：</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：序列中不存在 <span class="number">132</span> 模式的子序列。</span><br></pre></td></tr></table></figure><p><span style="font-size: 16px;">示例 2：</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：序列中有 <span class="number">1</span> 个 <span class="number">132</span> 模式的子序列： [<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>] 。</span><br></pre></td></tr></table></figure><p><span style="font-size: 16px;">示例 3：</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：序列中有 <span class="number">3</span> 个 <span class="number">132</span> 模式的的子序列：[<span class="number">-1</span>, <span class="number">3</span>, <span class="number">2</span>]、[<span class="number">-1</span>, <span class="number">3</span>, <span class="number">0</span>] 和 [<span class="number">-1</span>, <span class="number">2</span>, <span class="number">0</span>] 。</span><br></pre></td></tr></table></figure><p><span style="font-size: 16px;">提示：</span></p><p><span style="font-size: 16px;">n == nums.length</span><br /><span style="font-size: 16px;">1 &lt;= n &lt;= 104</span><br /><span style="font-size: 16px;">-109 &lt;= nums[i] &lt;= 109</span></p><p>&nbsp;</p><p><span style="font-size: 16px;">一开始用的是暴力法，O(n&sup2;)，勉强能接受..就是从做往右搜，以132中的3为基础，往左搜1，往右搜2，就行了。</span></p><p><span style="font-size: 16px;">代码：</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find132pattern</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> minn = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n<span class="number">-1</span> ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            minn = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= i - <span class="number">1</span> ; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(minn &gt; nums[j])minn = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt; n ; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &gt; minn &amp;&amp; nums[j] &lt; nums[i])<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p><span style="font-size: 16px;">后面又看到大神的单调栈思路，然后写了个单调栈方法，从右往左搜，利用单调栈的特性，同时找到2与3，只需要往左找1就行了。复杂度O(n)。</span></p><p><span style="font-size: 16px;">maxn维护3前面最大的数2。只要往左找到一个比maxn更小的数，就证明找到了132。</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find132pattern</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> maxn = INT_MIN;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span> ; i &gt;= <span class="number">0</span> ; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(maxn &gt; nums[i])<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()&amp;&amp;s.<span class="built_in">top</span>()&lt;nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                maxn = <span class="built_in">max</span>(s.<span class="built_in">top</span>(),maxn);</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;456-132-模式&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#456-132-模式&quot;&gt;¶&lt;/a&gt;456.132 模式&lt;/h2&gt;
&lt;h4 class=&quot;css-10c1h40-Title eugt34i1&quot; data-cypress=&quot;Qu</summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 341.扁平化嵌套列表迭代器</title>
    <link href="http://example.com/2021/03/26/leetcode341/"/>
    <id>http://example.com/2021/03/26/leetcode341/</id>
    <published>2021-03-26T15:07:54.443Z</published>
    <updated>2021-03-26T15:09:53.735Z</updated>
    
    <content type="html"><![CDATA[<h2 id="341-扁平化嵌套列表迭代器"><a class="header-anchor" href="#341-扁平化嵌套列表迭代器">¶</a>341. 扁平化嵌套列表迭代器</h2><h4 class="css-10c1h40-Title eugt34i1" data-cypress="QuestionTitle"><span style="font-size: 16px;"><a href="https://leetcode-cn.com/problems/flatten-nested-list-iterator/">341. 扁平化嵌套列表迭代器</a></span></h4><p><span style="font-size: 16px;">给你一个嵌套的整型列表。请你设计一个迭代器，使其能够遍历这个整型列表中的所有整数。</span></p><p><span style="font-size: 16px;">列表中的每一项或者为一个整数，或者是另一个列表。其中列表的元素也可能是整数或是其他列表。</span></p><hr><p><span style="font-size: 16px;">示例 1:</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [[<span class="number">1</span>,<span class="number">1</span>],<span class="number">2</span>,[<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">解释: 通过重复调用 next 直到 hasNext 返回 <span class="literal">false</span>，next 返回的元素的顺序应该是: [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]。</span><br></pre></td></tr></table></figure><p><span style="font-size: 16px;">示例 2:</span></p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,[<span class="number">4</span>,[<span class="number">6</span>]]]</span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">解释: 通过重复调用 next 直到 hasNext 返回 <span class="literal">false</span>，next 返回的元素的顺序应该是: [<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>]。</span><br></pre></td></tr></table></figure><hr><p><span style="font-size: 16px;">递归就行了。</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the interface that allows for creating nested lists.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class NestedInteger &#123;</span></span><br><span class="line"><span class="comment"> *   public:</span></span><br><span class="line"><span class="comment"> *     // Return true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line"><span class="comment"> *     bool isInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a nested list</span></span><br><span class="line"><span class="comment"> *     int getInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a single integer</span></span><br><span class="line"><span class="comment"> *     const vector&lt;NestedInteger&gt; &amp;getList() const;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator cur;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> vector&lt;NestedInteger&gt; &amp;nestedList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;nest : nestedList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nest.<span class="built_in">isInteger</span>()) &#123;</span><br><span class="line">                v.<span class="built_in">push_back</span>(nest.<span class="built_in">getInteger</span>());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(nest.<span class="built_in">getList</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NestedIterator</span>(vector&lt;NestedInteger&gt; &amp;nestedList) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(nestedList);</span><br><span class="line">        cur = v.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *cur++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cur != v.<span class="built_in">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NestedIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NestedIterator i(nestedList);</span></span><br><span class="line"><span class="comment"> * while (i.hasNext()) cout &lt;&lt; i.next();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;341-扁平化嵌套列表迭代器&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#341-扁平化嵌套列表迭代器&quot;&gt;¶&lt;/a&gt;341. 扁平化嵌套列表迭代器&lt;/h2&gt;
&lt;h4 class=&quot;css-10c1h40-Title eugt34i1&quot; dat</summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 191.位1的个数</title>
    <link href="http://example.com/2021/03/26/Leetcode191/"/>
    <id>http://example.com/2021/03/26/Leetcode191/</id>
    <published>2021-03-26T15:03:22.899Z</published>
    <updated>2021-03-26T15:06:36.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="191-位1的个数"><a class="header-anchor" href="#191-位1的个数">¶</a>191. 位1的个数</h2><p><span style="font-size: 16px;">编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。</span></p><p><span style="font-size: 16px;">提示：</span></p><p><span style="font-size: 16px;">请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</span><br /><span style="font-size: 16px;">在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的&nbsp;示例 3&nbsp;中，输入表示有符号整数 -3。</span><br /><span style="font-size: 16px;"></span></p><hr><p><span style="font-size: 16px;">示例 1：</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="number">00000000000000000000000000001011</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：输入的二进制串 <span class="number">00000000000000000000000000001011</span> 中，共有三位为 <span class="string">&#x27;1&#x27;</span>。</span><br></pre></td></tr></table></figure><p><span style="font-size: 16px;">示例 2：</span></p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="number">00000000000000000000000010000000</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：输入的二进制串 <span class="number">00000000000000000000000010000000</span> 中，共有一位为 <span class="string">&#x27;1&#x27;</span>。</span><br></pre></td></tr></table></figure><p><span style="font-size: 16px;">示例 3：</span></p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="number">11111111111111111111111111111101</span></span><br><span class="line">输出：<span class="number">31</span></span><br><span class="line">解释：输入的二进制串 <span class="number">11111111111111111111111111111101</span> 中，共有 <span class="number">31</span> 位为 <span class="string">&#x27;1&#x27;</span>。</span><br></pre></td></tr></table></figure><p><span style="font-size: 16px;">提示：</span></p><p><span style="font-size: 16px;">输入必须是长度为 32 的 二进制串 。</span><br /><span style="font-size: 16px;"></span></p><p><span style="font-size: 16px;">进阶：</span></p><p><span style="font-size: 16px;">如果多次调用这个函数，你将如何优化你的算法？</span></p><hr><p><span style="font-size: 16px;">利用位运算，判断当前数的最后一位是否为1，如果为1，则直接加入cnt,并且当前数右移一位。</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n&amp;<span class="number">1</span>)</span><br><span class="line">                cnt++;</span><br><span class="line">            n = n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;191-位1的个数&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#191-位1的个数&quot;&gt;¶&lt;/a&gt;191. 位1的个数&lt;/h2&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 16px;&quot;&gt;编写一个函数，输入是一个无符号整数（以二进制串</summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 73.矩阵置零</title>
    <link href="http://example.com/2021/03/26/leetcode73/"/>
    <id>http://example.com/2021/03/26/leetcode73/</id>
    <published>2021-03-26T14:42:11.018Z</published>
    <updated>2021-03-26T15:03:06.791Z</updated>
    
    <content type="html"><![CDATA[<h2 id="73-矩阵置零"><a class="header-anchor" href="#73-矩阵置零">¶</a>73.矩阵置零</h2><h4 class="css-10c1h40-Title eugt34i1" data-cypress="QuestionTitle"><span style="font-size: 16px;"><a href="https://leetcode-cn.com/problems/set-matrix-zeroes/">73. 矩阵置零</a></span></h4><div class="content__1Y2H"><div class="notranslate"><p><span style="font-size: 16px;">给定一个&nbsp;<code><em>m</em>&nbsp;x&nbsp;<em>n</em></code>&nbsp;的矩阵，如果一个元素为&nbsp;0&nbsp;，则将其所在行和列的所有元素都设为&nbsp;0&nbsp;。请使用&nbsp;<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>&nbsp;算法。</span></p><p><span style="font-size: 16px;">进阶：</span></p><ul><li><span style="font-size: 16px;">一个直观的解决方案是使用 &nbsp;<code>O(<em>m</em><em>n</em>)</code>&nbsp;的额外空间，但这并不是一个好的解决方案。</span></li><li><span style="font-size: 16px;">一个简单的改进方案是使用&nbsp;<code>O(<em>m</em>&nbsp;+&nbsp;<em>n</em>)</code>&nbsp;的额外空间，但这仍然不是最好的解决方案。</span></li><li><span style="font-size: 16px;">你能想出一个仅使用常量空间的解决方案吗？</span></li></ul><p><span style="font-size: 16px;">&nbsp;</span></p><p><span style="font-size: 16px;">示例 1：</span></p><span style="font-size: 16px;"><img src="https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg" alt="" /></span><pre><span style="font-size: 16px;">输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]输出：[[1,0,1],[0,0,0],[1,0,1]]</span></pre><p><span style="font-size: 16px;">示例 2：</span></p><span style="font-size: 16px;"><img src="https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg" alt="" /></span><pre><span style="font-size: 16px;">输入：matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]</span></pre><p><span style="font-size: 16px;">提示：</span></p><ul><li><span style="font-size: 16px;"><code>m == matrix.length</code></span></li><li><span style="font-size: 16px;"><code>n == matrix[0].length</code></span></li><li><span style="font-size: 16px;"><code>1 &lt;= m, n &lt;= 200</code></span></li><li><span style="font-size: 16px;"><code>-231&nbsp;&lt;= matrix[i][j] &lt;= 231&nbsp;- 1</code></span></li></ul><p>&nbsp;</p><p><span style="font-size: 16px;">普通解法，就是利用O(m+n)空间复杂度来解决问题，建立两个数组，一个row,一个col,分别保存要置零的行与要置零的列,遍历数组，获取相应的零的位置即可。</span></p><p><span style="font-size: 16px;">代码如下：</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> r[<span class="number">201</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> c[<span class="number">201</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; m ; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                r[i] = <span class="number">1</span>;</span><br><span class="line">                c[j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(r[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; m ; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(c[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    matrix[j][i] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><p><span style="font-size: 16px;">还有一种方法就是消耗最小的空间来解决问题，不创建任何数组，就利用它本身来解决问题，那么如何去解决呢。</span></p><p><span style="font-size: 16px;">首先，我们思考之前是不是都用两个数组来保存要置零的行和列，说到底就是我们需要知道哪一行需要置零，哪一列需要置零，那么我们是不是可以将置零信息保存在第0行与第0列呢。</span></p><p><span style="font-size: 16px;"><img src="https://img2020.cnblogs.com/blog/1582514/202103/1582514-20210326223554068-1329953760.png" alt="" loading="lazy" /></span></p><hr><p><span style="font-size: 16px;">最后遍历二维数组的时候，只需要遍历首行与首列，讲遇到的零的一列和一行全部置零就可以了，这个问题考虑完了，还有一个问题，就是首行与首列如果有零怎么办，我们选择用两个变量去保存首行首列是否需要置零的情况。比如，遍历首行，遇到一个零，那么我们知道，首行最后一定是要置零的，列同理，那么我们是不是应该考虑一下先后顺序，比如如果我们先将首行置零了，那接下来我们就无法根据上面的方法去判断哪一行和哪一列需要置零了，因为置零信息全部保存在起始行起始列。所以我们做事的顺序应该是：1.判断首行首列是否需要置零 2.遍历数组将需要置零的行列信息保存在首行首列（注意，遍历数组一定是不能包含首行首列的哦） 3.将蓝色区域置零 4.将粉色区域根据情况看是否置零</span></p><hr><p><span style="font-size: 16px;">这样我们就全部完成了。</span></p><p><span style="font-size: 16px;">代码如下：</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> row_z = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> col_z = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i++)</span><br><span class="line">            <span class="keyword">if</span>(matrix[<span class="number">0</span>][i] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    row_z = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    col_z = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; m ; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)</span><br><span class="line">                matrix[<span class="number">0</span>][j] = matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; m ; i++)</span><br><span class="line">            <span class="keyword">if</span>(matrix[<span class="number">0</span>][i] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; n ; j++)</span><br><span class="line">                    matrix[j][i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; i++)</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; m ; j++)</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(row_z)<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i++) matrix[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(col_z)<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++) matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;73-矩阵置零&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#73-矩阵置零&quot;&gt;¶&lt;/a&gt;73.矩阵置零&lt;/h2&gt;
&lt;h4 class=&quot;css-10c1h40-Title eugt34i1&quot; data-cypress=&quot;QuestionTit</summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>graphics pipeline - 图形管线</title>
    <link href="http://example.com/2021/03/26/graphics1/"/>
    <id>http://example.com/2021/03/26/graphics1/</id>
    <published>2021-03-26T11:18:01.301Z</published>
    <updated>2021-03-26T11:19:39.576Z</updated>
    
    <content type="html"><![CDATA[<h2 id="graphics-pipeline-图形管线"><a class="header-anchor" href="#graphics-pipeline-图形管线">¶</a>graphics pipeline - 图形管线</h2><p>标准图形系统的实施流程通常称为图形管线。&rdquo;管线&ldquo;一词在这里指从数学模型到生成屏幕上像素的过程，它包含多个步骤。在经典的体系结构中，这些步骤是按序执行的，即一个阶段的结果输出给下一个阶段，前面阶段随即开始处理新的多边形。</p><hr><p>管线简化示意图：</p><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210117225547738-1443334944.png" alt="" loading="lazy" /></p><hr><p>在许多情况下，管线的实现细节并非关注点，这时可以把它看成一个黑盒，通过黑盒，场景几何模型被转换为场景多边形的光栅透视投影（这里暂时忽略平行投影情况）图像。</p><hr><p>纹理映射与近似</p><p>　　图形管线中的一个标准模块是纹理映射(texture map)，纹理映射通过查表的方式将纹理图像的颜色映射到一个或多个多边形上。这个过程就像在表面上刻写图案或是将一张花纹纸粘贴到物体上，扫描到系统中的图像，相机拍摄的照片，或者绘图软件制作的图像都是纹理图像，<span style="background-color: #ffff00;">你可以把纹理图案想象成一张有图案的橡胶片，而纹理坐标描述了为了使这张橡胶片能够准确覆盖物体的某些部位，以及橡胶片是如何进行拉伸和变形的</span>。</p><hr><p>个人理解：</p><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210117230232056-878760406.png" alt="" loading="lazy" /></p><hr><p>如上图，就是通过纹理坐标将纹理图案进行一系列拉伸和变形准确覆盖到物体上的对应位置。</p><hr><p>通过纹理映射来指定图像上每个点的颜色仅仅是纹理映射的众多应用之一。例如，一个物体的外观部分取决于表面的法向量，计算光从表面的反射时就涉及法向量，由于表面通常采用多边形网格表示，所以通常在各多边形的顶点处计算表面的法向量，多边形内部各点的法向量则通过插值获得，从而使该物体表面呈现平滑的外观效果。</p><hr><p>上述提到，管线结构能够让我们并行处理很多任务，管线上的每一阶段针对一部分数据执行某个任务，然后将处理结果传送给下一阶段，接着这一阶段立即开始处理下一部分数据，如果管线设计合理，则大大提高处理能力。当然，随着管线所含阶段数的增多，从输入数据到生成最终结果所需的时间总量也将增加。对于交互性要求很高的系统来说，这种滞后或者潜在滞后可能会造成严重影响。</p><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210117231156283-1550082328.png" alt="" loading="lazy" /></p><hr><p>图形管线包括4个主要部分：顶点几何处理和变换，三角形处理（光栅化）和片段（fragment)生成、纹理映射和光照以及用来组装最终图像的片段组合操作。</p><p>在这个更大的管线里，应用程序提供显示所需的数据，而图形管线则生成最终的图像，但在此期间用户可能会输入信息对应用程序进行控制（例如对所显示的图像有所影响），还有从图形管线中返回的信息，他们组合起来，用于计算下一帧画面。</p><hr><p>持续补充。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;graphics-pipeline-图形管线&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#graphics-pipeline-图形管线&quot;&gt;¶&lt;/a&gt;graphics pipeline - 图形管线&lt;/h2&gt;
&lt;p&gt;标准图形系统的实施流程通常称</summary>
      
    
    
    
    <category term="图形学" scheme="http://example.com/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="概念知识" scheme="http://example.com/tags/%E6%A6%82%E5%BF%B5%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Eigen:Matrix and Vector arithmetic</title>
    <link href="http://example.com/2021/03/26/Eigen2/"/>
    <id>http://example.com/2021/03/26/Eigen2/</id>
    <published>2021-03-26T11:12:15.866Z</published>
    <updated>2021-03-26T11:16:57.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Eigen-Matrix-and-Vector-arithmetic"><a class="header-anchor" href="#Eigen-Matrix-and-Vector-arithmetic">¶</a>Eigen:Matrix and Vector arithmetic</h2><p>Eigen库 有重载关于Matrix与Vector的计算符，这样我们可以很方便的得到矩阵运算后的结果。</p><p>一些基本运算符：+,-,*,/,+=,-=,*=,/=</p><hr><p>普通的矩阵加减法运算：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Matrix2d a;</span><br><span class="line">a &lt;&lt; <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line"><span class="number">3</span>, <span class="number">4</span>;</span><br><span class="line"><span class="function">MatrixXd <span class="title">b</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">b &lt;&lt; <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line"><span class="number">1</span>, <span class="number">4</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;a + b =\n&quot;</span> &lt;&lt; a + b &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;a - b =\n&quot;</span> &lt;&lt; a - b &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Doing a += b;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">a += b;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Now a =\n&quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line"><span class="function">Vector3d <span class="title">v</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">Vector3d <span class="title">w</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;-v + w - v =\n&quot;</span> &lt;&lt; -v + w - v &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>Output:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a + b =</span><br><span class="line"><span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="number">8</span></span><br><span class="line">a - b =</span><br><span class="line"><span class="number">-1</span> <span class="number">-1</span></span><br><span class="line"> <span class="number">2</span>  <span class="number">0</span></span><br><span class="line">Doing a += b;</span><br><span class="line">Now a =</span><br><span class="line"><span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="number">8</span></span><br><span class="line">-v + w - v =</span><br><span class="line"><span class="number">-1</span></span><br><span class="line"><span class="number">-4</span></span><br><span class="line"><span class="number">-6</span></span><br></pre></td></tr></table></figure><hr><p>乘法运算：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Matrix2d a;</span><br><span class="line">a &lt;&lt; <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line"><span class="number">3</span>, <span class="number">4</span>;</span><br><span class="line"><span class="function">Vector3d <span class="title">v</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;a * 2.5 =\n&quot;</span> &lt;&lt; a * <span class="number">2.5</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;0.1 * v =\n&quot;</span> &lt;&lt; <span class="number">0.1</span> * v &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Doing v = 2;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">v = <span class="number">2</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Now v =\n&quot;</span> &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>Output:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a * <span class="number">2.5</span> =</span><br><span class="line"><span class="number">2.5</span>   <span class="number">5</span></span><br><span class="line"><span class="number">7.5</span>  <span class="number">10</span></span><br><span class="line"><span class="number">0.1</span> * v =</span><br><span class="line"><span class="number">0.1</span></span><br><span class="line"><span class="number">0.2</span></span><br><span class="line"><span class="number">0.3</span></span><br><span class="line">Doing v *= <span class="number">2</span>;</span><br><span class="line">Now v =</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><hr><p>除此之外，Eigen库关于运算还有个很人性化的地方<br />比如，VectorXf a(50),b(50),c(50),d(50);<br />...<br />a = 3 * b + 4 * c + 5 * d;<br />会自动编译为：<br />for(int i = 0 ; i &lt; 50 ; i++){<br />a[i] = 3*b[i] + 4*c[i] + 5*d[i];<br />}</p><hr><p>注意：如果你看了上面一段关于表达式模板的内容，担心做m=m*m会引起别名问题，暂时放心。Eigen将矩阵乘法作为一种特殊情况处理，并注意在这里引入一个临时的，所以它将把m=m*m编译为：</p><div class="cnblogs_code"><pre>temp = m*<span style="color: #000000;">m;m </span>= temp;</pre></div><hr><p>然后是一些特殊的计算函数，十分便利：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span>() <span class="comment">//矩阵内元素和</span></span><br><span class="line"><span class="built_in">prod</span>() <span class="comment">//元素积</span></span><br><span class="line"><span class="built_in">mean</span>() <span class="comment">//元素平均</span></span><br><span class="line"><span class="built_in">minCoeff</span>() <span class="comment">//最小元素</span></span><br><span class="line"><span class="built_in">maxCoeff</span>() <span class="comment">//最大元素</span></span><br><span class="line"><span class="built_in">trace</span>() <span class="comment">//对角线和</span></span><br><span class="line"><span class="built_in">transpose</span>() <span class="comment">//转置</span></span><br><span class="line"><span class="built_in">conjugate</span>() <span class="comment">//共轭</span></span><br><span class="line"><span class="built_in">adjoint</span>() <span class="comment">//共轭转置</span></span><br></pre></td></tr></table></figure><hr><p>普通计算函数示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Eigen::Matrix2d mat;</span><br><span class="line">mat &lt;&lt; <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line"><span class="number">3</span>, <span class="number">4</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Here is mat.sum():       &quot;</span> &lt;&lt; mat.<span class="built_in">sum</span>()       &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Here is mat.prod():      &quot;</span> &lt;&lt; mat.<span class="built_in">prod</span>()      &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Here is mat.mean():      &quot;</span> &lt;&lt; mat.<span class="built_in">mean</span>()      &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Here is mat.minCoeff():  &quot;</span> &lt;&lt; mat.<span class="built_in">minCoeff</span>()  &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Here is mat.maxCoeff():  &quot;</span> &lt;&lt; mat.<span class="built_in">maxCoeff</span>()  &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Here is mat.trace():     &quot;</span> &lt;&lt; mat.<span class="built_in">trace</span>()     &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Here is mat.<span class="built_in">sum</span>():       <span class="number">10</span></span><br><span class="line">Here is mat.<span class="built_in">prod</span>():      <span class="number">24</span></span><br><span class="line">Here is mat.<span class="built_in">mean</span>():      <span class="number">2.5</span></span><br><span class="line">Here is mat.<span class="built_in">minCoeff</span>():  <span class="number">1</span></span><br><span class="line">Here is mat.<span class="built_in">maxCoeff</span>():  <span class="number">4</span></span><br><span class="line">Here is mat.<span class="built_in">trace</span>():     <span class="number">5</span></span><br></pre></td></tr></table></figure><hr><p>并且minCoeff()与maxCoeff()能够得到相应元素的下标，可使用如下方法实现：</p><p>int i,j;</p><p>minCoeff(&amp;i,&amp;j);</p><p>maxCoeff(&amp;i,&amp;j);</p><p>得到的i,j就是相应元素的横纵坐标。</p><hr><p>转置，共轭，共轭转置示例代码：</p><div class="cnblogs_code"><pre>MatrixXcf a = MatrixXcf::Random(<span style="color: #800080;">2</span>,<span style="color: #800080;">2</span>); <span style="color: #008000;">//</span><span style="color: #008000;">随机2x2矩阵</span>cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">Here is the matrix a\n</span><span style="color: #800000;">"</span> &lt;&lt; a &lt;&lt;<span style="color: #000000;"> endl;<p>cout </span>&lt;&lt; <span style="color: #800000;">“</span><span style="color: #800000;">Here is the matrix a^T\n</span><span style="color: #800000;">”</span> &lt;&lt; a.transpose() &lt;&lt;<span style="color: #000000;"> endl;</p><p>cout </span>&lt;&lt; <span style="color: #800000;">“</span><span style="color: #800000;">Here is the conjugate of a\n</span><span style="color: #800000;">”</span> &lt;&lt; a.conjugate() &lt;&lt;<span style="color: #000000;"> endl;</p><p>cout </span>&lt;&lt; <span style="color: #800000;">“</span><span style="color: #800000;">Here is the matrix a^*\n</span><span style="color: #800000;">”</span> &lt;&lt; a.adjoint() &lt;&lt; endl;</pre></p></div><hr><p>Output:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Here is the matrix a</span><br><span class="line">    (<span class="number">-1</span>,<span class="number">-0.737</span>) (<span class="number">0.0655</span>,<span class="number">-0.562</span>)</span><br><span class="line">(<span class="number">0.511</span>,<span class="number">-0.0827</span>)  (<span class="number">-0.906</span>,<span class="number">0.358</span>)</span><br><span class="line">Here is the matrix a^T</span><br><span class="line">    (<span class="number">-1</span>,<span class="number">-0.737</span>) (<span class="number">0.511</span>,<span class="number">-0.0827</span>)</span><br><span class="line">(<span class="number">0.0655</span>,<span class="number">-0.562</span>)  (<span class="number">-0.906</span>,<span class="number">0.358</span>)</span><br><span class="line">Here is the conjugate of a</span><br><span class="line">     (<span class="number">-1</span>,<span class="number">0.737</span>)  (<span class="number">0.0655</span>,<span class="number">0.562</span>)</span><br><span class="line"> (<span class="number">0.511</span>,<span class="number">0.0827</span>) (<span class="number">-0.906</span>,<span class="number">-0.358</span>)</span><br><span class="line">Here is the matrix a^*</span><br><span class="line">     (<span class="number">-1</span>,<span class="number">0.737</span>)  (<span class="number">0.511</span>,<span class="number">0.0827</span>)</span><br><span class="line"> (<span class="number">0.0655</span>,<span class="number">0.562</span>) (<span class="number">-0.906</span>,<span class="number">-0.358</span>)</span><br></pre></td></tr></table></figure><p>注意：<span style="background-color: #00ffff;">至于基本的算术运算符，transpose()和 adjoint()只是返回一个代理对象，而不进行实际的转置。如果你做b = a.transpose()，那么在将结果写入b的同时就会对transpose进行评估。如果执行a = a.transpose()，那么在转置的评估完成之前，Eigen就开始将结果写入a中。因此，指令a = a.transpose()并不像人们所期望的那样，用它的转置替换a。</span></p><hr><p>还有两个函数差点忘记说了，分别是dot()与cross()，一个是计算点积，一个是计算叉积，非常实用的两个函数！</p><hr><p>补充两个编译时容易出现的错误：（官方文档详细说明）</p><p><a class="el" title="Namespace containing all symbols from the Eigen library." href="http://eigen.tuxfamily.org/dox/namespaceEigen.html">Eigen</a>&nbsp;checks the validity of the operations that you perform. When possible, it checks them at compile time, producing compilation errors. These error messages can be long and ugly, but&nbsp;<a class="el" title="Namespace containing all symbols from the Eigen library." href="http://eigen.tuxfamily.org/dox/namespaceEigen.html">Eigen</a>&nbsp;writes the important message in UPPERCASE_LETTERS_SO_IT_STANDS_OUT. For example:（Eigen会检查你所执行的操作的有效性，在可能的情况下，它会在编译时检查它们，产生编译错误。在可能的情况下，它在编译时检查它们，产生编译错误。这些错误信息可能又长又丑，但Eigen会把重要的信息用UPPERCASE_LETTERS_SO_IT_STANDS_OUT写出来，如下：）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Matrix3f m;</span><br><span class="line">Vector4f v;</span><br><span class="line">v = m*v; <span class="comment">// Compile-time error: YOU_MIXED_MATRICES_OF_DIFFERENT_SIZES</span></span><br></pre></td></tr></table></figure><div class="line"><span class="comment">Of course, in many cases, for example when checking dynamic sizes, the check cannot be performed at compile time.&nbsp;<a class="el" title="Namespace containing all symbols from the Eigen library." href="http://eigen.tuxfamily.org/dox/namespaceEigen.html">Eigen</a>then uses runtime assertions. This means that the program will abort with an error message when executing an illegal operation if it is run in "debug mode", and it will probably crash if assertions are turned off（当然，在很多情况下，比如检查动态大小时，不能在编译时进行检查。Eigen就会使用运行时断点。这意味着，如果在 "debug模式 "下运行，程序在执行非法操作时，会以错误信息中止，如果断点被关闭，程序很可能会崩溃）.</span></div><div class="line">&nbsp;</div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MatrixXf <span class="title">m</span><span class="params">(<span class="number">3</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">VectorXf <span class="title">v</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">v = m * v; <span class="comment">// Run-time assertion failure here: &quot;invalid matrix product&quot;</span></span><br></pre></td></tr></table></figure><p><span class="comment">解释：第一个就是两种不同类型的矩阵相乘会出现SIZE报错，这是理所当然的，第二个就是检查动态大小时，不能在编译时进行检查！</span></p></div><hr><p>有些内容暂时用不到，以后补充。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Eigen-Matrix-and-Vector-arithmetic&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#Eigen-Matrix-and-Vector-arithmetic&quot;&gt;¶&lt;/a&gt;Eigen:Matrix and Vector</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="Eigen" scheme="http://example.com/tags/Eigen/"/>
    
  </entry>
  
  <entry>
    <title>Eigen:The Matrix Class</title>
    <link href="http://example.com/2021/03/26/Eigen1/"/>
    <id>http://example.com/2021/03/26/Eigen1/</id>
    <published>2021-03-26T11:05:43.527Z</published>
    <updated>2021-03-26T11:11:24.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="The-Matrix-Class"><a class="header-anchor" href="#The-Matrix-Class">¶</a>The Matrix Class</h2><p>Eigen库 矩阵类的使用：</p><p>（本文根据官方文档加上自己的一些理解修改制成）</p><hr><p>首先关于Matrix的定义：&nbsp; Matrix&lt;typename scalar, int RowsAtCompileTime, int ColsAtCompileTime&gt; 这是常用的模板，一般为三个参数，也就是Matrix&lt;矩阵变量类型，行数，列数&gt;.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">　　　　　　　　　　　 Matrix&lt;<span class="keyword">typename</span> Scalar, <span class="comment">//标量类型</span></span><br><span class="line"></span><br><span class="line">　　　　　　　　　　　　　    <span class="keyword">int</span> RowsAtCompileTime, <span class="comment">//行数</span></span><br><span class="line"></span><br><span class="line">　　　　　　　　　　　　　　  <span class="keyword">int</span> ColsAtCompileTime,<span class="comment">//列数</span></span><br><span class="line"></span><br><span class="line"> 　　　　　　　　　　　　　　 <span class="keyword">int</span> Options = <span class="number">0</span>,<span class="comment">//位域</span></span><br><span class="line"></span><br><span class="line">　　　　　　　　　　　　      <span class="keyword">int</span> MaxRowsAtCompileTime = RowsAtCompileTime,<span class="comment">//最大行数</span></span><br><span class="line"></span><br><span class="line">　　　　　　　　　　　　　　  <span class="keyword">int</span> MaxColsAtCompileTime = ColsAtCompileTime&gt; <span class="comment">//最大列数</span></span><br></pre></td></tr></table></figure><p><em>使用Eigen库定义一个矩阵: Matrix&lt;int,2,2&gt; 这是一个int类型的2x2矩阵</em></p><p><em>　　　　　　　　　　　　Matrix&lt;float,3,3&gt;这是一个float类型的3x3矩阵</em></p><hr><p><em>Eigen库中简化了部分以上定义的过程，一般用于固定尺寸的矩阵的定义。</em></p><p><em>例如：&nbsp; Matrix2f,Matrix3f,Matrix4f&nbsp; float类型的2x2,3x3,4x4的矩阵(可见结尾部分为f）</em></p><p><em>&nbsp; &nbsp; &nbsp;同理Matrix2d,Matrix3d,Matrix4d,Matrix2i,Matrix3i,Matrix4i,只需要看最后结尾的字母，即可明白变量类型(double,int)</em></p><p>Eigen还有个常用的概念，向量，向量是矩阵中的特殊情况，表现为有一行或一列，也就是行向量和列向量，最常见的情况是只有一列，表现方式有：</p><p>　　　　　　　　　　　&nbsp; typedef Matrix&lt;float, 3, 1&gt; Vector3f;&nbsp; //列向量</p><p>　　　　　　　　　　　&nbsp; typedef Matrix&lt;int, 1, 2&gt; RowVector2i; //行向量</p><hr><p>接下来说明它们各自的赋值方式以及特殊情况：</p><p>静态矩阵下有如下的初始化方式:&nbsp; Vector2i myvector(1,2);&nbsp; 表示初始化一个列向量为<img src="https://img2020.cnblogs.com/blog/1582514/202012/1582514-20201230135221369-1383356973.png" alt="" loading="lazy" />&nbsp;或者 Vector2f myvector(1.0,2.0); 表示初始化一个列向量为<img src="https://img2020.cnblogs.com/blog/1582514/202012/1582514-20201230135913953-1373528500.png" alt="" loading="lazy" /></p><hr><p>向量能这样初始化，但Matrix就不行了，比如Matrix3f a(3,3)虽然编译能够通过，不会报错，但是这样的传递参数是无效的， 在官方文档有解释：In order to offer a uniform API across fixed-size and dynamic-size matrices, it is legal to use these constructors on fixed-size matrices, even if passing the sizes is useless in this case. 意思是：为了在固定大小和动态大小的矩阵上提供统一的API，在固定大小的矩阵上使用这些构造函数是合法的，即使在这种情况下传递大小是无用的。</p><hr><p>所以只能使用规定的输入方法： Matrix3f a;</p><p>　　　　　　　　　　　　　　 a&lt;&lt;1,2,3,</p><p>　　　　　　　　　　　　　　&nbsp; &nbsp; &nbsp; &nbsp;4,5,6,</p><p>　　　　　　　　　　　　　　　　7,8,9;</p><hr><p>说完静态矩阵，接下来说动态矩阵：typedef Matrix &lt;double,Dynamic,Dynamic&gt; MatrixXd;</p><p>看如下对比即可明白：</p><p>一般Matrix4f mymatrix; 等价于 float mymatrix[16];<br />一般MatrixXf mymatrix(rows,columns); 等价于 float *mymatrix = new float[rows*columns];</p><hr><p>所以有 MatrixXf a(2,2) 即定义一个2x2的矩阵，而且Eigen库有访问矩阵中值的特定方式。</p><p>如<img src="https://img2020.cnblogs.com/blog/1582514/202012/1582514-20201230140825999-966352070.png" alt="" loading="lazy" />，&nbsp;</p><hr><p>访问第一行第一个元素 即 a(0,1) ,也可 a(0,1) = x 为第一行第一个元素赋值。</p><p>如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">MatrixXd <span class="title">m</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="built_in">m</span>(<span class="number">0</span>,<span class="number">0</span>) = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">m</span>(<span class="number">1</span>,<span class="number">0</span>) = <span class="number">2.5</span>;</span><br><span class="line"><span class="built_in">m</span>(<span class="number">0</span>,<span class="number">1</span>) = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">m</span>(<span class="number">1</span>,<span class="number">1</span>) = <span class="built_in">m</span>(<span class="number">1</span>,<span class="number">0</span>) + <span class="built_in">m</span>(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Here is the matrix m:\n&quot;</span> &lt;&lt; m &lt;&lt; std::endl;</span><br><span class="line"><span class="function">VectorXd <span class="title">v</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="built_in">v</span>(<span class="number">0</span>) = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">v</span>(<span class="number">1</span>) = <span class="built_in">v</span>(<span class="number">0</span>) - <span class="number">1</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Here is the vector v:\n&quot;</span> &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Here is the matrix m:</span><br><span class="line">  <span class="number">3</span>  <span class="number">-1</span></span><br><span class="line"><span class="number">2.5</span> <span class="number">1.5</span></span><br><span class="line">Here is the vector v:</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>像这类动态分配大小的矩阵，有 resize()方法，可以重新定义大小，这篇代码写的很清楚：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">MatrixXd <span class="title">m</span><span class="params">(<span class="number">2</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">m.<span class="built_in">resize</span>(<span class="number">4</span>,<span class="number">3</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;The matrix m is of size &quot;</span></span><br><span class="line">&lt;&lt; m.<span class="built_in">rows</span>() &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; m.<span class="built_in">cols</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;It has &quot;</span> &lt;&lt; m.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; coefficients&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="function">VectorXd <span class="title">v</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">v.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;The vector v is of size &quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;As a matrix, v is of size &quot;</span></span><br><span class="line">&lt;&lt; v.<span class="built_in">rows</span>() &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; v.<span class="built_in">cols</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The matrix m is of size <span class="number">4</span>x3</span><br><span class="line">It has <span class="number">12</span> coefficients</span><br><span class="line">The vector v is of size <span class="number">5</span></span><br><span class="line">As a matrix, v is of size <span class="number">5</span>x1</span><br></pre></td></tr></table></figure><hr><p>&nbsp;然后说明一下固定尺寸与动态尺寸的选择问题，也就是什么时候静态分配最好，什么时候动态分配最好。</p><p>&nbsp;对于非常小的尺寸，尽可能使用Fixed（一般定义为小于等于16），这种情况下使用Fixed尺寸性能更加优越,因为它可以让Eigen避免动态内存分配和展开循环，对于较大尺寸的话就使用dynamic尺寸，</p><p>&nbsp;当然，使用固定大小的局限性在于，只有在编译时知道大小时才有可能。另外，对于足够大的尺寸，比如说大于或等于32的尺寸，使用固定尺寸的性能优势就变得微不足道了。更糟糕的是，如果试图在函数中使用固定大小创建一个非常大&nbsp; &nbsp;的矩阵，可能会导致堆栈溢出，因为Eigen会尝试将数组作为一个局部变量自动分配，而这通常是在堆栈中完成的。最后，根据不同的情况，当使用动态大小时，Eigen还可以更积极地尝试矢量化（使用SIMD指令）。</p><hr><p>&nbsp;最后解释一下上面说过的可选参数模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Matrix&lt;<span class="keyword">typename</span> Scalar,</span><br><span class="line">　　　　　　<span class="keyword">int</span> RowsAtCompileTime,</span><br><span class="line">　　　　　　<span class="keyword">int</span> ColsAtCompileTime,</span><br><span class="line">　　　　　　<span class="keyword">int</span> Options = <span class="number">0</span>,</span><br><span class="line">　　　　　　<span class="keyword">int</span> MaxRowsAtCompileTime = RowsAtCompileTime,</span><br><span class="line">　　　　　　<span class="keyword">int</span> MaxColsAtCompileTime = ColsAtCompileTime&gt;</span><br></pre></td></tr></table></figure><p>从参数的定义名即可看出来其大概意思。</p><p>分析：Matrix&lt;float,Dynamic,Dynamic,0,3,4&gt;&nbsp; 一个不知道大小，但最大行数为3，最大列数为4的矩阵。<br />从官方文档对于Matrix Optional template parameters 的定义来看，这是一个确定了上限的固定内存矩阵，如果在编译时不知道矩阵的确切大小，但在编译时可以知道一个固定的上限，这样做可以避免动态内存分配。</p><p>第三个参数是什么意思呢，在我看来是一个优先级的参数，比如一个矩阵是行优先还是列优先就是使用这个参数，0一般是默认值，不设置任何优先。</p><p>比如：Matrix&lt;float,3,3,RowMajor&gt; 就是一个行优先的矩阵。</p><hr><p>补充Eigen便利类型定义：</p><p><a class="el" title="Namespace containing all symbols from the Eigen library." href="http://eigen.tuxfamily.org/dox/namespaceEigen.html">Eigen</a>&nbsp;defines the following&nbsp;<a class="el" title="The matrix class, also used for vectors and row-vectors." href="http://eigen.tuxfamily.org/dox/classEigen_1_1Matrix.html">Matrix</a>&nbsp;typedefs:</p><ul><li>MatrixNt for Matrix&lt;type, N, N&gt;. For example, MatrixXi for Matrix&lt;int, Dynamic, Dynamic&gt;.</li><li>VectorNt for Matrix&lt;type, N, 1&gt;. For example, Vector2f for Matrix&lt;float, 2, 1&gt;.</li><li>RowVectorNt for Matrix&lt;type, 1, N&gt;. For example, RowVector3d for Matrix&lt;double, 1, 3&gt;.</li></ul><p>Where:</p><ul><li>N can be any one of&nbsp;<code>2</code>,&nbsp;<code>3</code>,&nbsp;<code>4</code>, or&nbsp;<code>X</code>&nbsp;(meaning&nbsp;<code>Dynamic</code>).</li><li>t can be any one of&nbsp;<code>i</code>&nbsp;(meaning int),&nbsp;<code>f</code>&nbsp;(meaning float),&nbsp;<code>d</code>&nbsp;(meaning double),&nbsp;<code>cf</code>&nbsp;(meaning complex&lt;float&gt;), or&nbsp;<code>cd</code>(meaning complex&lt;double&gt;). The fact that typedefs are only defined for these five types doesn't mean that they are the only supported scalar types. For example, all standard integer types are supported, see&nbsp;<a class="el" href="http://eigen.tuxfamily.org/dox/TopicScalarTypes.html">Scalar types</a>.</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;The-Matrix-Class&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#The-Matrix-Class&quot;&gt;¶&lt;/a&gt;The Matrix Class&lt;/h2&gt;
&lt;p&gt;Eigen库 矩阵类的使用：&lt;/p&gt;
&lt;p&gt;（本文根据官方文档加上自</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="Eigen" scheme="http://example.com/tags/Eigen/"/>
    
  </entry>
  
  <entry>
    <title>线性代数及其应用(二)</title>
    <link href="http://example.com/2021/03/26/lial2/"/>
    <id>http://example.com/2021/03/26/lial2/</id>
    <published>2021-03-26T11:00:38.711Z</published>
    <updated>2021-03-26T11:05:08.478Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线性代数及其应用-二"><a class="header-anchor" href="#线性代数及其应用-二">¶</a>线性代数及其应用(二)</h2><p>向量方程</p><p>线性方程组的重要性质都可用向量概念与符号来描述。</p><p><strong>R</strong><sup>2</sup>中的向量:</p><p>　　仅含一列的矩阵称为列向量，或简称向量，包含两个元素的向量如下：</p><p>　　<img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114203419813-1752537434.png" alt="" loading="lazy" /><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114203438965-2116671834.png" alt="" loading="lazy" /><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114203521345-1191418457.png" alt="" loading="lazy" /></p><hr><p>&nbsp;　&nbsp; 其中w<sub>1</sub>和w<sub>2</sub>是任意实数，所有两个元素的向量集记为<strong>R</strong><sup>2</sup>，<strong>R</strong>表示向量中的元素是实数，而指数2表示每个向量包含两个元素.&nbsp;</p><p>　　给定<strong>R</strong><sup>2</sup>中两个向量u和v，它们的和u+v是把u和v对应元素相加所得的向量，如</p><p>　　<img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114203944587-551626870.png" alt="" loading="lazy" /></p><hr><div class="cnblogs_code"><pre><span style="color: #000000;">\begin{bmatrix}</span><span style="color: #800080;">1</span><span style="color: #000000;">\\ </span>-<span style="color: #800080;">2</span><span style="color: #000000;">\\\end{bmatrix}</span>+<span style="color: #000000;">\begin{bmatrix}</span><span style="color: #800080;">2</span><span style="color: #000000;">\\ </span><span style="color: #800080;">5</span><span style="color: #000000;">\\\end{bmatrix}</span>=<span style="color: #000000;">\begin{bmatrix}</span><span style="color: #800080;">1</span>+<span style="color: #800080;">2</span><span style="color: #000000;">\\ </span>-<span style="color: #800080;">2</span>+<span style="color: #800080;">5</span><span style="color: #000000;">\\\end{bmatrix}</span>=<span style="color: #000000;">\begin{bmatrix}</span><span style="color: #800080;">3</span><span style="color: #000000;">\\ </span><span style="color: #800080;">3</span><span style="color: #000000;">\\\end{bmatrix}</span></pre></div><hr><p>　　给定向量u和实数c,u与c的标量乘法（或数乘）是把u的每个元素乘以c,所得向量记为cu，例如：</p><p>　　若<img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114204144474-273683973.png" alt="" loading="lazy" />;, c = 5,则</p><hr><p>&nbsp; &nbsp; &nbsp; &nbsp;<img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114204235817-645942824.png" alt="" loading="lazy" /></p><hr><div class="cnblogs_code"><pre>cu = <span style="color: #800080;">5</span><span style="color: #000000;">\begin{bmatrix}</span><span style="color: #800080;">3</span><span style="color: #000000;">\\ </span>-<span style="color: #800080;">1</span><span style="color: #000000;">\\\end{bmatrix}</span>=<span style="color: #000000;">\begin{bmatrix}</span><span style="color: #800080;">15</span><span style="color: #000000;">\\ </span>-<span style="color: #800080;">5</span><span style="color: #000000;">\\\end{bmatrix}</span></pre></div><hr><p><strong>&nbsp;R</strong><sup>2</sup>的几何表示</p><p>　　考虑平面上的直角坐标系，因为平面上每个点由实数的有序对确定，所以可把几何点(a,b) 与列向量<img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114204443579-1598459939.png" alt="" loading="lazy" />等同，因此我们可把R<sup>2</sup>看作平面上所有点的集合</p><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114204712781-911184167.png" alt="" loading="lazy" />&nbsp;&nbsp;<hr><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114204820571-445091784.png" alt="" loading="lazy" /></p></p><hr><p>&nbsp;　　两个向量的和的几何意义</p><p>　　<img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114205154150-1250560095.png" alt="" loading="lazy" /></p><hr><p>　　<strong>R</strong><sup>3</sup>中的向量</p><p>　　<img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114205719156-1126824442.png" alt="" loading="lazy" /></p><hr><p>　　<strong>R</strong><sup>n</sup>中的代数性质 （对<strong>R</strong><sup>n</sup>中一切向量u,v,w以及标量c和d）：</p><p>　　1. u + v = v + u</p><p>　　2.(u+v)+w = u+(v+w)</p><p>　　3.(u+0)=0+u=u</p><p>　　4.u+(-u) = -u+u =0</p><p>　　5.c(u+v)=cu+cv</p><p>　　6.(c+d)u=cu+du</p><p>　　7.c(du)=(cd)u</p><p>　　8.1u=u</p><hr><p>　　线性代数的一个主要思想是研究可以表示为某一个固定向量集合{v<sub>1</sub>,v<sub>2</sub>,....v<sub>p</sub>}的线性组合的所有向量</p><p>　　Span{v} 与 Span{u,v}的几何解释</p><p>　　设v是<strong>R</strong><sup>3</sup>中的向量，那么Span{v}就是v的所有标量倍数的集合，也就是<strong>R</strong><sup>3</sup>中通过v和0的直线上所有点的集合</p><p>　　</p><p>&nbsp;　　<img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114210420986-390914887.png" alt="" loading="lazy" /></p><hr><p>　　　若u和v是<strong>R</strong><sup>3</sup>中的非零向量，v不是u的倍数，则Span{u,v}是<strong>R</strong><sup>3</sup>中包含u,v和0的平面，特别地，Span{u,v}包含<strong>R</strong><sup>3</sup>中通过u与0的直线，也包含通过v与0的直线，反正就是确定了一个平面。</p><p>　　　　</p><p>&nbsp;　　<img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114210841656-276500780.png" alt="" loading="lazy" /></p><hr><p>&nbsp;　　蓝色范围在概念上无限扩充。</p><p>&nbsp;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;线性代数及其应用-二&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#线性代数及其应用-二&quot;&gt;¶&lt;/a&gt;线性代数及其应用(二)&lt;/h2&gt;
&lt;p&gt;向量方程&lt;/p&gt;
&lt;p&gt;线性方程组的重要性质都可用向量概念与符号来描述。&lt;/p&gt;
&lt;p&gt;&lt;strong</summary>
      
    
    
    
    <category term="数学" scheme="http://example.com/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="线性代数" scheme="http://example.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>线性代数及其应用(一)</title>
    <link href="http://example.com/2021/03/26/lial1/"/>
    <id>http://example.com/2021/03/26/lial1/</id>
    <published>2021-03-26T10:58:34.458Z</published>
    <updated>2021-03-26T11:00:26.140Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线性代数及其应用-一"><a class="header-anchor" href="#线性代数及其应用-一">¶</a>线性代数及其应用(一)</h2><p>线性方程组：</p><p>包含变量x<sub>1</sub>,x<sub>2</sub>，&hellip;&hellip;，x<sub>n</sub>的线性方程是形如</p><p>　　　　　　　　　　a<sub>1</sub>x<sub>2</sub> +a<sub>2</sub>x<sub>2</sub>+...+a<sub>3</sub>x<sub>3</sub>&nbsp; = b&nbsp;</p><p>的方程，其中b与系数a<sub>1&nbsp; &nbsp;</sub>，a<sub>2&nbsp;</sub>&nbsp;，&hellip;&hellip; ，a<sub>n是实数或者复数，通常是已知数，下标n可以是任意正整数。</sub><sub><br /></sub></p><hr><p>线性方程组的解有下列三种情况：</p><p>①无解</p><p>②有唯一解</p><p>③有无穷多解</p><hr><p>若一个线性方程组有一个解或无穷多个解，则称它是相容的，若它无解，则称它是不相容的。</p><hr><p>初等行变换：</p><p>①（倍加变换）把某一行换成它本身与另一行的倍数的和</p><p>②（对换变换）把两行对换</p><p>③（倍乘对换）把某一行的所有元素乘以同一个非零数</p><hr><p>行变换可以施与任何矩阵，不仅仅是对于线性方程组的增广矩阵，若其中一个矩阵可以经过一系列初等行变换变换成另外一个矩阵，则我们称这两个矩阵是等价的。</p><p>若两个线性方程组的增广矩阵是行等价的，则它们具有相同的解集。</p><hr><p>行简化与阶梯形矩阵</p><p>定义：一个矩阵称为阶梯形（或行阶梯形），则它有已下三个性质：</p><p>①每一非零行都在每一零行之上</p><p>②某一行的先导元素所在的列位于前一行先导元素的右边</p><p>③某一先导元素所在列下方元素都是零</p><p>一个矩阵称为简化阶梯形，则它满足以下性质：</p><p>①每一非零行的先导元素是1</p><p>②每一先导元素1是该元素所在列的唯一非零元素</p><hr><p>通常将矩阵变换成简化阶梯形矩阵的过程称为高斯消元法。（计算机程序通常选择一列中绝对值最大的元素作为主元，可以减少舍入误差）</p><p>但某些条件下高斯消元法不适用，使用的是部分主元法（列主元高斯消元法）</p><hr><p>原因：</p><p>&nbsp;</p><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210111155846873-924934418.png" alt="" loading="lazy" /></p><hr><p>&nbsp;<img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210111155905395-20983245.png" alt="" loading="lazy" /></p><hr><p>&nbsp;图片来自：<a href="https://www.zhihu.com/question/33862337">https://www.zhihu.com/question/33862337</a></p><hr><p>部分主元法思想：在进行第k(k=1,2,3...n-1)步消元时，从第k列的a<sub>kk</sub>及其以下的各元素中选取绝对值最大的元素，然后通过行变换将它交换到主元素a<sub>kk</sub>的位置上，再进行消元。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;线性代数及其应用-一&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#线性代数及其应用-一&quot;&gt;¶&lt;/a&gt;线性代数及其应用(一)&lt;/h2&gt;
&lt;p&gt;线性方程组：&lt;/p&gt;
&lt;p&gt;包含变量x&lt;sub&gt;1&lt;/sub&gt;,x&lt;sub&gt;2&lt;/sub&gt;，&amp;hell</summary>
      
    
    
    
    <category term="数学" scheme="http://example.com/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="线性代数" scheme="http://example.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++关于数据和函数</title>
    <link href="http://example.com/2021/03/26/C++datafuc/"/>
    <id>http://example.com/2021/03/26/C++datafuc/</id>
    <published>2021-03-26T10:51:03.688Z</published>
    <updated>2021-03-26T10:55:26.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-关于数据和函数"><a class="header-anchor" href="#C-关于数据和函数">¶</a>C++关于数据和函数</h2><p><span style="color: #000000; font-size: 14pt;">C++关于数据和函数</span></p><p>C语言在设计程序的时候会准备一些数据和函数，函数用来处理你创造的数据，这样会有一些缺点，由于语言没有提供足够的关键字，所以这些数据一定是全局的，所以所有的函数都可以处理这些数据，在后期会造成很大的影响的，所以面向对象语言C++出现了，基本思想是把数据和处理这些数据的函数包装在一起，也就是&ldquo;类&rdquo;，类其实和结构体是差不多的。</p><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210111195119606-1812816107.png" alt="" loading="lazy" /></p><hr><p>类是否涉及指针，一定要特别注意</p><p>Class 的 两个经典分类：</p><p>&middot;Class without pointer member(s)</p><p>&middot;Class with pointer member(s)</p><hr><p><span style="font-size: 14pt;">C++ program 代码基本形式</span></p><p>&nbsp;</p><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210111195754227-2039798270.png" alt="" loading="lazy" /></p><hr><p>&nbsp;.h 头文件 与 .cpp 代码程序</p><p>用#include的方法使用头文件，标准库也是类似。</p><p>使用自己的写的头文件使用双引号"",默认库使用尖括号&lt;&gt;</p><p>延伸文件名不一定是.h或.cpp</p><p>也可能是.hpp甚至是无延伸名</p><p>在不同的平台上可能不同。</p><p>Header头文件中的防卫式声明</p><p>#ifndef _XXX_&nbsp; &nbsp; &nbsp; &nbsp;//if not define 如果没有被定义（引用）过</p><p>#define _XXX_&nbsp; &nbsp; &nbsp; //则执行下列代码直到#endif</p><p>...</p><p>...</p><p>#endif&nbsp; //若第一行判定被定义过，则直接跳到#endif</p><p>作用是避免多重调用,出现重定义错误！</p><hr><p>比如 我在 Main.cpp 中&nbsp;</p><div class="cnblogs_code"><pre>#include<span style="color: #800000;">"</span><span style="color: #800000;">op1.h</span><span style="color: #800000;">"</span><span style="color: #000000;">#include</span><span style="color: #800000;">"</span><span style="color: #800000;">op2.h</span><span style="color: #800000;">"</span><span style="color: #000000;">.........</span></pre></div><p>而在op2.h中</p><div class="cnblogs_code"><pre>#include<span style="color: #800000;">"</span><span style="color: #800000;">op1.h</span><span style="color: #800000;">"</span><span style="color: #000000;">.........</span></pre></div><p>&nbsp;这样就形成了多重调用，因为op2.h中包含了op1.h，而在Main.cpp中既调用了op2.h也调用了op1.h。</p><p>&nbsp;<span style="color: #ff0000;">所以要养成写任何一个头文件都要使用#ifndef来避免重定义的习惯。</span></p><hr><p>既然有 #ifndef ，所以也有#ifdef</p><p>当在不同平台下编写代码时，由于环境不同，所以要使用的头文件也会不同，这时就可以用到#ifdef</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> OS_Win</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> OS_Linux</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这样就实现了windows环境下调用windows.h 而Linux环境下则调用linux.h。</p><p>Class 的声明（拿complex来举例）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">complex</span> (<span class="keyword">double</span> r = <span class="number">0</span> , <span class="keyword">double</span> i = <span class="number">0</span> ) <span class="comment">//构造函数</span></span><br><span class="line">    : <span class="built_in">re</span>(r),<span class="built_in">im</span>(i)</span><br><span class="line">   &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    complex&amp; <span class="keyword">operator</span> += (<span class="keyword">const</span> complex&amp;); <span class="comment">//重载+=</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">real</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> re;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> im;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> re,im;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>public: 下的函数或者数据都是可以直接给外界访问的，而private：下的函数或数据只能内部访问。实现数据与函数封装。</p><hr><p>class template(模板）</p><p>当你使用大量同一种数据类型的变量的时候，突然想改变这些变量的数据类型，那么一条一条代码去改是很难实现的，就比如上面有变量re和im，我想同时改变它们两个的数据类型，首先是变量声明那改成另一种数据类型，但是还有相关函数呢，返回的也是double类型，也需要更改，而且构造函数中传入的参数也是double类型，几乎所有地方都要修改，这样就显得极其麻烦，而且如果想通过不同的情况随时更改无法实现，灵活性也极差。</p><p>那么就使用到了&ldquo;模板&rdquo;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">complex</span> (T r = <span class="number">0</span> , T = <span class="number">0</span> ) <span class="comment">//构造函数</span></span><br><span class="line">    : <span class="built_in">re</span>(r),<span class="built_in">im</span>(i)</span><br><span class="line">   &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    complex&amp; <span class="keyword">operator</span> += (<span class="keyword">const</span> complex&amp;); <span class="comment">//重载+=</span></span><br><span class="line">    <span class="function">T <span class="title">real</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> re;&#125;</span><br><span class="line">    <span class="function">T <span class="title">imag</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> im;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T re;</span><br><span class="line">    T im;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">...主函数...</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">complex&lt;<span class="keyword">double</span>&gt; <span class="title">c1</span><span class="params">(<span class="number">2.5</span>,<span class="number">1.5</span>)</span></span>;</span><br><span class="line">    <span class="function">complex&lt;<span class="keyword">int</span>&gt; <span class="title">c1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就想使用double类型就用double模板，使用int类型就用int模板。灵活性强。</p><hr><p>关于 避免头文件重定义的补充：</p><p>我们已经知道一种方法 #ifndef</p><p>还有一种方法是 #pragma once</p><p>那么这两种方法有什么区别呢？</p><p>#ifndef 因为要定义宏名，如果出现两个头文件定义的宏名相同的话，可能会导致使用该头文件，但编译器找不到。</p><p>#pragma once则由编译器提供保证：同一个文件不会被包含多次。且这个文件是物理上的文件，缺点是如果物理文件被拷贝多次会导致无法避免重定义，且不支持跨平台。</p><hr><p>所以两种方法的使用需要根据情况来把握。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-关于数据和函数&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#C-关于数据和函数&quot;&gt;¶&lt;/a&gt;C++关于数据和函数&lt;/h2&gt;
&lt;p&gt;&lt;span style=&quot;color: #000000; font-size: 14pt;&quot;&gt;C++关于数据</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++学习" scheme="http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>C++ 重载</title>
    <link href="http://example.com/2021/03/26/C++opcz/"/>
    <id>http://example.com/2021/03/26/C++opcz/</id>
    <published>2021-03-26T10:46:25.415Z</published>
    <updated>2021-03-26T10:50:22.917Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-重载"><a class="header-anchor" href="#C-重载">¶</a>C++ 重载</h2><p>操作符就是一种函数，是可以让你重新定义的<br />比如说相加，与其自己写个相加函数 plus(u,v); 将u,v相加，<br />用 "+" 号 显得更为方便，可读性更高，所以C++就出现了重载运算符这个功能。<br />并且可以实现将各种你需要的属性相加。</p><p>一般来说，重载操作符的对象会有接收者和传递者</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> complex&amp;</span><br><span class="line">complex::<span class="keyword">operator</span> += (<span class="keyword">this</span>,<span class="keyword">const</span> complex&amp; r)&#123;</span><br><span class="line"><span class="keyword">return</span> __doapl(<span class="keyword">this</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面那个this,是不需要写的  比如 complex c1,c2;<br />c1 += c2;<br />c1就是this。代表操作对象中的接收者。<br />所以一般会这么写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> complex&amp;</span><br><span class="line">complex::<span class="keyword">operator</span> += (<span class="keyword">const</span> complex&amp; r)&#123; <span class="comment">//省略了this</span></span><br><span class="line"><span class="keyword">return</span> __doapl(<span class="keyword">this</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>return by reference语法分析<br />传递者无需知道接收者是以什么形式接收</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> complex&amp; __doapl(complex * ths,<span class="keyword">const</span> complex&amp; r)&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> *ths;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> complex&amp;</span><br><span class="line">complex::<span class="keyword">operator</span> += (<span class="keyword">const</span> complex&amp; r)&#123;</span><br><span class="line"><span class="keyword">return</span> __doapl(<span class="keyword">this</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>可以看到 第一个函数明明是 complex&amp; __doapl(...)<br />返回的却是一个value,return *ths, 这里是没有错误的，因为C++有个特性，就是return by reference,一般来说返回一个引用，会比返回一个值快很多，接收者与其接收其值，不如接收它的引用（也就是地址），而且传递者也不需要知道接收者如何接收，这样下来整个程序会快很多，避免了很多转换。<br />complex::operator += (const complex&amp; r) 也是一样，接收的是 c2 的引用，而不需要接收c2的值，直接通过引用去得到它的值，比起创建一个临时空间去转换去获取它的值要快的多。</p><hr><p>temp object(临时对象) typename();<br />刚刚说到了return by reference 比传value快，但下面这些情况，是一定不能return by reference的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="function">complex <span class="title">c1</span><span class="params">(<span class="number">2</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">complex c2;</span><br><span class="line">c2 = c1 + c2;</span><br><span class="line">c2 = c1 + <span class="number">5</span>;</span><br><span class="line">c2 = <span class="number">7</span> + c1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对应 c1 + c2</span></span><br><span class="line"><span class="keyword">inline</span> complex</span><br><span class="line"><span class="keyword">operator</span> + (<span class="keyword">const</span> complex&amp; x,<span class="keyword">const</span> complex&amp; y)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">complex</span> (<span class="built_in">real</span>(x) + <span class="built_in">real</span>(y) , <span class="built_in">imag</span>(x) + <span class="built_in">imag</span>(y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对应 c1 + 5</span></span><br><span class="line"><span class="keyword">inline</span> complex</span><br><span class="line"><span class="keyword">operator</span> + (<span class="keyword">const</span> complex&amp; x,<span class="keyword">double</span> y)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">complex</span> (<span class="built_in">real</span>(x) + y , <span class="built_in">imag</span>(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//对应 5 + c1</span></span><br><span class="line"><span class="keyword">inline</span> complex</span><br><span class="line"><span class="keyword">operator</span> + (<span class="keyword">double</span> x,<span class="keyword">const</span> complex&amp; y)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">complex</span> (x + <span class="built_in">real</span>(y) , <span class="built_in">imag</span>(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里也看出来 + 操作也分很多种不同情况。<br />为什么这里不能传引用呢，可以跟刚才的对比一下，<br />因为刚才我们传引用之后进行 += 操作之后，是将结果直接传给了C1，而现在我们没有一个地方存放结果，如果传引用，函数一结束，直接死亡，就等于什么也没做，所以我们需要一个临时complex对象，去存放结果，再将临时对象的结果返回到 c2 , 这样才是正确的，然后销毁临时对象。</p><p>注：typename() 就等于是创建临时变量，像上面的 complex( ... , ... )，也可以是int(7),double(3.65)等等...</p><hr><p>最后是关于返回类型的注意事项<br />比如说：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> complex&amp;</span><br><span class="line">complex::<span class="keyword">operator</span> += (<span class="keyword">const</span> complex&amp; r)&#123;</span><br><span class="line"><span class="keyword">return</span> __doapl(<span class="keyword">this</span>,r);</span><br><span class="line">&#125;</span><br><span class="line">改成：</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">complex::<span class="keyword">operator</span> += (<span class="keyword">const</span> complex&amp; r)&#123;</span><br><span class="line"><span class="keyword">return</span> __doapl(<span class="keyword">this</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会引起什么问题呢<br />如果说是 c1+=c2; 这样依然不会有任何问题，因为c2赋值到c1上（也就是执行__doapl()之后就完成了）<br />不用再管接下来返回的是什么类型了，所以改成void是没有问题的。<br />但如果是 c3 += c2 += c1;呢，当c1 赋值到 c2 上后，c2必须还要以 complex 类型 加到c3身上，如果返回的是void类型，那么是无法加到c3上面的，所以设计上考虑周全一点，还是会以第一种形式设计重载。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-重载&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#C-重载&quot;&gt;¶&lt;/a&gt;C++ 重载&lt;/h2&gt;
&lt;p&gt;操作符就是一种函数，是可以让你重新定义的&lt;br /&gt;比如说相加，与其自己写个相加函数 plus(u,v); 将u,v相加，&lt;br /&gt;用</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++学习" scheme="http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>C++ stack与heap</title>
    <link href="http://example.com/2021/03/26/C++stackheap/"/>
    <id>http://example.com/2021/03/26/C++stackheap/</id>
    <published>2021-03-26T09:09:14.141Z</published>
    <updated>2021-03-26T09:13:39.539Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-stack与heap"><a class="header-anchor" href="#C-stack与heap">¶</a>C++ stack与heap</h2><p>stack(栈) heap(堆)<br />Stack,是存在于某作用域(scope)的一块内存空间(memory space).例如当你调用函数，函数本身即会形成一个stack用来放置它所接收的参数，以及返回地址。</p><p>在函数本身(function body)内声明的任何变量，其所使用的内存块都取自于上述stack.</p><p>Heap，或者说system heap,是指由操作系统提供的一块global内存空间，程序可动态分配(dynamic allocated)从中获得若干区块(blocks)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span>...&#125;;</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;<span class="comment">// c1所占用的空间来自stack</span></span><br><span class="line">Complex * p = <span class="keyword">new</span> <span class="built_in">Complex</span>(<span class="number">3</span>); </span><br><span class="line"><span class="comment">//Complex(3)是个临时对象，其所占用的空间是以new自heap动态分配而得，并由p指向</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>stack objects 的生命周期</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span>...&#125;;</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c1便是所谓stack object,其生命在作用域(scope)结束时结束。<br />这种作用域内的object,又称为auto object,因为它会被自动释放。</p><p>static local objects 的生命周期</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span>...&#125;;</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Complex <span class="title">c2</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c2便是所谓static object,其生命在作用域(scope)结束时仍然存在，直到整个程序结束.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span>...&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="function">Complex <span class="title">c3</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>c3就是global object,其生命在整个程序结束之后才结束，也可以把它视为一种static object,其作用域是整个程序.</p><p>heap objects 的生命周期</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span>...&#125;;</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">Complex* p = <span class="keyword">new</span> Complex;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>p所指的是heap object,其生命在它被deleted时结束。</p><div class="cnblogs_code"><pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Complex{...};...<p>{<br>Complex</span>* p = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Complex;<br>}</span></pre></p></div><hr><p>以上出现内存泄露(memory leak)，因为当作用域结束，p所指的heap object仍然存在，但指针<br />p的生命却结束了，作用域之外再也看不到p(也就没机会delete p)了。<br />尽可能避免这种情况。</p><p>new:先分配memory，再调用ctor</p><p>Complex * pc = new Complex(1,2);</p><p>三个步骤。<br />编译器转化为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Complex * pc;</span><br><span class="line"><span class="comment">// operator new是C++中的一个特殊函数，其本质也是调用了malloc分配内存</span></span><br><span class="line"><span class="number">1.</span><span class="keyword">void</span> * mem = <span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Complex));</span><br><span class="line"><span class="number">2.</span>pc = <span class="keyword">static_cast</span>&lt;Complex*&gt;(mem); <span class="comment">//将mem指针转为Complex类型的指针</span></span><br><span class="line"><span class="number">3.</span>pc-&gt;Complex::<span class="built_in">Complex</span>(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">//构造函数 本质 Complex::Complex(pc,1,2); 这里的pc相当于this,是不可见的</span></span><br></pre></td></tr></table></figure><p>delete: 先调用 dtor,再释放memory</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String * ps = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> ps;</span><br></pre></td></tr></table></figure><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String::~<span class="built_in">String</span>(ps); <span class="comment">//析构函数</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(ps)</span></span>; <span class="comment">//释放内存，operator delete()是C++中的一个特殊函数其内部调用free(ps)</span></span><br></pre></td></tr></table></figure><p>array new 一定要搭配 array delete</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String * p = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span>[] p; <span class="comment">//唤起3次dtor</span></span><br><span class="line"></span><br><span class="line">String * p = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> p; <span class="comment">//唤起1次dtor</span></span><br></pre></td></tr></table></figure><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210113170228948-1252176890.png" alt="" loading="lazy" /></p><p>&nbsp;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-stack与heap&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#C-stack与heap&quot;&gt;¶&lt;/a&gt;C++ stack与heap&lt;/h2&gt;
&lt;p&gt;stack(栈) heap(堆)&lt;br /&gt;Stack,是存在于某作用域(scope)的</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++学习" scheme="http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>C++引用小结</title>
    <link href="http://example.com/2021/03/26/C++refer/"/>
    <id>http://example.com/2021/03/26/C++refer/</id>
    <published>2021-03-26T09:05:54.114Z</published>
    <updated>2021-03-26T09:08:38.497Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-引用小结"><a class="header-anchor" href="#C-引用小结">¶</a>C++引用小结</h2><p>从之前的博客中有提到，C++有两种特性</p><p>return by value&nbsp; &nbsp;and&nbsp; &nbsp;return by reference</p><p>一种是返回值，一种是返回引用</p><p>并且，在一般情况下，传引用比传值效率更高。</p><hr><p>先说说引用是什么，引用用的是&amp;符号，&amp;符号既可以用来当引用，也可以用来当取地址符，只不过使用方法不同。</p><p>引用的本质是别名。</p><p>引用的基本使用方法是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> &amp; a = b;</span><br></pre></td></tr></table></figure><p>此时a就是b的引用，也就是b的别名，那可能会发现一个问题，我为什么不直接用b，而去特意创建一个别名去使用b呢。</p><p>这里去思考一下typedef的作用就知道了。</p><hr><p>我们可以用它来接收返回值，并且创建引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> complex&amp;</span><br><span class="line">__doaml (complex* ths, <span class="keyword">const</span> complex&amp; r)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">double</span> f = ths-&gt;re * r.re - ths-&gt;im * r.im;</span><br><span class="line">  ths-&gt;im = ths-&gt;re * r.im + ths-&gt;im * r.re;</span><br><span class="line">  ths-&gt;re = f;</span><br><span class="line">  <span class="keyword">return</span> *ths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传递者是*ths，是一个&ldquo;实体&rdquo;，而接收者是 complex&amp; , 也就是一个引用，其实这里也可以直接接收值，但如果之后还要使用*ths,这里的用引用接收之后使用，效率会快上很多。</p><p>（可以把这整个函数想象成返回了一个 *ths 的引用）</p><hr><p>引用和指针是差不多的，因为</p><p>T&amp; ... = T* const ...&nbsp; 指针无法改变</p><p>const T&amp; ... = const T* const ... 指针无法改变，指针指向的值也无法改变</p><hr><p>所以引用就是一个不能改变指向的指针，传递的也是地址。</p><hr><p>并且引用能够解决 派生类切割问题。</p><p>比如说有两个类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     string name;</span><br><span class="line">     <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span>:</span> <span class="keyword">public</span> person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string classid;<span class="comment">//班级名</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printattribute</span><span class="params">(person p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; p.name;</span><br><span class="line">  cout &lt;&lt; p.classid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">//假设</span></span><br><span class="line">student s;</span><br><span class="line"><span class="built_in">printattribute</span>(s);</span><br></pre></td></tr></table></figure><p>当派生类对象s 传入到 printattribute()里去后，会切割掉自己原本有的属性，变成一个原原本本的基类，此时将没有classid这个属性。</p><p>如果传的是引用，则可以解决这个问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printattribute</span><span class="params">(<span class="keyword">const</span> person&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; p.name;</span><br><span class="line">  cout &lt;&lt; p.classid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样 p 的行为就和传入到函数的真实类型一致了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-引用小结&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#C-引用小结&quot;&gt;¶&lt;/a&gt;C++引用小结&lt;/h2&gt;
&lt;p&gt;从之前的博客中有提到，C++有两种特性&lt;/p&gt;
&lt;p&gt;return by value&amp;nbsp; &amp;nbsp;and&amp;nbsp</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++学习" scheme="http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>C++组合与继承</title>
    <link href="http://example.com/2021/03/26/C++zuhejicheng/"/>
    <id>http://example.com/2021/03/26/C++zuhejicheng/</id>
    <published>2021-03-26T08:55:49.033Z</published>
    <updated>2021-03-26T08:59:18.739Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-组合与继承"><a class="header-anchor" href="#C-组合与继承">¶</a>C++组合与继承</h2><p>组合与继承</p><p>Composition(复合)，表示has-a<br />复合关系简单来说，就是一个类中有另外一个类，A类中需要实现的东西，完全可以由B类中的方法来实现的话，就不需要在A类中去写，而直接去调用B类中的方法就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Sequence</span> =</span> deque&lt;T&gt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">queue</span>&#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">sequence c; <span class="comment">//底层容器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">empty</span>();&#125;</span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">size</span>();&#125;</span><br><span class="line"><span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">front</span>();&#125;</span><br><span class="line"><span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">back</span>();&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span> </span>&#123;c.<span class="built_in">push_back</span>(x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;c.<span class="built_in">pop_front</span>();&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为单向队列类queue中的一些操作完全可以由双端队列类deque中的方法去实现，所以可以在queue类中直接加入底层容器去调用deque中的方法，而不是自己实现，这就是复合。</p><hr><p>内存关系：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">queue</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">deque&lt;T&gt; c;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">deque</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Itr&lt;T&gt; start;</span><br><span class="line">Itr&lt;T&gt; finish;</span><br><span class="line">T** map;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> map_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Itr</span>&#123;</span></span><br><span class="line">T* cur;</span><br><span class="line">T* first;</span><br><span class="line">T* last;</span><br><span class="line">T** node;</span><br><span class="line">....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>算内存，由内而外，首先看结构体Itr，一个指针4字节，所以sizeof(Itr) = 4*4 =16<br />然后在 class deque中，有两个Itr结构体 加一个指针变量一个整形变量，所以sizeof(deque) = 16 * 2 + 4 + 4 = 40;<br />同理，所以sizeof(queue) = 40;</p><p>Composition(复合)关系下的构造和析构</p><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114110805972-646031218.png" alt="" loading="lazy" /></p><hr><p>构造由内而外<br />Container 的构造函数首先调用 Component 的 default 构造函数，然后才执行自己。</p><div class="cnblogs_code"><pre>Container::Container(...): Component() {...}; <span style="color: #008000;">//</span><span style="color: #008000;">因为Component的构造函数可能不止一个，编译器不知道调用哪个，所以只会调用缺省构造函数，除非自己指定参数。</span></pre></div><p>析构由外而内<br />Container 的析构函数首先执行自己，然后才调用Component的析构函数</p><div class="cnblogs_code"><pre>Container::~Container(...){... ~Component()};</pre></div><p>组装都是由内而外的，拆开肯定只能由外而内。</p><p><br />Delegation(委托).Composition by reference;<br />委托其实跟复合很像，说实在点也就是定义上有点区别。<br />不过委托就是Composition(复合) by reference，看这个应该就能明白了。</p><hr><h2 id="code￼2"><a class="header-anchor" href="#code￼2">¶</a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file String.hpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringRep</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">String</span>();</span><br><span class="line"><span class="built_in">String</span>(<span class="keyword">const</span> <span class="keyword">char</span> * s);</span><br><span class="line"><span class="built_in">String</span>(<span class="keyword">const</span> String&amp; s);</span><br><span class="line">String &amp;<span class="keyword">operator</span> = (<span class="keyword">const</span> String&amp; s);</span><br><span class="line">~<span class="built_in">String</span>();</span><br><span class="line">....</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">StringRep * rep; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file String.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;String.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringRep</span>&#123;</span></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span>;</span></span><br><span class="line"><span class="built_in">StringRep</span>(<span class="keyword">const</span> <span class="keyword">char</span> * s);</span><br><span class="line">~<span class="built_in">StringRep</span>();</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">char</span> * rep;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String::<span class="built_in">String</span>()&#123;...&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>通过调用 StringRep指针来获取到字符串"Hello"，通过下图就很明显能够看出。</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;<img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114110929461-942601926.png" alt="" loading="lazy" /></p><hr><p><br />这种模式的优点就是无论你怎么修改StringRep 对客户所需要看到的Hello都不影响，甚至可以更换委托对象。维护和更新起来特别方便。<br />可以说这两者之间就是 Handle 与 Body 的关系。</p><p>Inheritance(继承) ,表示is-a</p><div class="cnblogs_code"><pre><span style="color: #0000ff;">struct</span><span style="color: #000000;"> _List_node_base{_List_node_base</span>*<span style="color: #000000;"> _M_next;_List_node_base</span>*<span style="color: #000000;"> _M_prev;};<p>template</span>&lt;typename _Tp&gt;<br><span style="color: #0000ff;">struct</span><span style="color: #000000;"> _List_node<br>:</span><span style="color: #0000ff;">public</span><span style="color: #000000;"> _List_node_base<br>{<br>_Tp _M_data;<br>};</span></pre></p></div><hr><p>语法上继承有3种方法，最常用的就是 :public ...<br />其实struct和class是非常相似的，所以这里拿struct举例，继承是is-a的关系<br />继承在面向对象中的概念来说，就是父类与子类，比如说人类分男人，女人，人类是父类，男人与女人是子类。<br />拥有父类-人类的属性的同时，多了自己的属性。</p><p>构造由内而外</p><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114110901434-1450263716.png" alt="" loading="lazy" /></p><hr><p><br />Derived 的构造函数首先调用Base的 default 构造函数，然后才执行自己。</p><div class="cnblogs_code"><pre>Deruved::Derived(...) : Base() {...};</pre></div><p>析构由外而内<br />Derived 的析构函数首先执行自己，然后才调用Base的析构函数。</p><div class="cnblogs_code"><pre>Derived::~Derived(...){...~Base()};</pre></div><hr><p>注意：base class 的 dtor必须是virtual,否则会出现 undefined behaviod<br />养成习惯，每当创建的类有可能会作为基类衍生子类时，最好把这个类的析构函数设为虚函数(virtual)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-组合与继承&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#C-组合与继承&quot;&gt;¶&lt;/a&gt;C++组合与继承&lt;/h2&gt;
&lt;p&gt;组合与继承&lt;/p&gt;
&lt;p&gt;Composition(复合)，表示has-a&lt;br /&gt;复合关系简单来说，就是一个类中有另外</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++学习" scheme="http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
