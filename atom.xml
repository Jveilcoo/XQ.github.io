<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-04-16T07:24:02.723Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OpenGL(三) 分离并使用着色器</title>
    <link href="http://example.com/2021/04/16/OpenGL-Shader/"/>
    <id>http://example.com/2021/04/16/OpenGL-Shader/</id>
    <published>2021-04-16T03:33:02.309Z</published>
    <updated>2021-04-16T07:24:02.723Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OpenGL-三-分离并使用着色器"><a class="header-anchor" href="#OpenGL-三-分离并使用着色器">¶</a>OpenGL(三) 分离并使用着色器</h2><p><kbd><font size=2 color=red>注：本文仅供自己以及OPENGL初学者共同学习进步，并无实际教学意义，不过会对自己学习中遇到的关键点加上个人解释。应该会对初学者有所帮助，如有错误请指正！</font></kbd></p><hr><p>继续沿用上章的代码，我们发现着色器代码写在主代码文件中看上去非常冗余，并且难以分析，所以我们可以建立一个专属处理Shader的类，封装处理Shader的操作，这样我们在使用Shader的时候就只需要短短一两行代码就可以实现。</p><p>依旧是在VS2017下完成以下操作。</p><p>先不管我们的main.cpp(主执行代码)，右键我们的项目名称-&gt;添加-&gt;类，把类名设置成Shader,其他设置一律用默认，点击确定即可，VS2017就会帮我们建立好一个Shader.h 以及 Shader.cpp，来分析一下我们需要的东西，我们的目的是用从txt文档中取得着色器代码，并且能够编译使用它，那么Shader的构建函数就应该传入txt文档的路径，由于我们只使用了顶点着色器与片段着色器，所以只需要传入两个文件的路径即可，用const char * 接收(注意：这里必须是const类型)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Shader</span>(<span class="keyword">const</span> <span class="keyword">char</span> * vertexPath, <span class="keyword">const</span> <span class="keyword">char</span> * fragmentPath);</span><br></pre></td></tr></table></figure><p>然后看向Shader.cpp,既然是从文件读取内容，当然就要用到C++的文件流了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Shader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>我们要从txt文档中读取内容要经过以下几个步骤：</p><img src="https://note.youdao.com/yws/api/personal/file/WEB374c7ed0965214efa376c4d293cae08f?method=download&shareKey=80beb86fade23ceda6f5821c03d4b0fc">  <p>shader文件从硬盘被读取到内存里，放在文件缓冲区，然后转换到string缓冲,再由string字符接收内容，然后由于CPU只认得char,所以最后再将string转为char *,内容接收就完成了。</p><hr><p>所以我们是不是需要文件缓冲，字符缓冲与string还有char *,看下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Shader.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Shader</span>(<span class="keyword">const</span> <span class="keyword">char</span> * vertexPath, <span class="keyword">const</span> <span class="keyword">char</span> * fragmentPath);</span><br><span class="line">~<span class="built_in">Shader</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::string vertexString;</span><br><span class="line">std::string fragmentString;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * vertexSource;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * fragmentSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> ID; <span class="comment">// 程序ID</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkCompileErrors</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> ID, std::string type)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">use</span><span class="params">()</span></span>; <span class="comment">//激活程序</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//shader.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Shader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">Shader::<span class="built_in">Shader</span>(<span class="keyword">const</span> <span class="keyword">char</span> * vertexPath,<span class="keyword">const</span> <span class="keyword">char</span> * fragmentPath)</span><br><span class="line">&#123;</span><br><span class="line">ifstream vertexFile;<span class="comment">//顶点着色器 信息</span></span><br><span class="line">ifstream fragmentFile;<span class="comment">//片段着色器 信息</span></span><br><span class="line">stringstream vertexSStream;</span><br><span class="line">stringstream fragmentSStream;</span><br><span class="line"></span><br><span class="line">vertexFile.<span class="built_in">open</span>(vertexPath);<span class="comment">//读取内容到文件缓冲</span></span><br><span class="line">fragmentFile.<span class="built_in">open</span>(fragmentPath);<span class="comment">//同上</span></span><br><span class="line"></span><br><span class="line">vertexFile.<span class="built_in">exceptions</span>(ifstream::failbit || ifstream::badbit);<span class="comment">//检测是否读取成功</span></span><br><span class="line">fragmentFile.<span class="built_in">exceptions</span>(ifstream::failbit || ifstream::badbit);<span class="comment">//同上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!vertexFile.<span class="built_in">is_open</span>()|| !fragmentFile.<span class="built_in">is_open</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">exception</span>(<span class="string">&quot;open Shader file error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vertexSStream &lt;&lt; vertexFile.<span class="built_in">rdbuf</span>();</span><br><span class="line">fragmentSStream &lt;&lt; fragmentFile.<span class="built_in">rdbuf</span>();  <span class="comment">//file buffer -&gt; string buffer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>-&gt;vertexString = vertexSStream.<span class="built_in">str</span>();</span><br><span class="line"><span class="keyword">this</span>-&gt;fragmentString = fragmentSStream.<span class="built_in">str</span>(); <span class="comment">//string buffer -&gt; string</span></span><br><span class="line"></span><br><span class="line">vertexSource = vertexString.<span class="built_in">c_str</span>();</span><br><span class="line">fragmentSource = fragmentString.<span class="built_in">c_str</span>(); <span class="comment">// string -&gt; char</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面这几段就是我们之前在主执行代码里创建着色器程序的过程</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> vertex, fragment;</span><br><span class="line">vertex = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER);</span><br><span class="line"><span class="built_in">glShaderSource</span>(vertex, <span class="number">1</span>, &amp;vertexSource, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">glCompileShader</span>(vertex);</span><br><span class="line"></span><br><span class="line">fragment = <span class="built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);</span><br><span class="line"><span class="built_in">glShaderSource</span>(fragment, <span class="number">1</span>, &amp;fragmentSource, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">glCompileShader</span>(fragment);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>-&gt;ID = <span class="built_in">glCreateProgram</span>();<span class="comment">//ID就是我们使用的着色器程序名字</span></span><br><span class="line"><span class="built_in">glAttachShader</span>(<span class="keyword">this</span>-&gt;ID, vertex);</span><br><span class="line"><span class="built_in">glAttachShader</span>(<span class="keyword">this</span>-&gt;ID, fragment);</span><br><span class="line"><span class="built_in">glLinkProgram</span>(<span class="keyword">this</span>-&gt;ID);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glDeleteShader</span>(vertex);</span><br><span class="line"><span class="built_in">glDeleteShader</span>(fragment);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> std::exception&amp; ex)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(ex.<span class="built_in">what</span>());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Shader::use</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">glUseProgram</span>(<span class="keyword">this</span>-&gt;ID); <span class="comment">//使用着色器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Shader::~<span class="built_in">Shader</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后接下来我们就可以把主代码那些关于着色器的代码全部去掉了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GLEW_STATIC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;Shader.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> vertices[] = &#123;  <span class="comment">//三角形是逆时针构造  所以逆时针为正面，顺时针为反面，原因参考 法向量</span></span><br><span class="line"><span class="comment">//pos//rgb</span></span><br><span class="line"><span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,<span class="comment">//0</span></span><br><span class="line"> <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,<span class="comment">//1</span></span><br><span class="line"> <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span> <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> indices[] = &#123;</span><br><span class="line"><span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow * window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">glfwInit</span>();</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);<span class="comment">//major version</span></span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);<span class="comment">//minor version</span></span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//OpenGL GLFW Window</span></span><br><span class="line">GLFWwindow * window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;demo&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (window == <span class="literal">NULL</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Fail to create&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">glfwTerminate</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Initg GLFW</span></span><br><span class="line">glewExperimental = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Init GLEW failed&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">glfwTerminate</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">600</span>);</span><br><span class="line"></span><br><span class="line">Shader * testShader = <span class="keyword">new</span> <span class="built_in">Shader</span>(<span class="string">&quot;vertexSource.txt&quot;</span>, <span class="string">&quot;fragmentSource.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VAO;</span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO); <span class="comment">//绑定</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> EBO;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;EBO);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="built_in"><span class="keyword">sizeof</span></span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="comment">//以使用glGenBuffers函数和一个缓冲ID生成一个VBO对象</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VBO;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO); </span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line"></span><br><span class="line"><span class="comment">//接下来就可以正式使用两个shader了</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">3</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>)));</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in"><span class="keyword">sizeof</span></span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">processInput</span>(window);<span class="comment">//窗口模板载入</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3</span>, <span class="number">0.3</span>, <span class="number">1.0f</span>);<span class="comment">//背景色</span></span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);<span class="comment">//清除缓冲</span></span><br><span class="line"></span><br><span class="line">testShader-&gt;<span class="built_in">use</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line"><span class="comment">//glDrawArrays(GL_TRIANGLES, 0,6);</span></span><br><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">3</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"><span class="built_in">glfwPollEvents</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">glfwTerminate</span>();</span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow * window)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">glfwSetWindowShouldClose</span>(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然着色器代码已经删除了，那么我们就需要两个txt文档来写着色器代码.<br>可以直接到VS2017右键项目-&gt;添加-&gt;新建项-&gt;实用工具-&gt;文档,创建两个文档，一个写vertexShader,一个写fragmentShader,然后你会发现你的资源文件多了两个txt文档，把之前的着色器代码复制粘贴进去，去掉双引号和&quot;\n&quot;(不去干净就会出错)，就OK了。</p><hr><p>然后我们到主执行代码程序里面去，创建Shader对象，初始化路径，使用use方法就行啦。<br>还有一点要注意，创建Shader对象时,必须是在初始化glad或glew之后才能创建。</p><p>附上ShaderSource代码：</p><hr><p>vertexSource.txt</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line">layout (location = <span class="number">1</span>) in vec3 aColor;</span><br><span class="line">out vec3 vertexColor;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">vertexColor = aColor;</span><br><span class="line">gl_Position = vec4(aPos.x, aPos.y, aPos.z, <span class="number">1.0</span>);&#125;</span><br></pre></td></tr></table></figure><p>fragmentSource.txt</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line">in vec3 vertexColor;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">FragColor = vec4(vertexColor,<span class="number">1.0</span>);&#125;</span><br></pre></td></tr></table></figure><hr><p>最后再补充一下代码，可以看到我们的顶点数组多了些内容，也就是每个顶点的RGB值，还记得我们如何告诉OpenGL处理这些数据吗</p><img src="https://learnopengl-cn.github.io/img/01/05/vertex_attribute_pointer_interleaved.png"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">3</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>)));</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>我们将RGB值放在了我们绑定的VAO的1号位置，然后由于现在每一个顶点数据变成了6个，所以第四个参数改成了6*sizeof(float);</p><p>可以看到我们的vertexShader里面也多了个aColor属性，然后将它传入了fragmentShader.<br>输出效果如下：</p><img src="https://note.youdao.com/yws/api/personal/file/WEB783353f7ed09015a5e59e6d731e3d61d?method=download&shareKey=60d1f5a652727e9a8df353781b2d8fd2"><p>我们要记得一个地方，就是如果颜色不对，一般就是fragmentShader出问题了,如果连图形都没有，一般就是vertexShader出问题了,然后检查两个着色器的代码。</p><p>那我们希望知道着色器代码编译出错的点该怎么办，我们只需要使用OpenGL的函数来获取Shader的编译信息就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Shader::checkCompileErrors</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> ID, std::string type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> success;</span><br><span class="line"><span class="keyword">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (type != <span class="string">&quot;PROGRAM&quot;</span>) <span class="comment">//着色器编译错误</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">glGetShaderiv</span>(ID, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line"><span class="keyword">if</span> (!success)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">glGetShaderInfoLog</span>(ID,<span class="number">512</span>,<span class="literal">NULL</span>,infoLog);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;shader compile error: &quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>  <span class="comment">//着色器程序链接错误</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">glGetProgramiv</span>(ID, GL_LINK_STATUS, &amp;success);</span><br><span class="line"><span class="keyword">if</span> (!success)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">glGetProgramInfoLog</span>(ID, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;program compile error: &quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要我们着色器编译出错，它就会在窗口打印出错误信息。这样我们就能知道错误的详细情况了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;OpenGL-三-分离并使用着色器&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#OpenGL-三-分离并使用着色器&quot;&gt;¶&lt;/a&gt;OpenGL(三) 分离并使用着色器&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;&lt;font size=2 color=red&gt;注：</summary>
      
    
    
    
    <category term="OPENGL" scheme="http://example.com/categories/OPENGL/"/>
    
    
    <category term="OPENGL学习" scheme="http://example.com/tags/OPENGL%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 263. 丑数</title>
    <link href="http://example.com/2021/04/12/leetcode263/"/>
    <id>http://example.com/2021/04/12/leetcode263/</id>
    <published>2021-04-12T14:21:36.607Z</published>
    <updated>2021-04-12T14:23:32.273Z</updated>
    
    <content type="html"><![CDATA[<h2 id="263-丑数"><a class="header-anchor" href="#263-丑数">¶</a>263. 丑数</h2><p>给你一个整数 n ，请你判断 n 是否为 丑数 。如果是，返回 true ；否则，返回 false 。</p><p>丑数 就是只包含质因数 2、3 和/或 5 的正整数。</p><p></p><p>示例 1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：<span class="number">6</span> = <span class="number">2</span> × <span class="number">3</span></span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">8</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：<span class="number">8</span> = <span class="number">2</span> × <span class="number">2</span> × <span class="number">2</span></span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">14</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：<span class="number">14</span> 不是丑数，因为它包含了另外一个质因数 <span class="number">7</span> 。</span><br></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：<span class="number">1</span> 通常被视为丑数。</span><br></pre></td></tr></table></figure><p>提示：</p><p>-2^31 &lt;= n &lt;= 2^31 - 1</p><hr><p>一直使用2，3，5整除就行，直到等于1，不行则返回false。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n == <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>)n/=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(n % <span class="number">3</span> == <span class="number">0</span>)n/=<span class="number">3</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(n % <span class="number">5</span> == <span class="number">0</span>)n/=<span class="number">5</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;263-丑数&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#263-丑数&quot;&gt;¶&lt;/a&gt;263. 丑数&lt;/h2&gt;
&lt;p&gt;给你一个整数 n ，请你判断 n 是否为 丑数 。如果是，返回 true ；否则，返回 false 。&lt;/p&gt;
&lt;p&gt;丑数 就</summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 264. 丑数 II</title>
    <link href="http://example.com/2021/04/12/leetcode264/"/>
    <id>http://example.com/2021/04/12/leetcode264/</id>
    <published>2021-04-12T14:20:30.069Z</published>
    <updated>2021-04-12T14:33:08.009Z</updated>
    
    <content type="html"><![CDATA[<h2 id="264-丑数-II"><a class="header-anchor" href="#264-丑数-II">¶</a>264. 丑数 II</h2><p>给你一个整数 n ，请你找出并返回第 n 个 丑数 。</p><p>丑数 就是只包含质因数 2、3 和/或 5 的正整数。</p><p></p><p>示例 1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">10</span></span><br><span class="line">输出：<span class="number">12</span></span><br><span class="line">解释：[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">12</span>] 是由前 <span class="number">10</span> 个丑数组成的序列。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：<span class="number">1</span> 通常被视为丑数。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;= n &lt;= 1690</li></ul><p>很明显，判断每一个数是否是丑数，再判断它是第几个明显不现实，绝对超时，所以要提前构造每个数的2，3，5倍，然后直到这是第n个丑数，再返回。</p><p>构造方法就是建立一个dp数组，dp[i-1]代表的这是第i个丑数，初始化dp[0] = 1,因为第一个丑数是1，然后我们使用3个下标p2=0,p3=0,p5=0，去分别代表2倍，3倍，5倍，如何构造第二个丑数呢，我们要使2<em>dp[p2]，3</em>dp[p3],5<em>dp[p5],很明显，其中最小的就是第2个丑数，3</em>dp[p3],5*[p5]一定是后面的丑数了（只对这次而言），然后p2下标加一，第三个丑数理所当然的应该是3<em>dp[p3],算嘛，2</em>dp[p2],3<em>dp[p3],5</em>dp[p5],中最小的一定是3*dp[p3]，而我们不用算，我们只需要用min来取得每次一最小的丑数就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p2 = <span class="number">0</span> , p3 = <span class="number">0</span> , p5 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n,<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(<span class="built_in">min</span>(dp[p2]*<span class="number">2</span>,dp[p3]*<span class="number">3</span>),dp[p5]*<span class="number">5</span>);</span><br><span class="line">            <span class="keyword">if</span>(dp[p2]*<span class="number">2</span> == dp[i])p2++; <span class="comment">//以下三行都是防止大小相等的元素构成两个相同丑数</span></span><br><span class="line">            <span class="keyword">if</span>(dp[p3]*<span class="number">3</span> == dp[i])p3++;</span><br><span class="line">            <span class="keyword">if</span>(dp[p5]*<span class="number">5</span> == dp[i])p5++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;264-丑数-II&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#264-丑数-II&quot;&gt;¶&lt;/a&gt;264. 丑数 II&lt;/h2&gt;
&lt;p&gt;给你一个整数 n ，请你找出并返回第 n 个 丑数 。&lt;/p&gt;
&lt;p&gt;丑数 就是只包含质因数 2、3 和/或</summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 179. 最大数</title>
    <link href="http://example.com/2021/04/12/leetcode179/"/>
    <id>http://example.com/2021/04/12/leetcode179/</id>
    <published>2021-04-12T14:02:51.355Z</published>
    <updated>2021-04-12T14:18:49.558Z</updated>
    
    <content type="html"><![CDATA[<h2 id="179-最大数"><a class="header-anchor" href="#179-最大数">¶</a>179. 最大数</h2><p>给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。</p><p>注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p><p></p><p>示例 1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">10</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="string">&quot;210&quot;</span>  </span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">30</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">9</span>]</span><br><span class="line">输出：<span class="string">&quot;9534330&quot;</span></span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>]</span><br><span class="line">输出：<span class="string">&quot;1&quot;</span></span><br></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">10</span>]</span><br><span class="line">输出：<span class="string">&quot;10&quot;</span></span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;= nums.length &lt;= 100</li><li>0 &lt;= nums[i] &lt;= 109</li></ul><hr><p>刚看到这题的想法是，找数字的优先级，然后从小往大排，比如34，3谁应该排在后面，一开始认为是从数字的个位开始遍历，34的个位为4，3的个位为3，那么3应该排在34的后面，形成了343，甚至满足前面4个示例，比如示例2，[3,30,34,5,9] 按个位比较后得到[30,3,34,5,9]，那么从小到大排我们得到<br>“9&lt;-5&lt;-34&lt;-3&lt;-30”，与答案符合，但是最后发现这并不是所有的最佳解，还是会有特殊情况，并不满足这个排序条件。</p><p>正确解法应该是先合并，后考虑谁大，最后再排序。<br>将nums数字里面的类容转化成字符串然后放进变量类型为string的str数组里。<br>使用sort的快排加上自定义函数，利用string的特性去让它自己判断大小，比如34和3，会直接比较343和334，343比较大，然后来排序。</p><p>最后是考虑，假如数组里全是0的话，那么我会得到&quot;000…“,所以判断，假如数组第一位是0的话，意味着后面都是0，那么我们直接返回&quot;0”。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> string&amp; a, <span class="keyword">const</span> string&amp; b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b &gt; b+a;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">largestNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; str;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            str.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(x));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>(),cmp);</span><br><span class="line"></span><br><span class="line">        string res =<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : str)</span><br><span class="line">        &#123;</span><br><span class="line">            res+=x;  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>? <span class="string">&quot;0&quot;</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;179-最大数&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#179-最大数&quot;&gt;¶&lt;/a&gt;179. 最大数&lt;/h2&gt;
&lt;p&gt;给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。&lt;/p&gt;
&lt;p&gt;注意：输出结果</summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 154.寻找旋转排序数组中的最小值 II</title>
    <link href="http://example.com/2021/04/09/leetcode154/"/>
    <id>http://example.com/2021/04/09/leetcode154/</id>
    <published>2021-04-09T01:06:34.828Z</published>
    <updated>2021-04-09T01:32:08.983Z</updated>
    
    <content type="html"><![CDATA[<h2 id="154-寻找旋转排序数组中的最小值-II"><a class="header-anchor" href="#154-寻找旋转排序数组中的最小值-II">¶</a>154. 寻找旋转排序数组中的最小值 II</h2><p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到：<br>若旋转 4 次，则可以得到 [4,5,6,7,0,1,4]<br>若旋转 7 次，则可以得到 [0,1,4,4,5,6,7]<br>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</p><p>给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。</p><p>示例 1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]  </span><br><span class="line">输出：<span class="number">1</span>  </span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>]  </span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>n == nums.length</li><li>1 &lt;= n &lt;= 5000</li><li>-5000 &lt;= nums[i] &lt;= 5000</li><li>nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转</li></ul><p>进阶：</p><p>这道题是 寻找旋转排序数组中的最小值 的延伸题目。<br>允许重复会影响算法的时间复杂度吗？会如何影响，为什么？</p><hr><p>由于有重复数字，所以我们需要恢复二段性，确立二分区间。<br>然后就直接跟 &lt;153.寻找旋转排序数组中的最小值&gt; 一样的操作就行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = size - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//恢复二段性</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[right] == nums[right<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            right--;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + ((right - left)/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= nums[<span class="number">0</span>])</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left == size?nums[<span class="number">0</span>]:nums[left];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>突然发现一年前写过这道题，这道题难度还是困难，但是当时直接就用了暴力法搜索了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;154-寻找旋转排序数组中的最小值-II&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#154-寻找旋转排序数组中的最小值-II&quot;&gt;¶&lt;/a&gt;154. 寻找旋转排序数组中的最小值 II&lt;/h2&gt;
&lt;p&gt;已知一个长度为 n 的数组，预先按照升序排</summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 153.寻找旋转排序数组中的最小值</title>
    <link href="http://example.com/2021/04/09/leecode153/"/>
    <id>http://example.com/2021/04/09/leecode153/</id>
    <published>2021-04-09T00:48:33.343Z</published>
    <updated>2021-04-09T01:06:17.796Z</updated>
    
    <content type="html"><![CDATA[<h2 id="153-寻找旋转排序数组中的最小值"><a class="header-anchor" href="#153-寻找旋转排序数组中的最小值">¶</a>153. 寻找旋转排序数组中的最小值</h2><p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：<br>若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]<br>若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]<br>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</p><p>给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。</p><p>示例 1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：原数组为 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] ，旋转 <span class="number">3</span> 次得到输入数组。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：原数组为 [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>] ，旋转 <span class="number">4</span> 次得到输入数组。</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">17</span>]</span><br><span class="line">输出：<span class="number">11</span></span><br><span class="line">解释：原数组为 [<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">17</span>] ，旋转 <span class="number">4</span> 次得到输入数组。</span><br></pre></td></tr></table></figure><p>提示：</p><p>n == nums.length<br>1 &lt;= n &lt;= 5000<br>-5000 &lt;= nums[i] &lt;= 5000<br>nums 中的所有整数 互不相同<br>nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转</p><hr><p>leetcode这几天应该是想要我们熟悉使用二分法，全是搜索查找题，这题比较简单，跟昨天题目差不多，因为没有相同值，所以不需要手动恢复二段性，直接用二分法找到分断点，返回即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>)<span class="keyword">return</span> <span class="built_in">min</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + ((right - left)/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= nums[<span class="number">0</span>])</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[<span class="number">0</span>])</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left == n?nums[<span class="number">0</span>]:nums[left];</span><br><span class="line">        <span class="comment">//当left = n时，证明没有旋转，直接返回nums[0]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;153-寻找旋转排序数组中的最小值&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#153-寻找旋转排序数组中的最小值&quot;&gt;¶&lt;/a&gt;153. 寻找旋转排序数组中的最小值&lt;/h2&gt;
&lt;p&gt;已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 </summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 81.搜索旋转排序数组 II</title>
    <link href="http://example.com/2021/04/07/leetcode81/"/>
    <id>http://example.com/2021/04/07/leetcode81/</id>
    <published>2021-04-07T08:07:41.540Z</published>
    <updated>2021-04-07T09:00:27.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="81-搜索旋转排序数组-II"><a class="header-anchor" href="#81-搜索旋转排序数组-II">¶</a>81. 搜索旋转排序数组 II</h2><p>已知存在一个按非降序排列的整数数组 <kbd>nums</kbd> ，数组中的值不必互不相同。</p><p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。</p><p>给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。</p><p>示例 1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">0</span></span><br><span class="line">输出：<span class="literal">true</span>  </span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">3</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;= nums.length &lt;= 5000</li><li>-10^4 &lt;= nums[i] &lt;= 10^4</li><li>题目数据保证 nums 在预先未知的某个下标上进行了旋转</li><li>-10^4 &lt;= target &lt;= 10^4</li></ul><p>进阶：</p><p>这是 搜索旋转排序数组 的延伸题目，本题中的 nums  可能包含重复元素。<br>这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？</p><hr><p>搜索题，二分必须的…所以我们只需要稍微考虑下最坏情况是什么，由于它是一个非递减数组，意思就是该数组里面会有相同的数字，有相同的数字意味着什么呢，意味着最坏情况下时间复杂度为O(n)，因为，我们在确定二分区间的时候，是一个在不断判断两个数字大小的，如果两个数字一直相同，会导致我们区间最后锁定在一个数上，而此时所有数已经遍历完了，所以最坏是O(n)，不过确定区间了复杂度就是O(logn)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right&amp;&amp;nums[<span class="number">0</span>] == nums[right<span class="number">-1</span>])right--;<span class="comment">//将相同的数剔除，控制二分区间</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到旋转点</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + ((right - left)/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= nums[<span class="number">0</span>])</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[<span class="number">0</span>])</span><br><span class="line">                right = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//此时left在旋转线右边，right在旋转线左边</span></span><br><span class="line">        <span class="comment">//直接在两个区间内使用二分法寻找。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">binarySearch</span>(nums,<span class="number">0</span>,left<span class="number">-1</span>,target)||<span class="built_in">binarySearch</span>(nums,left,n<span class="number">-1</span>,target);</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + ((right - left)/<span class="number">2</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)right = mid<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;81-搜索旋转排序数组-II&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#81-搜索旋转排序数组-II&quot;&gt;¶&lt;/a&gt;81. 搜索旋转排序数组 II&lt;/h2&gt;
&lt;p&gt;已知存在一个按非降序排列的整数数组 &lt;kbd&gt;nums&lt;/kbd&gt; ，数组中的</summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 80.删除有序数组中的重复项 II</title>
    <link href="http://example.com/2021/04/07/leetcode80/"/>
    <id>http://example.com/2021/04/07/leetcode80/</id>
    <published>2021-04-07T08:01:49.245Z</published>
    <updated>2021-04-07T08:07:21.737Z</updated>
    
    <content type="html"><![CDATA[<h2 id="80-删除有序数组中的重复项-II"><a class="header-anchor" href="#80-删除有序数组中的重复项-II">¶</a>80. 删除有序数组中的重复项 II</h2><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><p></p><p>说明：</p><p>为什么返回数值是整数，但输出的答案是数组呢？</p><p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">removeDuplicates</span>(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="built_in">print</span>(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例一：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">5</span>, nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">解释：函数应返回新长度 length = <span class="number">5</span>, 并且原数组的前五个元素被修改为 <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span> 。 不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p>示例二:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">7</span>, nums = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line">解释：函数应返回新长度 length = <span class="number">7</span>, 并且原数组的前五个元素被修改为 <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span> 。 不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;= nums.length &lt;= 3 * 10^4</li><li>-10^4 &lt;= nums[i] &lt;= 10^4</li><li>nums 已按升序排列</li></ul><hr><p>由于我们知道该数组已经是升序的了，所以相同数字一定是相邻的，所以我们只需要用一个变量cnt，判断遇到的数字是否相同，相同则cnt++，当cnt超过2则删除当前数字并且cnt减一，遇到不同数字cnt直接置一。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> st = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; nums.<span class="built_in">size</span>() ;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == st)</span><br><span class="line">                cnt++;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">                st = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nums.<span class="built_in">erase</span>(nums.<span class="built_in">begin</span>() + i);</span><br><span class="line">                cnt--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;80-删除有序数组中的重复项-II&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#80-删除有序数组中的重复项-II&quot;&gt;¶&lt;/a&gt;80. 删除有序数组中的重复项 II&lt;/h2&gt;
&lt;p&gt;给你一个有序数组 nums ，请你 原地 删除重复出现的元素</summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 88.合并两个有序数组</title>
    <link href="http://example.com/2021/04/05/leetcode88/"/>
    <id>http://example.com/2021/04/05/leetcode88/</id>
    <published>2021-04-05T12:34:54.198Z</published>
    <updated>2021-04-05T13:07:50.690Z</updated>
    
    <content type="html"><![CDATA[<h2 id="88-合并两个有序数组"><a class="header-anchor" href="#88-合并两个有序数组">¶</a>88. 合并两个有序数组</h2><p>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。</p><p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。</p><p>示例一：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], m = <span class="number">3</span>, nums2 = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>], n = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure><p>示例二：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>], m = <span class="number">1</span>, nums2 = [], n = <span class="number">0</span></span><br><span class="line">输出：[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>nums1.length == m + n</li><li>nums2.length == n</li><li>0 &lt;= m, n &lt;= 200</li><li>1 &lt;= m + n &lt;= 200</li><li>-10^9 &lt;= nums1[i], nums2[i] &lt;= 10^9</li></ul><hr><p>一个暴力法O(m*n)一个双指针法O(m+n)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        map&lt;int,int&gt; maps;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        for(int i = 0 ; i &lt; m ; i++)</span></span><br><span class="line"><span class="comment">            maps[nums1[i]]++;</span></span><br><span class="line"><span class="comment">        for(int i = 0 ; i &lt; n ; i++)</span></span><br><span class="line"><span class="comment">            maps[nums2[i]]++;</span></span><br><span class="line"><span class="comment">        nums1.clear();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        for(auto x: maps)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            for(int i = 0 ; i &lt; x.second ; i++)</span></span><br><span class="line"><span class="comment">                nums1.push_back(x.first);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mp = <span class="number">0</span> , np = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(mp &lt; m || np &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp == m || np == n)&#123;</span><br><span class="line">                mp == m ?ans.<span class="built_in">push_back</span>(nums2[np++]) : ans.<span class="built_in">push_back</span>(nums1[mp++]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums1[mp] &gt; nums2[np])</span><br><span class="line">                ans.<span class="built_in">push_back</span>(nums2[np++]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums1[mp] &lt; nums2[np])</span><br><span class="line">                ans.<span class="built_in">push_back</span>(nums1[mp++]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(nums1[mp++]);</span><br><span class="line">                ans.<span class="built_in">push_back</span>(nums2[np++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nums1.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : ans)</span><br><span class="line">            nums1.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;88-合并两个有序数组&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#88-合并两个有序数组&quot;&gt;¶&lt;/a&gt;88. 合并两个有序数组&lt;/h2&gt;
&lt;p&gt;给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使</summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 781.森林中的兔子</title>
    <link href="http://example.com/2021/04/04/leetcode781/"/>
    <id>http://example.com/2021/04/04/leetcode781/</id>
    <published>2021-04-04T09:00:08.489Z</published>
    <updated>2021-04-04T09:06:13.292Z</updated>
    
    <content type="html"><![CDATA[<h2 id="781-森林中的兔子"><a class="header-anchor" href="#781-森林中的兔子">¶</a>781. 森林中的兔子</h2><p>森林中，每个兔子都有颜色。其中一些兔子（可能是全部）告诉你还有多少其他的兔子和自己有相同的颜色。我们将这些回答放在 answers 数组里。</p><p>返回森林中兔子的最少数量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入: answers = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line">解释:</span><br><span class="line">两只回答了 <span class="string">&quot;1&quot;</span> 的兔子可能有相同的颜色，设为红色。</span><br><span class="line">之后回答了 <span class="string">&quot;2&quot;</span> 的兔子不会是红色，否则他们的回答会相互矛盾。</span><br><span class="line">设回答了 <span class="string">&quot;2&quot;</span> 的兔子为蓝色。</span><br><span class="line">此外，森林中还应有另外 <span class="number">2</span> 只蓝色兔子的回答没有包含在数组中。</span><br><span class="line">因此森林中兔子的最少数量是 <span class="number">5</span>: <span class="number">3</span> 只回答的和 <span class="number">2</span> 只没有回答的。</span><br><span class="line"></span><br><span class="line">输入: answers = [<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>]</span><br><span class="line">输出: <span class="number">11</span></span><br><span class="line"></span><br><span class="line">输入: answers = []</span><br><span class="line">输出: <span class="number">0</span></span><br></pre></td></tr></table></figure><p>说明:</p><ul><li>answers 的长度最大为1000。</li><li>answers[i] 是在 [0, 999] 范围内的整数。</li></ul><hr><p>举个例子当一只兔子说有n只兔子与它相同，那么它和另外n只兔子一共加起来是n+1只，当又有一只兔子说有n只兔子相同，说明和上一个说有n个兔子的兔子可能是相同的，但我们要尽量使它们是相同的，那么怎么判断呢，很简单，我们只需要建立一个数组cnt，并初始化为0，比如说有一个兔子说有9个兔子和它相同，那么只要cnt[9]不为0，我们就设cnt[9] = 9,当又有一只兔子说它和9个兔子颜色相同，那么cnt[9]–;直到cnt[9] = 0,那么这就是我们所期望的10只兔子。如果此时又多了一只兔子说有9只与它们相同，证明这就是另外一种颜色了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numRabbits</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; answers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = answers.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">1001</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : answers)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[x] &gt; <span class="number">0</span>)</span><br><span class="line">                cnt[x]--;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cnt[x] = x;</span><br><span class="line">                cnt[<span class="number">1000</span>] += (x + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt[<span class="number">1000</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;781-森林中的兔子&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#781-森林中的兔子&quot;&gt;¶&lt;/a&gt;781. 森林中的兔子&lt;/h2&gt;
&lt;p&gt;森林中，每个兔子都有颜色。其中一些兔子（可能是全部）告诉你还有多少其他的兔子和自己有相同的颜色。我们将</summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 1143. 最长公共子序列</title>
    <link href="http://example.com/2021/04/04/leetcode1143/"/>
    <id>http://example.com/2021/04/04/leetcode1143/</id>
    <published>2021-04-04T07:03:50.647Z</published>
    <updated>2021-04-04T08:59:48.146Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1143-最长公共子序列"><a class="header-anchor" href="#1143-最长公共子序列">¶</a>1143. 最长公共子序列</h2><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如，“ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。</li></ul><p>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p><p>示例 1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 = <span class="string">&quot;abcde&quot;</span>, text2 = <span class="string">&quot;ace&quot;</span> </span><br><span class="line">输出：<span class="number">3</span>  </span><br><span class="line">解释：最长公共子序列是 <span class="string">&quot;ace&quot;</span> ，它的长度为 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 = <span class="string">&quot;abc&quot;</span>, text2 = <span class="string">&quot;abc&quot;</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：最长公共子序列是 <span class="string">&quot;abc&quot;</span> ，它的长度为 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 = <span class="string">&quot;abc&quot;</span>, text2 = <span class="string">&quot;def&quot;</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：两个字符串没有公共子序列，返回 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;= text1.length, text2.length &lt;= 1000</li><li>text1 和 text2 仅由小写英文字符组成。</li></ul><p>自从上次用动归写过字符串批配问题之后，这类问题只要套用模板，改下初始化状态和状态转移方程就行了，一样，建立一个二维的dp数组，dp[i][j] 代表text1[0<sub>i-1]与text2[0</sub>j-1]匹配的最长公共子序列的长度，想一想初始状态，当i为0或j为0的时候，代表相互之间没有一个能与其互相匹配的字符串，所以全部置零，然后思考状态转移方程。</p><p>状态转移方程的原理实在不好描述，我自己跟自己也说不清，但我知道就是那么回事，所以也不较真了。<br>就是当text1[i - 1]与text2[j - 1]相同时，因为dp[i-1][j-1]是去掉text1[i-1]与text2[j-1]两个字符后的匹配结果，所以两者相同我们只需要加上一就是dp[i][j]的结果，如果不同，我们就要从text1[0:i-2]与text2[0:j-1]，text1[0:i-1]与text2[0:j-2]的匹配结果中取最大值，这样才符合最长公共子序列的要求。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = text1.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">int</span> m = text2.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">long</span>&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>,vector&lt;<span class="keyword">long</span>&gt;(m+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; i++)dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= m ; i++)dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>])</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1143-最长公共子序列&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#1143-最长公共子序列&quot;&gt;¶&lt;/a&gt;1143. 最长公共子序列&lt;/h2&gt;
&lt;p&gt;给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如</summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 面试题 17.21. 直方图的水量</title>
    <link href="http://example.com/2021/04/02/leetcodeof1712/"/>
    <id>http://example.com/2021/04/02/leetcodeof1712/</id>
    <published>2021-04-02T09:15:51.527Z</published>
    <updated>2021-04-02T09:31:54.432Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试题-17-21-直方图的水量"><a class="header-anchor" href="#面试题-17-21-直方图的水量">¶</a>面试题 17.21. 直方图的水量</h2><p>给定一个直方图(也称柱状图)，假设有人从上面源源不断地倒水，最后直方图能存多少水量?直方图的宽度为 1。<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png"></p><p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的直方图，在这种情况下，可以接 6 个单位的水（蓝色部分表示水）。 感谢 Marcos 贡献此图。</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">6</span></span><br></pre></td></tr></table></figure><hr><p>看到这题想到了单调栈，维护一个递减的单调栈存储下标，一旦遇到比栈顶对应的元素大的元素，证明可以存水。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> n = height.<span class="built_in">size</span>();</span><br><span class="line">        s.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() &amp;&amp; height[s.<span class="built_in">top</span>()] &lt; height[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> minn = s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    cnt += (<span class="built_in">min</span>(height[s.<span class="built_in">top</span>()],height[i]) - height[minn])*(i - s.<span class="built_in">top</span>() - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>cnt 每次加上当前行的储水量，也就是说，一旦遇到比栈顶元素大的情况，我们记录当前栈顶元素位置为minn，然后弹出，然后知道左边墙的高度为height[s.top()]，求左边墙与右边墙之中的最小值，减去minn就是高度，然后i是当前位置，s.top()是左边墙的位置，右墙减去左墙再减一等它们之间的宽度，这样我们就得知了两个墙之间的行水量一共有多少。</p><img src="https://note.youdao.com/yws/api/personal/file/WEB83729112f15ca993cfd5c5d51a9be909?method=download&shareKey=ebe8ab7878acea2c59d2d5bf2dcffbb3">  <p>就拿这幅图举例子，蓝色是我们第一次计算的面积，红色是第二次。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;面试题-17-21-直方图的水量&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#面试题-17-21-直方图的水量&quot;&gt;¶&lt;/a&gt;面试题 17.21. 直方图的水量&lt;/h2&gt;
&lt;p&gt;给定一个直方图(也称柱状图)，假设有人从上面源源不断地倒水，最后直</summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 1006.笨阶乘</title>
    <link href="http://example.com/2021/04/01/leetcode1006/"/>
    <id>http://example.com/2021/04/01/leetcode1006/</id>
    <published>2021-04-01T11:00:54.286Z</published>
    <updated>2021-04-01T11:53:39.815Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1006-笨阶乘"><a class="header-anchor" href="#1006-笨阶乘">¶</a>1006.笨阶乘</h2><p>通常，正整数 n 的阶乘是所有小于或等于 n 的正整数的乘积。例如，factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1。</p><p>相反，我们设计了一个笨阶乘 clumsy：在整数的递减序列中，我们以一个固定顺序的操作符序列来依次替换原有的乘法操作符：乘法(*)，除法(/)，加法(+)和减法(-)。</p><p>例如，clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1。然而，这些运算仍然使用通常的算术运算顺序：我们在任何加、减步骤之前执行所有的乘法和除法步骤，并且按从左到右处理乘法和除法步骤。</p><p>另外，我们使用的除法是地板除法（floor division），所以 10 * 9 / 8 等于 11。这保证结果是一个整数。</p><p>实现上面定义的笨函数：给定一个整数 N，它返回 N 的笨阶乘。</p><p>示例一：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="number">4</span></span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：<span class="number">7</span> = <span class="number">4</span> * <span class="number">3</span> / <span class="number">2</span> + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>示例二：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="number">10</span></span><br><span class="line">输出：<span class="number">12</span></span><br><span class="line">解释：<span class="number">12</span> = <span class="number">10</span> * <span class="number">9</span> / <span class="number">8</span> + <span class="number">7</span> - <span class="number">6</span> * <span class="number">5</span> / <span class="number">4</span> + <span class="number">3</span> - <span class="number">2</span> * <span class="number">1</span></span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;= N &lt;= 10000</li><li>-2^31 &lt;= answer &lt;= 2^31 - 1  （答案保证符合 32 位整数。）</li></ul><hr><p>只要写过计算器的写这道题就毫无困难，直接用栈，遇乘除更新值，遇加减保存值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">clumsy</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        res.<span class="built_in">push</span>(N);</span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        N--;</span><br><span class="line">        <span class="keyword">while</span>(N&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sign%<span class="number">4</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> cur = res.<span class="built_in">top</span>() * N;</span><br><span class="line">                res.<span class="built_in">pop</span>();</span><br><span class="line">                res.<span class="built_in">push</span>(cur);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sign%<span class="number">4</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> cur = res.<span class="built_in">top</span>() / N;</span><br><span class="line">                res.<span class="built_in">pop</span>();</span><br><span class="line">                res.<span class="built_in">push</span>(cur);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sign%<span class="number">4</span> == <span class="number">2</span>)&#123;</span><br><span class="line">                res.<span class="built_in">push</span>(N);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res.<span class="built_in">push</span>(-N);</span><br><span class="line">            &#125;</span><br><span class="line">            sign++;</span><br><span class="line">            N--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!res.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            sum+=res.<span class="built_in">top</span>();</span><br><span class="line">            res.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1006-笨阶乘&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#1006-笨阶乘&quot;&gt;¶&lt;/a&gt;1006.笨阶乘&lt;/h2&gt;
&lt;p&gt;通常，正整数 n 的阶乘是所有小于或等于 n 的正整数的乘积。例如，factorial(10) = 10 * 9 *</summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 90.子集 II</title>
    <link href="http://example.com/2021/03/31/leetcode90/"/>
    <id>http://example.com/2021/03/31/leetcode90/</id>
    <published>2021-03-31T14:02:02.973Z</published>
    <updated>2021-03-31T14:25:11.074Z</updated>
    
    <content type="html"><![CDATA[<h2 id="90-子集-II"><a class="header-anchor" href="#90-子集-II">¶</a>90. 子集 II</h2><p>给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。</p><p>示例 1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出：[[],[<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">2</span>],[<span class="number">2</span>,<span class="number">2</span>]]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>]</span><br><span class="line">输出：[[],[<span class="number">0</span>]]</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;= nums.length &lt;= 10</li><li>-10 &lt;= nums[i] &lt;= 10</li></ul><p>本题用回溯算法比较容易理解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; sub;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">back</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(sub);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start ; i &lt; size ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; start &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            sub.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">back</span>(nums,i+<span class="number">1</span>);</span><br><span class="line">            sub.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">       res.<span class="built_in">clear</span>();</span><br><span class="line">       sub.<span class="built_in">clear</span>();</span><br><span class="line">       <span class="keyword">this</span>-&gt;size = nums.<span class="built_in">size</span>();</span><br><span class="line">       <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">       <span class="built_in">back</span>(nums,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先将nums排序，因为这样才能达到去重的目的，后面说。<br>start是每次组合的首地址，直接看循环，分析if为什么这样写</p><hr><p>设置i&gt;start是为了防止第一次循环就判断nums[i] == nums[i-1],这不是我们要判断的范围，因为i==start时，明显我们只有一个元素进来。<br>nums[i] == nums[i-1] 是为了去重，有点不好解释，我们就这样想象,举个例子[1,2,3,3],start是0的时候我们从1进入，然后递归进入back(),不管它子递归的循环，我们就只看第一次递归的循环，是不是会得到[1,2,3,3]，你们可能会说，你不是设置了nums[i] == nums[i-1]就continue吗，为什么会得到[1,2,3,3]，这就是因为前面有个i&gt;start，但如果我们在子循环时，也就是此时sub里面有[1,2]时的递归层，我们遍历到第一个3，加进去sub = [1,2,3]，此时i明显已经大于start，我们不会再得到第二个[1,2,3]，此时这个3是第4个3.</p><hr><p>用一个非常妙的解释方法就是，把整个结构想象成一个树，层相同是不允许的，树枝相同是允许的。<br><img src="https://note.youdao.com/yws/api/personal/file/WEB5d691b3c537e26e9e9bc35f74ba68abe?method=download&shareKey=1f1d9dff89c143e4999f15294b65158d"></p><p><kbd>i &gt; start &amp;&amp; nums[i] == nums[i-1]</kbd>就诠释了这种判断。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;90-子集-II&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#90-子集-II&quot;&gt;¶&lt;/a&gt;90. 子集 II&lt;/h2&gt;
&lt;p&gt;给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。&lt;/p&gt;
&lt;p&gt;解集 不</summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL(二) 绘制一个三角形</title>
    <link href="http://example.com/2021/03/30/OpenGL-Triangle/"/>
    <id>http://example.com/2021/03/30/OpenGL-Triangle/</id>
    <published>2021-03-30T12:57:15.591Z</published>
    <updated>2021-04-01T12:47:16.566Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OpenGL-二-绘制一个三角形"><a class="header-anchor" href="#OpenGL-二-绘制一个三角形">¶</a>OpenGL(二) 绘制一个三角形</h2><p><kbd><font size=2 color=red>注：本文仅供自己以及OPENGL初学者共同学习进步，并无实际教学意义，不过会对自己学习中遇到的关键点加上个人解释。应该会对初学者有所帮助，如有错误请指正！</font></kbd></p><hr><p>来到初学者最容易弃坑的地方了，因为这个地方实在是很多东西难以理解，不过，我们必须尽可能理解多一点，就算是算不上正确的观念，我们也只能强吃下去，等学到后面自己纠正自己，因为网上实在是找不到什么详细的教程来解释我们这些初学者的问题，也许这些在别人眼里都不算问题，只能自己一步一步慢慢摸索咯。</p><hr><p>不过这篇文章，我会试着解释很多我之前学习这个地方的时候诸多的疑惑，我相信有很多初学者会跟我抱有相同的问题，所以我会以初学者的角度，去解释所有的东西，并且在基础上加上官方解释，以显得我们不是在学一加一等于二。（还是建议先去看完learnOpenGL中文里面的你好三角形章节，带上自己的理解，再回来看这篇文章)</p><p>来梳理一下我们这篇文章要了解的东西：</p><ul><li>顶点数组对象(Vertex Array Object) VAO]=是什么，有什么作用？</li><li>顶点缓冲对象(Vertex Buffer Object) VBO 是什么，有什么作用，跟VAO的关系？</li><li>索引缓冲对象(Element Buffer Object) EBO 是什么，跟VBO有什么区别？</li><li>编程时的规则是怎样，跟OpenGL特性的关联。</li><li>重点：使用上面东西时经历的过程。</li></ul><hr><p>就从简单的屏幕绘制说起吧，Opengl是一个3D的工作空间，不过我们要绘制的是2D事物，在高中大家都有了解到三维坐标吧(x,y,z),在图形学里，简单来说，x是左右,y是上下,z是前后，其实还有个w,用来区分向量和点。<br>那么我们要绘制一个三角形，要做的工作是什么呢？</p><hr><p>我们可能一开始都会这么想，画个三角形不就是给定三个坐标，然后让这三个坐标连起来不就行了吗。确实，对于“人”来说，就是这么简单，可惜我们要告诉一个只认得1和0的莫得感情的机器这些东西，直接对话吗？不太现实，当然，我们也不用扯的太底层，我只是说我们要完成一个什么样的过程才能让电脑明白我们的代码。</p><p>首先是给定坐标，这是必须的，那么坐标用什么表示呢，数组，都能想到吧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line"><span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// x1 y1 z1</span></span><br><span class="line"> <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// x2 y2 z2 因为我们只是画个2D的三角形，所以不用管远近，一律设为</span></span><br><span class="line"> <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// x3 y3 z3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>好的，坐标给出来了，不过这是我们眼中的坐标，因为我们知道，但OpenGL呢，你给它这9个浮点数，它可不能自己识别这9个数字然后自己乖乖画个三角形出来。所以我们要利用OpenGL里面的“工具”。</p><p>OK，第一项内容就是数据，看到了我们刚刚定义的三个坐标的数组，这就是我们要交给OpenGL的数据，那么OpenGL可不能直接认下你这个数组，所以要用一个东西，<kbd>VBO</kbd>登场了，<font color=red>是OpenGL里面专门存储各种数据的对象</font>，我们要用到它，把这个数组交给VBO是我们的第一步。</p><hr><p>那么我们开始创建一个VBO:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VBO;<span class="comment">//变量名什么的无所谓，你叫 ABC 都行</span></span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>,&amp;VBO);</span><br><span class="line"></span><br><span class="line"><span class="comment">//好的，现在我们有一个VBO了，接下来就是绑定它</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER,VBO);</span><br><span class="line"><span class="comment">//然后将上面的vertices数组给这个VBO；</span></span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in"><span class="keyword">sizeof</span></span>(vertices), vertices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure><p>先解释下<kbd>glGenBuffers()</kbd>,我相信有不少人仍然对这个函数里面的两个参数抱有疑惑，如果你只看了learnOpenGL的话，可能并没有实际理解这两个参数的意义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glGenBuffers</span><span class="params">(GLsizei n,GLuint * buffers)</span></span>;</span><br><span class="line"> </span><br><span class="line">n - Specifies the number of buffer object names to be generated.</span><br><span class="line">buffers - Specifies an array in which the generated buffer object names are stored.</span><br><span class="line"></span><br><span class="line">glGenBuffers returns n buffer object names in buffers. There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to glGenBuffers.</span><br><span class="line"></span><br><span class="line">Buffer object names returned by a call to glGenBuffers are <span class="keyword">not</span> returned by subsequent calls, unless they are first deleted with glDeleteBuffers.</span><br><span class="line"></span><br><span class="line">No buffer objects are associated with the returned buffer object names until they are first bound by calling glBindBuffer.</span><br><span class="line"></span><br><span class="line">n - 指定要生成的缓冲区对象名称的数量。</span><br><span class="line">buffers - 指定存储缓冲区对象名称的数组。</span><br><span class="line"></span><br><span class="line">glGenBuffers返回n个缓冲区对象名。不能保证这些名称形成一个连续的整数集；但是，可以保证在调用glGenBuffers之前，没有一个返回的名称是正在使用的。</span><br><span class="line"></span><br><span class="line">调用glGenBuffers返回的缓冲区对象名称不会被后续调用返回，除非先用glDeleteBuffers删除它们。</span><br><span class="line"></span><br><span class="line">在调用glBindBuffer首次绑定之前，没有任何缓冲区对象与返回的缓冲区对象名相关联。</span><br></pre></td></tr></table></figure><p>目前不要理解太深了，不要被官方文档给吓到了，你只需知道第一个参数是数量，第二个参数是变量名就行。</p><hr><p>好的，说完<kbd>glGenBuffers()</kbd>,最让初学者疑惑的东西来了。<kbd>glBindBuffer()</kbd>-绑定是什么东西，还有下面那个函数<kbd>glBufferData()</kbd>看上去跟我们创建的VBO没半点关系，为什么说是将我们刚刚建立的数组vertices丢进了这个VBO里。请看下面这幅图：</p><img src="https://note.youdao.com/yws/api/personal/file/WEB9668a8abf8d58bba5cd7fb91976ab3bf?method=download&shareKey=2b803bbd2c5adc818e7f249c0ba8aeef"><p><kbd>glBindBuffer(GL_ARRAY_BUFFER, VBO);</kbd><br>告诉Opengl，VBO是GL_ARRAY_BUFFER类型的缓冲对象并且将VBO绑定到GL_ARRAY_BUFFER缓冲区.<br><kbd>glBufferData(GL_ARRAY_BUFFER,…,…,…)</kbd>目标缓冲类型GL_ARRAY_BUFFER，意思就是把数据发送到GL_ARRAY_BUFFER缓冲区上，而刚刚我们已经将VBO与GL_ARRAY_BUFFER缓冲绑定在一起了，所以任何传送给GL_ARRAY_BUFFER缓冲的数据都会传送到我们刚刚绑定的VBO身上，只要我们不用glBindBuffer()去绑定另外的VBO1,VBO2…Balaaa…，就会一直作用到VBO身上。</p><hr><p>目前为止，数据传递就已经解决了吧，那么接下来该干什么呢，当然是给OpenGL翻译这堆数据啊，虽然我们已经有了存好数据的VBO，但是你不告诉OpenGL怎么去读取VBO的内容，还是不行的，因为它虽然能拿到这些数据，不过它不知道你是第一列是XYZ，还是第一行是XYZ，所以你得设置一个读取规则，并且让OpenGl知道。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT,GL_FALSE, <span class="number">3</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>); <span class="comment">//告诉OPENGL如何处理顶点数据</span></span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>先别管第二行，我们直接观察第一个函数<kbd>glVertexAttribPointer()</kbd>，先看下面一幅图：</p><img src="https://learnopengl-cn.github.io/img/01/04/vertex_attribute_pointer.png"><p>和我们刚刚建立的数组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line"><span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// x1 y1 z1</span></span><br><span class="line"> <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// x2 y2 z2 </span></span><br><span class="line"> <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// x3 y3 z3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在来分析<kbd>glVertexAttribPointer()</kbd>的参数</p><ul><li>第一个参数，0，意思就是我们从第零个位置开始读取，因为我们数组中第0个就已经是我们要取的坐标之一了，也就是x1</li><li>第二个参数，3，也就是告诉我们，每3个数，算作一个顶点，每三个数分别代表xyz</li><li>第三个参数，GL_FLOAT，也就是说我们数组中的每个数据是浮点型</li><li>第四个参数，GL_FALSE，定义我们是否希望数据被标准化(Normalize)。如果我们设置为GL_TRUE，所有数据都会被映射到0（对于有符号型signed数据是-1）到1之间。我们把它设置为GL_FALSE。（这个可能你得懂一点图形学才知道标准化有什么意思，不过目前就先别深究了，以后会懂的）</li><li>第五个参数，3 * sizeof(float),我们已经知道了每3个float数据为一个顶点，所以3个数据的长度为 3乘以一个float数据的字节大小。这是告诉opengl一个顶点的数据长度。</li><li>第六个参数，它表示位置数据在缓冲中起始位置的偏移量(Offset)，而且由于它的类型是void,所以要强转一下。因为你数组中的第一个顶点的信息是从0开始获取的，所以这里设为0，假如你数组中第一行是其他信息，从第二行开始才是你的顶点信息，那就设为3，从第4个（0,1,2,3)数据开始读取数据。</li></ul><hr><p>下面解释VAO，我相信大部分初学者肯定难以理解VAO的作用在哪，毕竟VAO这名字取得我们根本想不到它的作用是什么，我尝试用最简单的方法去理解它。</p><p>就拿我们刚刚建立的VBO缓冲来当例子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VBO;<span class="comment">//变量名什么的无所谓，你叫 ABC 都行</span></span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>,&amp;VBO);</span><br><span class="line"></span><br><span class="line"><span class="comment">//好的，现在我们有一个VBO了，接下来就是绑定它</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER,VBO);</span><br><span class="line"><span class="comment">//然后将上面的vertices数组给这个VBO；</span></span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in"><span class="keyword">sizeof</span></span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">//告诉OPENGL如何处理顶点数据</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT,GL_FALSE, <span class="number">3</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>); </span><br></pre></td></tr></table></figure><p>如果不用VAO，我们用VBO就能画出一个三角形来了（只不过现在版本强制我们需要使用VAO，不然不准我们绘制，所以本菜鸟也不能去实践测试），说到底要绘制三角形，只要数据到位了，数据处理规则到位了，确切的传给显卡了，那么就能绘制出来。<br>这只是一个三角形，但假如我们要绘制非常非常多的图形，并且有非常多的VBO，各个VBO都有相应的读取规则呢。我们这样想，假设我们有VBO1,VBO2。<br>每次绘制图像前，我们都要像上面那样输入很多行，我刚把VBO1跟GL_ARRAY_BUFFER绑定，设置了读取规则，然后要我绘制VBO2中的数据，我又让VBO2跟GL_ARRAY_BUFFER绑定设置读取规则，结果现在又要我绘制VBO1，我又要重复输入上面那几行代码。就是这样一个过程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VBO1,VBO2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>,&amp;VBO1);</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>,&amp;VBO2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时要使用VBO1</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER,VBO1);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in"><span class="keyword">sizeof</span></span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT,GL_FALSE, <span class="number">3</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时要使用VBO2</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER,VBO2);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in"><span class="keyword">sizeof</span></span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT,GL_FALSE, <span class="number">3</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时又要使用VBO1</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER,VBO2);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in"><span class="keyword">sizeof</span></span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT,GL_FALSE, <span class="number">3</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//假如我们又要用VBO2，又来一遍</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER,VBO2);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in"><span class="keyword">sizeof</span></span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT,GL_FALSE, <span class="number">3</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>这才两个VBO，我们就要这样不断的设置，是不是特别麻烦。</p><p>如果有VAO：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VAO1,VAO2,VBO1,VBO2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO1);</span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO2);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO1);</span><br><span class="line">------------------此区域内为VAO1的作用域，在这里面对VBO1的操作都会存储在VAO1里面</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>,&amp;VBO1);</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>,&amp;VBO2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER,VBO1);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in"><span class="keyword">sizeof</span></span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT,GL_FALSE, <span class="number">3</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line">------------------ </span><br><span class="line"><span class="built_in">glBindVertexArray</span>(<span class="number">0</span>); <span class="comment">//解绑VAO1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO2);</span><br><span class="line">------------------此区域内为VAO2的作用域，在这里面对VBO2的操作都会存储在VAO1里面</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER,VBO2);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in"><span class="keyword">sizeof</span></span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT,GL_FALSE, <span class="number">3</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>); </span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line">------------------</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(<span class="number">0</span>); <span class="comment">//解绑VAO2</span></span><br></pre></td></tr></table></figure><p>完成上面的操作后：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此时要使用VBO1</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO1);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时要使用VBO2</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO2);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时又要使用VBO1</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO1);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//假如我们又要用VBO2，又来一遍</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO2);</span><br></pre></td></tr></table></figure><hr><p>是不是感觉瞬间方便很多了。可以吧VAO理解为记忆了一个VBO的操作，并且想用只要绑定相应的VAO就能用了，不用再重新进行一遍VBO的操作。</p><hr><p>好的，现在我们利用VAO和VBO画一个三角形~那是不可能的，因为还有个最最重要的东西，着色器，也是GPU的核心，不过我们只需要完成两个最基础的着色器，就能绘制我们想要的东西，分别是顶点着色器，还有片段着色器，因为这两个是必须品咯，其他着色器都可以不要，但这两个是绘制图形的基础，顶点着色器接收我们输入的顶点数据，也就是之前用VBO往GL_ARRAY_BUFFER里面输的东西，片段着色器就是用来给三角形上色的。因为C++又不能直接识别着色器语言，我们只能用opengl编译着色器语言，然后使用它。</p><p>首先是设置两个着色器，用字符串来写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顶点着色器</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *vertexShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line"><span class="string">&quot;layout (location = 0) in vec3 aPos;\n&quot;</span></span><br><span class="line"><span class="string">&quot;void main()\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line"><span class="string">&quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#125;\0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * fragmentShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line"><span class="string">&quot;out vec4 FragColor;\n&quot;</span></span><br><span class="line"><span class="string">&quot;void main()\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line"><span class="string">&quot;   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#125;\0&quot;</span>;</span><br></pre></td></tr></table></figure><p>还记得上面的<kbd>glEnableVertexAttribArray(0);</kbd>吗，再看看着色器源码里面的<kbd>layout (location = 0)</kbd>,这两个0有什么关系呢，先来看一幅图：<br><img src="https://learnopengl-cn.github.io/img/01/04/vertex_array_objects.png"></p><p>VAO里面可不止能存一个VBO中的一种信息，VBO里面除了顶点数据，可能还包括颜色和纹理数据等等，我们刚刚是将顶点数据存在了类似图中的VAO1的<kbd>attribute pointer 0</kbd>里面，所以0是我们所需要的信息的位置，glEnableVertexAttribArray(0);是将VBO这系列操作放在0，而layout (location = 0)是告诉顶点着色器传进来的顶点信息是在VAO的0的位置。片段着色器就不多说了，相信learnOpenGL里面已经讲到我们需要理解的地步了，接下来使用着色器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> vertexShader;  <span class="comment">//输出一个图像到屏幕，至少需要顶点着色器与片段着色器</span></span><br><span class="line">vertexShader = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER); <span class="comment">//创建顶点着色器</span></span><br><span class="line"><span class="built_in">glShaderSource</span>(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>); <span class="comment">//绑定着色器源码 </span></span><br><span class="line"><span class="built_in">glCompileShader</span>(vertexShader); <span class="comment">//编译着色器源码</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> fragmentShader; <span class="comment">//同上 片段着色器</span></span><br><span class="line">fragmentShader = <span class="built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);</span><br><span class="line"><span class="built_in">glShaderSource</span>(fragmentShader,<span class="number">1</span>,&amp;fragmentShaderSource,<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">glCompileShader</span>(fragmentShader);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> shaderProgram;</span><br><span class="line">shaderProgram = <span class="built_in">glCreateProgram</span>(); <span class="comment">// 创建着色器程序</span></span><br><span class="line"><span class="built_in">glAttachShader</span>(shaderProgram, vertexShader); <span class="comment">//将两个着色器丢进程序里</span></span><br><span class="line"><span class="built_in">glAttachShader</span>(shaderProgram, fragmentShader);</span><br><span class="line"><span class="built_in">glLinkProgram</span>(shaderProgram); <span class="comment">//并且链接两个着色器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">glDeleteShader</span>(vertexShader); <span class="comment">//因为已经把着色器对象链接到程序对象里了，已经不需要了，就可以删除了</span></span><br><span class="line"><span class="built_in">glDeleteShader</span>(fragmentShader);</span><br></pre></td></tr></table></figure><p>之后在渲染循环里使用<kbd>glUseProgram(shaderProgram);</kbd>就能使用我们创建的着色器程序绘制图像了。</p><p>附上源码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GLEW_STATIC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow * window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow * window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line"><span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.3f</span>,</span><br><span class="line"> <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.3f</span>,</span><br><span class="line"> <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.3f</span>,</span><br><span class="line"> <span class="number">0.8f</span>,  <span class="number">0.8f</span>, <span class="number">0.3f</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *vertexShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line"><span class="string">&quot;layout (location = 0) in vec3 aPos;\n&quot;</span></span><br><span class="line"><span class="string">&quot;void main()\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line"><span class="string">&quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#125;\0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * fragmentShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line"><span class="string">&quot;out vec4 FragColor;\n&quot;</span></span><br><span class="line"><span class="string">&quot;void main()\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line"><span class="string">&quot;   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#125;\0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">glfwInit</span>(); <span class="comment">//初始化glfw</span></span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>); <span class="comment">//版本号</span></span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>); <span class="comment">//代表glfw3.3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); <span class="comment">//MAC 系统</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建窗口</span></span><br><span class="line">GLFWwindow * window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;demo&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//判断是否创建成功</span></span><br><span class="line"><span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">glfwTerminate</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">glfwMakeContextCurrent</span>(window); <span class="comment">//设置当前线程上下文 意思就是在切换下一个状态之前，进行的所有操作都是对 window这个对象进行的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化glad , glad是用来管理opengl的函数指针的，所以启用opengl任何函数之前需要初始化glad</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始渲染之前先告诉opengl渲染窗口的尺寸大小，以及坐标</span></span><br><span class="line"><span class="comment">//注意，opengl坐标范围为-1到1 ,与屏幕坐标之间存在映射关系</span></span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">600</span>); </span><br><span class="line"><span class="comment">//注册该函数，告诉opengl每次window调整大小时都调用该函数</span></span><br><span class="line"><span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback); </span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VBO,VAO;</span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO); <span class="comment">//创建一个VBO</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER,VBO);<span class="comment">//绑定这个VBO，在下一次绑定之前，所有的操作都是对这个VBO进行</span></span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in"><span class="keyword">sizeof</span></span>(vertices), vertices, GL_STATIC_DRAW); <span class="comment">//现在已经将vertices这个数据传递到了显存，而上面的VBO对象管理这些顶点数据</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT,GL_FALSE, <span class="number">3</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>); <span class="comment">//告诉OPENGL如何处理顶点数据</span></span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>); <span class="comment">//解绑VAO</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> vertexShader;  <span class="comment">//输出一个图像到屏幕，至少需要顶点着色器与片段着色器</span></span><br><span class="line">vertexShader = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER); <span class="comment">//创建顶点着色器</span></span><br><span class="line"><span class="built_in">glShaderSource</span>(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>); <span class="comment">//绑定着色器源码 </span></span><br><span class="line"><span class="built_in">glCompileShader</span>(vertexShader); <span class="comment">//编译着色器源码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> success;</span><br><span class="line"><span class="keyword">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line"><span class="built_in">glGetShaderiv</span>(vertexShader, GL_COMPILE_STATUS, &amp;success); <span class="comment">//判断着色器是否创建成功</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!success)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">glGetShaderInfoLog</span>(vertexShader,<span class="number">512</span>,<span class="literal">NULL</span>,infoLog);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl; <span class="comment">//打印错误信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> fragmentShader; <span class="comment">//同上 片段着色器</span></span><br><span class="line">fragmentShader = <span class="built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);</span><br><span class="line"><span class="built_in">glShaderSource</span>(fragmentShader,<span class="number">1</span>,&amp;fragmentShaderSource,<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">glCompileShader</span>(fragmentShader);</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> shaderProgram;</span><br><span class="line">shaderProgram = <span class="built_in">glCreateProgram</span>(); <span class="comment">// 创建着色器程序</span></span><br><span class="line"><span class="built_in">glAttachShader</span>(shaderProgram, vertexShader); <span class="comment">//将两个着色器丢进程序里</span></span><br><span class="line"><span class="built_in">glAttachShader</span>(shaderProgram, fragmentShader);</span><br><span class="line"><span class="built_in">glLinkProgram</span>(shaderProgram); <span class="comment">//并且链接两个着色器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">glDeleteShader</span>(vertexShader); <span class="comment">//因为已经把着色器对象链接到程序对象里了，已经不需要了，就可以删除了</span></span><br><span class="line"><span class="built_in">glDeleteShader</span>(fragmentShader);</span><br><span class="line"></span><br><span class="line"><span class="comment">//至此顶点数据已经全部传入GPU,以及告诉了GPU如何在顶点和片段着色器中处理数据</span></span><br><span class="line"><span class="comment">//但OPENGL还必须知道如何解释内存中的顶点数据，以及如何将顶点数据链接到顶点着色器的属性上</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//开始渲染循环</span></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window)) <span class="comment">// 检查glfw是否被要求退出</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">processInput</span>(window);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glUseProgram</span>(shaderProgram); <span class="comment">//使用该函数后，每个着色器调用和渲染都会使用这个程序对象</span></span><br><span class="line"><span class="comment">//glPolygonMode(GL_FRONT_AND_BACK, GL_LINE); //线框模式</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glfwSwapBuffers</span>(window); <span class="comment">//输出颜色缓冲</span></span><br><span class="line"><span class="built_in">glfwPollEvents</span>(); <span class="comment">//监视事件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放内存</span></span><br><span class="line"><span class="built_in">glfwTerminate</span>(); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow * window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> <span class="comment">//随用户调整窗口大小而变化视口大小</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow * window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line"><span class="built_in">glfwSetWindowShouldClose</span>(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，恭喜你，第一个三角形就完成了。</p><hr><p>到了最后，我们了说一下EBO，其实实质上，EBO和VBO是一个东西，不过从功能上还是将两者区分了出来，只不过是换了个名字，VBO存的是数据，EBO存的也是数据，不过是调用数据的索引数据，比如说我们要画一个4边型，但我们绘制的是GL_TRIANGLES，所以我们用两个三角形组成一个四边形，也就是这样：</p><img src="https://learnopengl.com/img/getting-started/hellotriangle2.png">  但是如果我们用VAO直接绘制，其实是有两个点重复绘制了的，也就是左上角和右下角，这两点是重复绘制了的，我们不希望这种重复绘制的事情发生，这时我们就可以用到索引缓冲对象EBO，其实看我不用EBO和用EBO要建立的两个数组，一下就能明白EBO是用来干嘛的了：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不用EBO，VBO数组必须这样设</span></span><br><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="comment">// first triangle</span></span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// top right</span></span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// bottom right</span></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// top left </span></span><br><span class="line">    <span class="comment">// second triangle</span></span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// bottom right</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// bottom left</span></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// top left</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//明显有重复点需要绘制</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">//而使用EBO，VBO我们则可以这样设置</span></span><br><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">//右上角</span></span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">//右下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">//左下角</span></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">//左上角 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//很明显，去除了重复点</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> indices[] = &#123; </span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>,   <span class="comment">// 第一个三角形</span></span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>    <span class="comment">// 第二个三角形</span></span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><p>也就是用索引的方式去调用每个每个顶点来绘制。<br>直接上源码吧：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GLEW_STATIC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow * window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow * window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line"> <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">//右上角</span></span><br><span class="line"> <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">//右下角</span></span><br><span class="line"><span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">//左下角</span></span><br><span class="line"><span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">//左上角 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//很明显，去除了重复点</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> indices[] = &#123;</span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>,   <span class="comment">// 第一个三角形</span></span><br><span class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>    <span class="comment">// 第二个三角形</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *vertexShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line"><span class="string">&quot;layout (location = 0) in vec3 aPos;\n&quot;</span></span><br><span class="line"><span class="string">&quot;void main()\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line"><span class="string">&quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#125;\0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * fragmentShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line"><span class="string">&quot;out vec4 FragColor;\n&quot;</span></span><br><span class="line"><span class="string">&quot;void main()\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line"><span class="string">&quot;   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#125;\0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">glfwInit</span>(); <span class="comment">//初始化glfw</span></span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>); <span class="comment">//版本号</span></span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>); <span class="comment">//代表glfw3.3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); <span class="comment">//MAC 系统</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建窗口</span></span><br><span class="line">GLFWwindow * window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;demo&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//判断是否创建成功</span></span><br><span class="line"><span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">glfwTerminate</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">glfwMakeContextCurrent</span>(window); <span class="comment">//设置当前线程上下文 意思就是在切换下一个状态之前，进行的所有操作都是对 window这个对象进行的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化glad , glad是用来管理opengl的函数指针的，所以启用opengl任何函数之前需要初始化glad</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始渲染之前先告诉opengl渲染窗口的尺寸大小，以及坐标</span></span><br><span class="line"><span class="comment">//注意，opengl坐标范围为-1到1 ,与屏幕坐标之间存在映射关系</span></span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">600</span>);</span><br><span class="line"><span class="comment">//注册该函数，告诉opengl每次window调整大小时都调用该函数</span></span><br><span class="line"><span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VBO, VAO ,EBO;</span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO); <span class="comment">//创建一个VBO</span></span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;EBO);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);<span class="comment">//绑定这个VBO，在下一次绑定之前，所有的操作都是对这个VBO进行</span></span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in"><span class="keyword">sizeof</span></span>(vertices), vertices, GL_STATIC_DRAW); <span class="comment">//现在已经将vertices这个数据传递到了显存，而上面的VBO对象管理这些顶点数据</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>); <span class="comment">//告诉OPENGL如何处理顶点数据</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, EBO); <span class="comment">//绑定EBO</span></span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="built_in"><span class="keyword">sizeof</span></span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(<span class="number">0</span>); <span class="comment">//解绑VAO</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> vertexShader;  <span class="comment">//输出一个图像到屏幕，至少需要顶点着色器与片段着色器</span></span><br><span class="line">vertexShader = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER); <span class="comment">//创建顶点着色器</span></span><br><span class="line"><span class="built_in">glShaderSource</span>(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>); <span class="comment">//绑定着色器源码 </span></span><br><span class="line"><span class="built_in">glCompileShader</span>(vertexShader); <span class="comment">//编译着色器源码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> success;</span><br><span class="line"><span class="keyword">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line"><span class="built_in">glGetShaderiv</span>(vertexShader, GL_COMPILE_STATUS, &amp;success); <span class="comment">//判断着色器是否创建成功</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!success)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">glGetShaderInfoLog</span>(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl; <span class="comment">//打印错误信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> fragmentShader; <span class="comment">//同上 片段着色器</span></span><br><span class="line">fragmentShader = <span class="built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);</span><br><span class="line"><span class="built_in">glShaderSource</span>(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">glCompileShader</span>(fragmentShader);</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> shaderProgram;</span><br><span class="line">shaderProgram = <span class="built_in">glCreateProgram</span>(); <span class="comment">// 创建着色器程序</span></span><br><span class="line"><span class="built_in">glAttachShader</span>(shaderProgram, vertexShader); <span class="comment">//将两个着色器丢进程序里</span></span><br><span class="line"><span class="built_in">glAttachShader</span>(shaderProgram, fragmentShader);</span><br><span class="line"><span class="built_in">glLinkProgram</span>(shaderProgram); <span class="comment">//并且链接两个着色器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">glDeleteShader</span>(vertexShader); <span class="comment">//因为已经把着色器对象链接到程序对象里了，已经不需要了，就可以删除了</span></span><br><span class="line"><span class="built_in">glDeleteShader</span>(fragmentShader);</span><br><span class="line"></span><br><span class="line"><span class="comment">//至此顶点数据已经全部传入GPU,以及告诉了GPU如何在顶点和片段着色器中处理数据</span></span><br><span class="line"><span class="comment">//但OPENGL还必须知道如何解释内存中的顶点数据，以及如何将顶点数据链接到顶点着色器的属性上</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//开始渲染循环</span></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window)) <span class="comment">// 检查glfw是否被要求退出</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">processInput</span>(window);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glUseProgram</span>(shaderProgram); <span class="comment">//使用该函数后，每个着色器调用和渲染都会使用这个程序对象</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="comment">//glDrawArrays(GL_TRIANGLES, 0, 3);</span></span><br><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glfwSwapBuffers</span>(window); <span class="comment">//输出颜色缓冲</span></span><br><span class="line"><span class="built_in">glfwPollEvents</span>(); <span class="comment">//监视事件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放内存</span></span><br><span class="line"><span class="built_in">glfwTerminate</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow * window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> <span class="comment">//随用户调整窗口大小而变化视口大小</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow * window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line"><span class="built_in">glfwSetWindowShouldClose</span>(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>只是多了点EBO的部分，绘制函数改了一个罢了。<br>到这里，我相信你已经对VAO,VBO,EBO有初步的了解了，文章非常长，看到这里也非常不容易哈。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;OpenGL-二-绘制一个三角形&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#OpenGL-二-绘制一个三角形&quot;&gt;¶&lt;/a&gt;OpenGL(二) 绘制一个三角形&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;&lt;font size=2 color=red&gt;注：本文仅</summary>
      
    
    
    
    <category term="OPENGL" scheme="http://example.com/categories/OPENGL/"/>
    
    
    <category term="OPENGL学习" scheme="http://example.com/tags/OPENGL%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL(一) 渲染循环创建窗口</title>
    <link href="http://example.com/2021/03/30/OpenGL-window/"/>
    <id>http://example.com/2021/03/30/OpenGL-window/</id>
    <published>2021-03-30T08:49:48.270Z</published>
    <updated>2021-03-30T12:57:33.618Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OpenGL-一-渲染循环创建窗口"><a class="header-anchor" href="#OpenGL-一-渲染循环创建窗口">¶</a>OpenGL(一) 渲染循环创建窗口</h2><p><kbd><font size=2 color=red>注：本文仅供自己以及OPENGL初学者共同学习进步，并无实际教学意义，不过会对自己学习中遇到的关键点加上个人解释。应该会对初学者有所帮助，如有错误请指正！</font></kbd></p><p>上次我们已经配置好了<a href="openglconf.md">glfw + glad环境</a>,接下来就是我们实践使用的时候了。</p><hr><p>首先，我们先将要使用的头文件加进来，注意，这里先后顺序不能错：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>然后我们开始进入<kbd>main()</kbd>函数,初始化<kbd>glfw</kbd>,并且声明版本号：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">glfwInit</span>(); <span class="comment">//初始化glfw</span></span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>); <span class="comment">//版本号</span></span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>); <span class="comment">//代表glfw3.3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我这里使用的是3.3版本。<br>然后我们用<kbd>glfwCreateWindow()</kbd>函数创建一个窗口对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">glfwInit</span>(); <span class="comment">//初始化glfw</span></span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>); <span class="comment">//版本号</span></span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>); <span class="comment">//代表glfw3.3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建窗口</span></span><br><span class="line">GLFWwindow * window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//判断是否创建成功</span></span><br><span class="line"><span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">glfwTerminate</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window); <span class="comment">//设置当前线程上下文 意思就是在切换下一个状态之前，进行的所有操作都是对 window这个对象进行的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在源码注释里，<kbd>GLFWwindow</kbd>是&quot;brief Opaque window object&quot;，也就是简易窗口对象的意思。<br><kbd>glfwCreateWindow()</kbd>函数显而易见，第一个参数是宽度，第二个参数是高度，第三个是title，也就是窗口名称，后面两个参数现在用不到。当窗口创建失败时，<kbd>window</kbd>指针会指向NULL，我们可以利用这个来判断窗口是否创建成功。</p><p><kbd>glfwTerminate()</kbd>是释放资源的函数，当一切结束的时候，我们就要用到这个函数。<br><kbd>glfwMakeContextCurrent(window)</kbd>就如注释所说，OPENGL是讲状态的，只要我们不在当前线程设置其他上下文，它就会一直绑定当前设置的<kbd>window</kbd>窗口，之后的所有操作，就都是在这个<kbd>window</kbd>里进行.</p><hr><p>接下来我们初始化<kbd>glad</kbd>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">glfwInit</span>(); <span class="comment">//初始化glfw</span></span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>); <span class="comment">//版本号</span></span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>); <span class="comment">//代表glfw3.3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建窗口</span></span><br><span class="line">GLFWwindow * window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//判断是否创建成功</span></span><br><span class="line"><span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">glfwTerminate</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window); <span class="comment">//设置当前线程上下文 意思就是在切换下一个状态之前，进行的所有操作都是对 window这个对象进行的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始渲染之前先告诉opengl渲染窗口的尺寸大小，以及坐标</span></span><br><span class="line"><span class="comment">//注意，opengl坐标范围为-1到1 ,与屏幕坐标之间存 映射关系</span></span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">600</span>); </span><br><span class="line"><span class="comment">//注册该函数，告诉opengl每次window调整大小时都调用该函数</span></span><br><span class="line"><span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>glad是用来管理opengl的函数指针的，所以启用opengl任何函数之前需要初始化glad<br><kbd>glViewport()</kbd>是设置视口的，具体作用大概就是设置窗口的起始坐标，以及告诉opengl我们要渲染的窗口大小为800x600.<br><kbd>glfwSetFramebufferSizeCallback()</kbd>目的是为了当我们拖动窗口，造成窗口大小变化时，能够及时改变渲染的窗口尺寸,里面传入了我们自己设置的函数，可以看到函数内;我们在实时更改视口。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow * window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> <span class="comment">//随用户调整窗口大小而变化视口大小</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该准备的准备完了，可以开始渲染循环了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window)) <span class="comment">// 检查glfw是否被要求退出</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">glfwSwapBuffers</span>(window); <span class="comment">//交换前后缓冲</span></span><br><span class="line"><span class="built_in">glfwPollEvents</span>(); <span class="comment">//监视事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果跟着前面打没有打错的话，至此一个完整的黑色背景窗口就能出现了。</p><hr><p>来解释一下<kbd>glfwSwapBuffers()</kbd>,因为OPENGL是双缓冲，那么双缓冲的作用是什么呢？假如是单缓冲，由于屏幕上的像素绘制是由左到右，从上到下一个一个绘制的，如果缓冲量过大，那么可能会出现图像闪烁，但是如果是双缓冲，它是由前缓冲全部绘制好，然后再跟后缓冲互换，然后前后工作交替进行，这样子就解决了闪烁问题。所以也能理解这个函数为什么叫这么个名字了吧。</p><p>那么现在我们想给窗口背景改个色，该怎么弄呢，我们需要设置一个颜色缓冲。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br></pre></td></tr></table></figure><p><kbd>glClearColor()</kbd>是设置清空屏幕所使用的颜色，意思就是使用这个函数后，之后每次清屏，默认颜色都是我们这个函数所设置的颜色。然后<kbd>glClear()</kbd>就是清除颜色缓冲，也就是清屏，那么我们为什么每次循环都要<kbd>glClear()</kbd>呢，因为有些人可能认为，我都画上去了，为什么要清除屏幕，再绘制一次呢，因为在渲染循环里，你是一个在不断绘制图像的过程，如果不清屏，那么每次画的图像就会叠加，导致跟我们预想的绘制内容会出现很大差别，比如你只是要画一只鸭子，但你如果不使用<kbd>glClear()</kbd>,那可能就是成千上万只鸭子绘制在同一个地方，内容不断叠加。</p><p>最后我们再加入一个退出事件的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow * window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line"><span class="built_in">glfwSetWindowShouldClose</span>(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到一旦检测到我们按下ESC键，那么就会利用<kbd>glfwSetWindowShouldClose()</kbd>函数，传入true,使window窗口关闭，可以看到我们循环的条件是<kbd>while (!glfwWindowShouldClose(window))</kbd>。</p><p>接下来是完整源码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow * window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow * window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">glfwInit</span>(); <span class="comment">//初始化glfw</span></span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>); <span class="comment">//版本号</span></span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>); <span class="comment">//代表glfw3.3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建窗口</span></span><br><span class="line">GLFWwindow * window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//判断是否创建成功</span></span><br><span class="line"><span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">glfwTerminate</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window); <span class="comment">//设置当前线程上下文 意思就是在切换下一个状态之前，进行的所有操作都是对 window这个对象进行的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始渲染之前先告诉opengl渲染窗口的尺寸大小，以及坐标</span></span><br><span class="line"><span class="comment">//注意，opengl坐标范围为-1到1 ,与屏幕坐标之间存 映射关系</span></span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">600</span>); </span><br><span class="line"><span class="comment">//注册该函数，告诉opengl每次window调整大小时都调用该函数</span></span><br><span class="line"><span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window)) <span class="comment">// 检查glfw是否被要求退出</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">processInput</span>(window);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glfwSwapBuffers</span>(window); <span class="comment">//交换前后缓冲</span></span><br><span class="line"><span class="built_in">glfwPollEvents</span>(); <span class="comment">//监视事件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放内存</span></span><br><span class="line"><span class="built_in">glfwTerminate</span>(); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow * window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> <span class="comment">//随用户调整窗口大小而变化视口大小</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow * window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line"><span class="built_in">glfwSetWindowShouldClose</span>(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><img src="https://learnopengl-cn.github.io/img/01/03/hellowindow2.png">  <p>这样，一个基本完整的窗口就完成啦。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;OpenGL-一-渲染循环创建窗口&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#OpenGL-一-渲染循环创建窗口&quot;&gt;¶&lt;/a&gt;OpenGL(一) 渲染循环创建窗口&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;&lt;font size=2 color=red&gt;注：</summary>
      
    
    
    
    <category term="OPENGL" scheme="http://example.com/categories/OPENGL/"/>
    
    
    <category term="OPENGL学习" scheme="http://example.com/tags/OPENGL%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 74.搜索二维矩阵</title>
    <link href="http://example.com/2021/03/30/leetcode74/"/>
    <id>http://example.com/2021/03/30/leetcode74/</id>
    <published>2021-03-30T05:21:59.002Z</published>
    <updated>2021-03-30T08:49:06.404Z</updated>
    
    <content type="html"><![CDATA[<h2 id="74-搜索二维矩阵"><a class="header-anchor" href="#74-搜索二维矩阵">¶</a>74. 搜索二维矩阵</h2><p>编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p><p>-每行中的整数从左到右按升序排列。<br>-每行的第一个整数大于前一行的最后一个整数.</p><p>示例一：<br><img src="https://assets.leetcode.com/uploads/2020/10/05/mat.jpg"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>],[<span class="number">10</span>,<span class="number">11</span>,<span class="number">16</span>,<span class="number">20</span>],[<span class="number">23</span>,<span class="number">30</span>,<span class="number">34</span>,<span class="number">60</span>]], target = <span class="number">3</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>示例二：<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/mat2.jpg"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>],[<span class="number">10</span>,<span class="number">11</span>,<span class="number">16</span>,<span class="number">20</span>],[<span class="number">23</span>,<span class="number">30</span>,<span class="number">34</span>,<span class="number">60</span>]], target = <span class="number">13</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>m == matrix.length</li><li>n == matrix[i].length</li><li>1 &lt;= m, n &lt;= 100</li><li>-104 &lt;= matrix[i][j], target &lt;= 104</li></ul><hr><p>使用二分法，然后剪枝，对于每一行使用二分法，当target比当前行数尾的数还大时，直接去下一行搜寻。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(target &gt; matrix[i][n - <span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = left + ((right - left) / <span class="number">2</span>);</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][mid] == target)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][mid] &gt; target)&#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][mid] &lt; target)&#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;74-搜索二维矩阵&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#74-搜索二维矩阵&quot;&gt;¶&lt;/a&gt;74. 搜索二维矩阵&lt;/h2&gt;
&lt;p&gt;编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：&lt;/p&gt;
&lt;p&gt;-每行</summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 190.颠倒二进制位</title>
    <link href="http://example.com/2021/03/29/leetcode190/"/>
    <id>http://example.com/2021/03/29/leetcode190/</id>
    <published>2021-03-29T03:03:08.181Z</published>
    <updated>2021-03-29T09:26:18.321Z</updated>
    
    <content type="html"><![CDATA[<h2 id="190-颠倒二进制位"><a class="header-anchor" href="#190-颠倒二进制位">¶</a>190.颠倒二进制位</h2><p>颠倒给定的 32 位无符号整数的二进制位。</p><p>提示：</p><p>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。<br>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。</p><p>进阶:<br>如果多次调用这个函数，你将如何优化你的算法？</p><p>示例一：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">00000010100101000001111010011100</span></span><br><span class="line">输出: <span class="number">00111001011110000010100101000000</span></span><br><span class="line">解释: 输入的二进制串 <span class="number">00000010100101000001111010011100</span> 表示无符号整数 <span class="number">43261596</span>，</span><br><span class="line">     因此返回 <span class="number">964176192</span>，其二进制表示形式为 <span class="number">00111001011110000010100101000000</span>。</span><br></pre></td></tr></table></figure><p>示例二：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="number">11111111111111111111111111111101</span></span><br><span class="line">输出：<span class="number">10111111111111111111111111111111</span></span><br><span class="line">解释：输入的二进制串 <span class="number">11111111111111111111111111111101</span> 表示无符号整数 <span class="number">4294967293</span>，</span><br><span class="line">     因此返回 <span class="number">3221225471</span> 其二进制表示形式为 <span class="number">10111111111111111111111111111111</span> 。</span><br></pre></td></tr></table></figure><p>示例一：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">00000010100101000001111010011100</span></span><br><span class="line">输出：<span class="number">964176192</span> (<span class="number">00111001011110000010100101000000</span>)</span><br><span class="line">解释：输入的二进制串 <span class="number">00000010100101000001111010011100</span> 表示无符号整数 <span class="number">43261596</span>，</span><br><span class="line">     因此返回 <span class="number">964176192</span>，其二进制表示形式为 <span class="number">00111001011110000010100101000000</span>。</span><br></pre></td></tr></table></figure><p>示例二：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">11111111111111111111111111111101</span></span><br><span class="line">输出：<span class="number">3221225471</span> (<span class="number">10111111111111111111111111111111</span>)</span><br><span class="line">解释：输入的二进制串 <span class="number">11111111111111111111111111111101</span> 表示无符号整数 <span class="number">4294967293</span>，</span><br><span class="line">     因此返回 <span class="number">3221225471</span> 其二进制表示形式为 <span class="number">10111111111111111111111111111111</span> 。</span><br></pre></td></tr></table></figure><p>提示：</p><p>输入是一个长度为 32 的二进制字符串</p><hr><p>边取余边累加即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">32</span> ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = sum * <span class="number">2</span> + n % <span class="number">2</span>;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum = sum * <span class="number">2</span> + n % <span class="number">2</span>;</span><br><span class="line">n &gt;&gt;= <span class="number">1</span>; <span class="comment">//等价于 n = n / 2;</span></span><br></pre></td></tr></table></figure><p>这行如果看不懂可以看作十进制倒转的过程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum = sum * <span class="number">10</span> + n % <span class="number">10</span>;</span><br><span class="line">n = n / <span class="number">10</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;190-颠倒二进制位&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#190-颠倒二进制位&quot;&gt;¶&lt;/a&gt;190.颠倒二进制位&lt;/h2&gt;
&lt;p&gt;颠倒给定的 32 位无符号整数的二进制位。&lt;/p&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;p&gt;请注意，在某些语言（如 </summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 第243场周赛 创新奇智&amp;力扣</title>
    <link href="http://example.com/2021/03/28/lcweek243/"/>
    <id>http://example.com/2021/03/28/lcweek243/</id>
    <published>2021-03-28T04:50:43.042Z</published>
    <updated>2021-03-28T05:51:39.017Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-第243场周赛-创新奇智-力扣"><a class="header-anchor" href="#Leetcode-第243场周赛-创新奇智-力扣">¶</a>Leetcode 第243场周赛 创新奇智&amp;力扣</h2><p>本次差点全AC了，还是差一点火候。</p><h3 id="第一题-字符串中不同整数的数目"><a class="header-anchor" href="#第一题-字符串中不同整数的数目">¶</a>第一题-字符串中不同整数的数目</h3><p>给你一个字符串 word ，该字符串由数字和小写英文字母组成。</p><p>请你用空格替换每个不是数字的字符。例如，“a123bc34d8ef34” 将会变成 &quot; 123  34 8  34&quot; 。注意，剩下的这些整数间至少要用一个空格隔开：“123”、“34”、“8” 和 “34” 。</p><p>返回对 word 完成替换后形成的 不同 整数的数目。</p><p>如果两个整数的 不含前导零 的十进制表示不同，则认为这两个整数也不同。</p><p>示例一：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：word = <span class="string">&quot;a123bc34d8ef34&quot;</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：不同的整数有 <span class="string">&quot;123&quot;</span>、<span class="string">&quot;34&quot;</span> 和 <span class="string">&quot;8&quot;</span> 。注意，<span class="string">&quot;34&quot;</span> 只计数一次。</span><br></pre></td></tr></table></figure><p>示例二</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：word = <span class="string">&quot;leet1234code234&quot;</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure><p>示例三</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：word = <span class="string">&quot;a1b01c001&quot;</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：<span class="string">&quot;1&quot;</span>、<span class="string">&quot;01&quot;</span> 和 <span class="string">&quot;001&quot;</span> 视为同一个整数的十进制表示，因为在比较十进制值时会忽略前导零的存在。</span><br></pre></td></tr></table></figure><p>提示：<br>1 &lt;= word.length &lt;= 1000<br>word 由数字和小写英文字母组成</p><hr><p>该题只需要考虑两个东西，第一是提取数字，第二是去重。<br>利用vector提取数字，set去重</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numDifferentIntegers</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = word.<span class="built_in">length</span>();</span><br><span class="line">set&lt;string&gt; s;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (word[i] &gt;= <span class="string">&#x27;0&#x27;</span>&amp;&amp;word[i] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;<span class="keyword">char</span>&gt; vc;</span><br><span class="line"><span class="keyword">while</span> (i &lt; n &amp;&amp; (word[i] &gt;= <span class="string">&#x27;0&#x27;</span>&amp;&amp;word[i] &lt;= <span class="string">&#x27;9&#x27;</span>))</span><br><span class="line">&#123;</span><br><span class="line">vc.<span class="built_in">push_back</span>(word[i++]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (vc.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; vc[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">vc.<span class="built_in">erase</span>(vc.<span class="built_in">begin</span>());</span><br><span class="line">&#125;</span><br><span class="line">string tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : vc)</span><br><span class="line">tmp += x;</span><br><span class="line">s.<span class="built_in">insert</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> s.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="第二题-还原排列的最少操作步数"><a class="header-anchor" href="#第二题-还原排列的最少操作步数">¶</a>第二题-还原排列的最少操作步数</h2><p>给你一个偶数 n​​​​​​ ，已知存在一个长度为 n 的排列 perm ，其中 perm[i] == i​（下标 从 0 开始 计数）。</p><p>一步操作中，你将创建一个新数组 arr ，对于每个 i ：</p><p>如果 i % 2 == 0 ，那么 arr[i] = perm[i / 2]<br>如果 i % 2 == 1 ，那么 arr[i] = perm[n / 2 + (i - 1) / 2]<br>然后将 arr​​ 赋值​​给 perm 。</p><p>要想使 perm 回到排列初始值，至少需要执行多少步操作？返回最小的 非零 操作步数。</p><p>示例一：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：最初，perm = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">第 <span class="number">1</span> 步操作后，perm = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">所以，仅需执行 <span class="number">1</span> 步操作</span><br></pre></td></tr></table></figure><p>示例二:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：最初，perm = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">第 <span class="number">1</span> 步操作后，perm = [<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">第 <span class="number">2</span> 步操作后，perm = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">所以，仅需执行 <span class="number">2</span> 步操作</span><br></pre></td></tr></table></figure><p>示例三:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span></span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure><p>提示：<br>2 &lt;= n &lt;= 1000<br>n​​​​​​ 是一个偶数</p><hr><p>我们只用考虑arr数组是否对应prem[i] = i 即可，否则则操作步数+1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reinitializePermutation</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">prem</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">prem[i] = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (j&lt;n)</span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">0</span>)arr[i] = prem[i/<span class="number">2</span>];</span><br><span class="line"><span class="keyword">else</span> arr[i] = prem[n / <span class="number">2</span> + (i <span class="number">-1</span>)/ <span class="number">2</span> ];</span><br><span class="line">&#125;</span><br><span class="line">prem = arr;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (prem[j] != j)</span><br><span class="line">&#123;</span><br><span class="line">cnt++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (j == n)<span class="keyword">return</span> cnt+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="第三题-替换字符串中的括号内容"><a class="header-anchor" href="#第三题-替换字符串中的括号内容">¶</a>第三题-替换字符串中的括号内容</h2><p>给你一个字符串 s ，它包含一些括号对，每个括号中包含一个 非空 的键。</p><p>比方说，字符串 “(name)is(age)yearsold” 中，有 两个 括号对，分别包含键 “name” 和 “age” 。<br>你知道许多键对应的值，这些关系由二维字符串数组 knowledge 表示，其中 knowledge[i] = [keyi, valuei] ，表示键 keyi 对应的值为 valuei 。</p><p>你需要替换 所有 的括号对。当你替换一个括号对，且它包含的键为 keyi 时，你需要：</p><p>将 keyi 和括号用对应的值 valuei 替换。<br>如果从 knowledge 中无法得知某个键对应的值，你需要将 keyi 和括号用问号 “?” 替换（不需要引号）。<br>knowledge 中每个键最多只会出现一次。s 中不会有嵌套的括号。</p><p>请你返回替换 所有 括号对后的结果字符串。</p><p>示例一：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;(name)is(age)yearsold&quot;</span>, knowledge = [[<span class="string">&quot;name&quot;</span>,<span class="string">&quot;bob&quot;</span>],[<span class="string">&quot;age&quot;</span>,<span class="string">&quot;two&quot;</span>]]</span><br><span class="line">输出：<span class="string">&quot;bobistwoyearsold&quot;</span></span><br><span class="line">解释：</span><br><span class="line">键 <span class="string">&quot;name&quot;</span> 对应的值为 <span class="string">&quot;bob&quot;</span> ，所以将 <span class="string">&quot;(name)&quot;</span> 替换为 <span class="string">&quot;bob&quot;</span> 。</span><br><span class="line">键 <span class="string">&quot;age&quot;</span> 对应的值为 <span class="string">&quot;two&quot;</span> ，所以将 <span class="string">&quot;(age)&quot;</span> 替换为 <span class="string">&quot;two&quot;</span> 。</span><br></pre></td></tr></table></figure><p>示例二：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;hi(name)&quot;</span>, knowledge = [[<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>]]</span><br><span class="line">输出：<span class="string">&quot;hi?&quot;</span></span><br><span class="line">解释：由于不知道键 <span class="string">&quot;name&quot;</span> 对应的值，所以用 <span class="string">&quot;?&quot;</span> 替换 <span class="string">&quot;(name)&quot;</span> 。</span><br></pre></td></tr></table></figure><p>示例三：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;(a)(a)(a)aaa&quot;</span>, knowledge = [[<span class="string">&quot;a&quot;</span>,<span class="string">&quot;yes&quot;</span>]]</span><br><span class="line">输出：<span class="string">&quot;yesyesyesaaa&quot;</span></span><br><span class="line">解释：相同的键在 s 中可能会出现多次。</span><br><span class="line">键 <span class="string">&quot;a&quot;</span> 对应的值为 <span class="string">&quot;yes&quot;</span> ，所以将所有的 <span class="string">&quot;(a)&quot;</span> 替换为 <span class="string">&quot;yes&quot;</span> 。</span><br><span class="line">注意，不在括号里的 <span class="string">&quot;a&quot;</span> 不需要被替换。</span><br></pre></td></tr></table></figure><hr><p>看到找对应值的题，首先想到了map,然后题意告诉了我们并不需要保持map有序，所以使用unordered_map,将knowledge的值提取出来放入map,然后判断括号内的内容，找到了则替换成unordered_map[key],没找到则替换成‘？’.然后使用一个字符串保存所有结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">evaluate</span><span class="params">(string s, vector&lt;vector&lt;string&gt;&gt;&amp; knowledge)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;string,string&gt; maps;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(vector&lt;string&gt; x : knowledge)</span><br><span class="line">        &#123;</span><br><span class="line">            maps[x[<span class="number">0</span>]] = x[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ssize = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ssize ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                string tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">while</span>(s[i]!=<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp += s[i++];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(maps.<span class="built_in">find</span>(tmp)!=maps.<span class="built_in">end</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    res+=maps[tmp];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    res+=<span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res+=s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="第四题-好因子的最大数目"><a class="header-anchor" href="#第四题-好因子的最大数目">¶</a>第四题-好因子的最大数目</h2><p>时间不够没写出来，但看上去只需要维持一个素数表，利用空间换取时间，然后做到因数拆分就行了，对其因数加以判断就行了，需要注意的应该就是值太大要利用快速幂取模。</p><p>附上<a href="https://leetcode-cn.com/problems/maximize-number-of-nice-divisors/solution/c-python3-jian-sheng-zi-zheng-shu-chai-f-0980/">大佬</a>题解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxNiceDivisors</span><span class="params">(<span class="keyword">int</span> primeFactors)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> n = primeFactors;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> tmp = n / <span class="number">3</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">f</span>(<span class="number">3</span>, tmp) % <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">f</span>(<span class="number">3</span>, tmp<span class="number">-1</span>) * <span class="number">4</span> % <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">f</span>(<span class="number">3</span>, tmp) * <span class="number">2</span> % <span class="number">1000000007</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">f</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> n)</span>   </span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res *= a;</span><br><span class="line">                res %= <span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            a *= a;</span><br><span class="line">            a %= <span class="number">1000000007</span>;</span><br><span class="line">            n /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Leetcode-第243场周赛-创新奇智-力扣&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#Leetcode-第243场周赛-创新奇智-力扣&quot;&gt;¶&lt;/a&gt;Leetcode 第243场周赛 创新奇智&amp;amp;力扣&lt;/h2&gt;
&lt;p&gt;本次差点全A</summary>
      
    
    
    
    <category term="竞赛" scheme="http://example.com/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="Leetcode周赛复现" scheme="http://example.com/tags/Leetcode%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 173.二叉搜索树迭代器</title>
    <link href="http://example.com/2021/03/28/leetcode173/"/>
    <id>http://example.com/2021/03/28/leetcode173/</id>
    <published>2021-03-28T04:29:17.196Z</published>
    <updated>2021-03-28T04:48:05.421Z</updated>
    
    <content type="html"><![CDATA[<h2 id="173-二叉搜索树迭代器"><a class="header-anchor" href="#173-二叉搜索树迭代器">¶</a>173. 二叉搜索树迭代器</h2><p>实现一个二叉搜索树迭代器类BSTIterator ，表示一个按中序遍历二叉搜索树（BST）的迭代器：<br><kbd>BSTIterator(TreeNode root)</kbd> 初始化 BSTIterator 类的一个对象。BST 的根节点 root 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。<br><kbd>boolean hasNext()</kbd> 如果向指针右侧遍历存在数字，则返回 true ；否则返回 false 。<br><kbd>int next()</kbd>将指针向右移动，然后返回指针处的数字。<br>注意，指针初始化为一个不存在于 BST 中的数字，所以对 next() 的首次调用将返回 BST 中的最小元素。</p><p>你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 的中序遍历中至少存在一个下一个数字。</p><img src="https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png">  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[<span class="string">&quot;BSTIterator&quot;</span>, <span class="string">&quot;next&quot;</span>, <span class="string">&quot;next&quot;</span>, <span class="string">&quot;hasNext&quot;</span>, <span class="string">&quot;next&quot;</span>, <span class="string">&quot;hasNext&quot;</span>, <span class="string">&quot;next&quot;</span>, <span class="string">&quot;hasNext&quot;</span>, <span class="string">&quot;next&quot;</span>, <span class="string">&quot;hasNext&quot;</span>]</span><br><span class="line">[[[<span class="number">7</span>, <span class="number">3</span>, <span class="number">15</span>, null, null, <span class="number">9</span>, <span class="number">20</span>]], [], [], [], [], [], [], [], [], []]</span><br><span class="line">输出</span><br><span class="line">[null, <span class="number">3</span>, <span class="number">7</span>, <span class="literal">true</span>, <span class="number">9</span>, <span class="literal">true</span>, <span class="number">15</span>, <span class="literal">true</span>, <span class="number">20</span>, <span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">BSTIterator bSTIterator = <span class="keyword">new</span> <span class="built_in">BSTIterator</span>([<span class="number">7</span>, <span class="number">3</span>, <span class="number">15</span>, null, null, <span class="number">9</span>, <span class="number">20</span>]);</span><br><span class="line">bSTIterator.<span class="built_in">next</span>();    <span class="comment">// 返回 3</span></span><br><span class="line">bSTIterator.<span class="built_in">next</span>();    <span class="comment">// 返回 7</span></span><br><span class="line">bSTIterator.<span class="built_in">hasNext</span>(); <span class="comment">// 返回 True</span></span><br><span class="line">bSTIterator.<span class="built_in">next</span>();    <span class="comment">// 返回 9</span></span><br><span class="line">bSTIterator.<span class="built_in">hasNext</span>(); <span class="comment">// 返回 True</span></span><br><span class="line">bSTIterator.<span class="built_in">next</span>();    <span class="comment">// 返回 15</span></span><br><span class="line">bSTIterator.<span class="built_in">hasNext</span>(); <span class="comment">// 返回 True</span></span><br><span class="line">bSTIterator.<span class="built_in">next</span>();    <span class="comment">// 返回 20</span></span><br><span class="line">bSTIterator.<span class="built_in">hasNext</span>(); <span class="comment">// 返回 False</span></span><br></pre></td></tr></table></figure><p>提示：</p><p>树中节点的数目在范围 [1, 10^5] 内<br>0 &lt;= Node.val &lt;= 10^6<br>最多调用 10^5 次 hasNext 和 next 操作</p><hr><p>利用栈来实现迭代写法，因为是中序遍历，所以遍历顺序为<kbd>左-&gt;头-&gt;右</kbd></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode * cur;</span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BSTIterator</span>(TreeNode* root):<span class="built_in">cur</span>(root) &#123;</span><br><span class="line">        ans = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>) <span class="comment">//将cur指针不断指向当前节点的左子树</span></span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(cur);</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = s.<span class="built_in">top</span>(); <span class="comment">//得到最后一个左子树的结点</span></span><br><span class="line">        s.<span class="built_in">pop</span>(); <span class="comment">//弹出该结点</span></span><br><span class="line">        ans = cur-&gt;val;  <span class="comment">//得到父节点的值</span></span><br><span class="line">        cur = cur-&gt;right; <span class="comment">//符合 左-&gt;父节点-&gt;右</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!s.<span class="built_in">empty</span>() || cur != <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your BSTIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * BSTIterator* obj = new BSTIterator(root);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;next();</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;hasNext();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;173-二叉搜索树迭代器&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#173-二叉搜索树迭代器&quot;&gt;¶&lt;/a&gt;173. 二叉搜索树迭代器&lt;/h2&gt;
&lt;p&gt;实现一个二叉搜索树迭代器类BSTIterator ，表示一个按中序遍历二叉搜索树（BST）</summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
</feed>
