<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-03-31T14:25:11.074Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode每日一题 90.子集 II</title>
    <link href="http://example.com/2021/03/31/leetcode90/"/>
    <id>http://example.com/2021/03/31/leetcode90/</id>
    <published>2021-03-31T14:02:02.973Z</published>
    <updated>2021-03-31T14:25:11.074Z</updated>
    
    <content type="html"><![CDATA[<h2 id="90-子集-II"><a class="header-anchor" href="#90-子集-II">¶</a>90. 子集 II</h2><p>给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。</p><p>示例 1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出：[[],[<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">2</span>],[<span class="number">2</span>,<span class="number">2</span>]]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>]</span><br><span class="line">输出：[[],[<span class="number">0</span>]]</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;= nums.length &lt;= 10</li><li>-10 &lt;= nums[i] &lt;= 10</li></ul><p>本题用回溯算法比较容易理解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; sub;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">back</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(sub);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start ; i &lt; size ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; start &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            sub.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">back</span>(nums,i+<span class="number">1</span>);</span><br><span class="line">            sub.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">       res.<span class="built_in">clear</span>();</span><br><span class="line">       sub.<span class="built_in">clear</span>();</span><br><span class="line">       <span class="keyword">this</span>-&gt;size = nums.<span class="built_in">size</span>();</span><br><span class="line">       <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">       <span class="built_in">back</span>(nums,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先将nums排序，因为这样才能达到去重的目的，后面说。<br>start是每次组合的首地址，直接看循环，分析if为什么这样写</p><hr><p>设置i&gt;start是为了防止第一次循环就判断nums[i] == nums[i-1],这不是我们要判断的范围，因为i==start时，明显我们只有一个元素进来。<br>nums[i] == nums[i-1] 是为了去重，有点不好解释，我们就这样想象,举个例子[1,2,3,3],start是0的时候我们从1进入，然后递归进入back(),不管它子递归的循环，我们就只看第一次递归的循环，是不是会得到[1,2,3,3]，你们可能会说，你不是设置了nums[i] == nums[i-1]就continue吗，为什么会得到[1,2,3,3]，这就是因为前面有个i&gt;start，但如果我们在子循环时，也就是此时sub里面有[1,2]时的递归层，我们遍历到第一个3，加进去sub = [1,2,3]，此时i明显已经大于start，我们不会再得到第二个[1,2,3]，此时这个3是第4个3.</p><hr><p>用一个非常妙的解释方法就是，把整个结构想象成一个树，层相同是不允许的，树枝相同是允许的。<br><img src="https://note.youdao.com/yws/api/personal/file/WEB5d691b3c537e26e9e9bc35f74ba68abe?method=download&shareKey=1f1d9dff89c143e4999f15294b65158d"></p><p><kbd>i &gt; start &amp;&amp; nums[i] == nums[i-1]</kbd>就诠释了这种判断。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;90-子集-II&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#90-子集-II&quot;&gt;¶&lt;/a&gt;90. 子集 II&lt;/h2&gt;
&lt;p&gt;给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。&lt;/p&gt;
&lt;p&gt;解集 不</summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL(二) 绘制一个及多个三角形</title>
    <link href="http://example.com/2021/03/30/OpenGL-Triangle/"/>
    <id>http://example.com/2021/03/30/OpenGL-Triangle/</id>
    <published>2021-03-30T12:57:15.591Z</published>
    <updated>2021-03-31T16:06:16.986Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OpenGL-二-绘制一个及多个三角形"><a class="header-anchor" href="#OpenGL-二-绘制一个及多个三角形">¶</a>OpenGL(二) 绘制一个及多个三角形</h2><p><kbd><font size=2 color=red>注：本文仅供自己以及OPENGL初学者共同学习进步，并无实际教学意义，不过会对自己学习中遇到的关键点加上个人解释。应该会对初学者有所帮助，如有错误请指正！</font></kbd></p><hr><p>来到初学者最容易弃坑的地方了，因为这个地方实在是很多东西难以理解，不过，我们必须尽可能理解多一点，就算是算不上正确的观念，我们也只能强吃下去，等学到后面自己纠正自己，因为网上实在是找不到什么详细的教程来解释我们这些初学者的问题，也许这些在别人眼里都不算问题，只能自己一步一步慢慢摸索咯。</p><hr><p>不过这篇文章，我会试着解释很多我之前学习这个地方的时候诸多的疑惑，我相信有很多初学者会跟我抱有相同的问题，所以我会以初学者的角度，去解释所有的东西，并且在基础上加上官方解释，以显得我们不是在学一加一等于二。（还是建议先去看完learnOpenGL中文里面的你好三角形章节，带上自己的理解，再回来看这篇文章)</p><p>来梳理一下我们这篇文章要了解的东西：</p><ul><li>顶点数组对象(Vertex Array Object) VAO 是什么，有什么作用？</li><li>顶点缓冲对象(Vertex Buffer Object) VBO 是什么，有什么作用，跟VAO的关系？</li><li>索引缓冲对象(Element Buffer Object) EBO 是什么，跟VBO有什么区别？</li><li>编程时的规则是怎样，跟OpenGL特性的关联。</li><li>重点：使用上面东西时经历的过程。</li></ul><hr><p>就从简单的屏幕绘制说起吧，Opengl是一个3D的工作空间，不过我们要绘制的是2D事物，在高中大家都有了解到三维坐标吧(x,y,z),在图形学里，简单来说，x是左右,y是上下,z是前后，其实还有个w,用来区分向量和点。<br>那么我们要绘制一个三角形，要做的工作是什么呢？</p><hr><p>我们可能一开始都会这么想，画个三角形不就是给定三个坐标，然后让这三个坐标连起来不就行了吗。确实，对于“人”来说，就是这么简单，可惜我们要告诉一个只认得1和0的莫得感情的机器这些东西，直接对话吗？不太现实，当然，我们也不用扯的太底层，我只是说我们要完成一个什么样的过程才能让电脑明白我们的代码。</p><p>首先是给定坐标，这是必须的，那么坐标用什么表示呢，数组，都能想到吧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line"><span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// x1 y1 z1</span></span><br><span class="line"> <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// x2 y2 z2 因为我们只是画个2D的三角形，所以不用管远近，一律设为</span></span><br><span class="line"> <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// x3 y3 z3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>好的，坐标给出来了，不过这是我们眼中的坐标，因为我们知道，但OpenGL呢，你给它这9个浮点数，它可不能自己识别这9个数字然后自己乖乖画个三角形出来。所以我们要利用OpenGL里面的“工具”。</p><p>OK，第一项内容就是数据，看到了我们刚刚定义的三个坐标的数组，这就是我们要交给OpenGL的数据，那么OpenGL可不能直接认下你这个数组，所以要用一个东西，<kbd>VBO</kbd>登场了，<font color=red>是OpenGL里面专门存储各种数据的对象</font>，我们要用到它，把这个数组交给VBO是我们的第一步。</p><hr><p>那么我们开始创建一个VBO:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VBO;<span class="comment">//变量名什么的无所谓，你叫 ABC 都行</span></span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>,&amp;VBO);</span><br><span class="line"></span><br><span class="line"><span class="comment">//好的，现在我们有一个VBO了，接下来就是绑定它</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER,VBO);</span><br><span class="line"><span class="comment">//然后将上面的vertices数组给这个VBO；</span></span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in"><span class="keyword">sizeof</span></span>(vertices), vertices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure><p>先解释下<kbd>glGenBuffers()</kbd>,我相信有不少人仍然对这个函数里面的两个参数抱有疑惑，如果你只看了learnOpenGL的话，可能并没有实际理解这两个参数的意义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glGenBuffers</span><span class="params">(GLsizei n,GLuint * buffers)</span></span>;</span><br><span class="line"> </span><br><span class="line">n - Specifies the number of buffer object names to be generated.</span><br><span class="line">buffers - Specifies an array in which the generated buffer object names are stored.</span><br><span class="line"></span><br><span class="line">glGenBuffers returns n buffer object names in buffers. There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to glGenBuffers.</span><br><span class="line"></span><br><span class="line">Buffer object names returned by a call to glGenBuffers are <span class="keyword">not</span> returned by subsequent calls, unless they are first deleted with glDeleteBuffers.</span><br><span class="line"></span><br><span class="line">No buffer objects are associated with the returned buffer object names until they are first bound by calling glBindBuffer.</span><br><span class="line"></span><br><span class="line">n - 指定要生成的缓冲区对象名称的数量。</span><br><span class="line">buffers - 指定存储缓冲区对象名称的数组。</span><br><span class="line"></span><br><span class="line">glGenBuffers返回n个缓冲区对象名。不能保证这些名称形成一个连续的整数集；但是，可以保证在调用glGenBuffers之前，没有一个返回的名称是正在使用的。</span><br><span class="line"></span><br><span class="line">调用glGenBuffers返回的缓冲区对象名称不会被后续调用返回，除非先用glDeleteBuffers删除它们。</span><br><span class="line"></span><br><span class="line">在调用glBindBuffer首次绑定之前，没有任何缓冲区对象与返回的缓冲区对象名相关联。</span><br></pre></td></tr></table></figure><p>目前不要理解太深了，不要被官方文档给吓到了，你只需知道第一个参数是数量，第二个参数是变量名就行。</p><hr><p>好的，说完<kbd>glGenBuffers()</kbd>,最让初学者疑惑的东西来了。<kbd>glBindBuffer()</kbd>-绑定是什么东西，还有下面那个函数<kbd>glBufferData()</kbd>看上去跟我们创建的VBO没半点关系，为什么说是将我们刚刚建立的数组vertices丢进了这个VBO里。请看下面这幅图：</p><img src="https://note.youdao.com/yws/api/personal/file/WEB9668a8abf8d58bba5cd7fb91976ab3bf?method=download&shareKey=2b803bbd2c5adc818e7f249c0ba8aeef"><p><kbd>glBindBuffer(GL_ARRAY_BUFFER, VBO);</kbd><br>告诉Opengl，VBO是GL_ARRAY_BUFFER类型的缓冲对象并且将VBO绑定到GL_ARRAY_BUFFER缓冲区.<br><kbd>glBufferData(GL_ARRAY_BUFFER,…,…,…)</kbd>目标缓冲类型GL_ARRAY_BUFFER，意思就是把数据发送到GL_ARRAY_BUFFER缓冲区上，而刚刚我们已经将VBO与GL_ARRAY_BUFFER缓冲绑定在一起了，所以任何传送给GL_ARRAY_BUFFER缓冲的数据都会传送到我们刚刚绑定的VBO身上，只要我们不用glBindBuffer()去绑定另外的VBO1,VBO2…Balaaa…，就会一直作用到VBO身上。</p><hr><p>目前为止，数据传递就已经解决了吧，那么接下来该干什么呢，当然是给OpenGL翻译这堆数据啊，虽然我们已经有了存好数据的VBO，但是你不告诉OpenGL怎么去读取VBO的内容，还是不行的，因为它虽然能拿到这些数据，不过它不知道你是第一列是XYZ，还是第一行是XYZ，所以你得设置一个读取规则，并且让OpenGl知道。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT,GL_FALSE, <span class="number">3</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>); <span class="comment">//告诉OPENGL如何处理顶点数据</span></span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>先别管第二行，我们直接观察第一个函数<kbd>glVertexAttribPointer()</kbd>，先看下面一幅图：</p><img src="https://learnopengl-cn.github.io/img/01/04/vertex_attribute_pointer.png"><p>和我们刚刚建立的数组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line"><span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// x1 y1 z1</span></span><br><span class="line"> <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// x2 y2 z2 </span></span><br><span class="line"> <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// x3 y3 z3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在来分析<kbd>glVertexAttribPointer()</kbd>的参数</p><ul><li>第一个参数，0，意思就是我们从第零个位置开始读取，因为我们数组中第0个就已经是我们要取的坐标之一了，也就是x1</li><li>第二个参数，3，也就是告诉我们，每3个数，算作一个顶点，每三个数分别代表xyz</li><li>第三个参数，GL_FLOAT，也就是说我们数组中的每个数据是浮点型</li><li>第四个参数，GL_FALSE，定义我们是否希望数据被标准化(Normalize)。如果我们设置为GL_TRUE，所有数据都会被映射到0（对于有符号型signed数据是-1）到1之间。我们把它设置为GL_FALSE。（这个可能你得懂一点图形学才知道标准化有什么意思，不过目前就先别深究了，以后会懂的）</li><li>第五个参数，3 * sizeof(float),我们已经知道了每3个float数据为一个顶点，所以3个数据的长度为 3乘以一个float数据的字节大小。这是告诉opengl一个顶点的数据长度。</li><li>第六个参数，它表示位置数据在缓冲中起始位置的偏移量(Offset)，而且由于它的类型是void,所以要强转一下。因为你数组中的第一个顶点的信息是从0开始获取的，所以这里设为0，假如你数组中第一行是其他信息，从第二行开始才是你的顶点信息，那就设为3，从第4个（0,1,2,3)数据开始读取数据。</li></ul><hr><p>下面解释VAO，我相信大部分初学者肯定难以理解VAO的作用在哪，毕竟VAO这名字取得我们根本想不到它的作用是什么，我尝试用最简单的方法去理解它。</p><p>就拿我们刚刚建立的VBO缓冲来当例子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VBO;<span class="comment">//变量名什么的无所谓，你叫 ABC 都行</span></span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>,&amp;VBO);</span><br><span class="line"></span><br><span class="line"><span class="comment">//好的，现在我们有一个VBO了，接下来就是绑定它</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER,VBO);</span><br><span class="line"><span class="comment">//然后将上面的vertices数组给这个VBO；</span></span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in"><span class="keyword">sizeof</span></span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">//告诉OPENGL如何处理顶点数据</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT,GL_FALSE, <span class="number">3</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>); </span><br></pre></td></tr></table></figure><p>如果不用VAO，我们用VBO就能画出一个三角形来了（只不过现在版本强制我们需要使用VAO，不然不准我们绘制，所以本菜鸟也不能去实践测试），说到底要绘制三角形，只要数据到位了，数据处理规则到位了，确切的传给显卡了，那么就能绘制出来。<br>这只是一个三角形，但假如我们要绘制非常非常多的图形，并且有非常多的VBO，各个VBO都有相应的读取规则呢。我们这样想，假设我们有VBO1,VBO2。<br>每次绘制图像前，我们都要像上面那样输入很多行，我刚把VBO1跟GL_ARRAY_BUFFER绑定，设置了读取规则，然后要我绘制VBO2中的数据，我又让VBO2跟GL_ARRAY_BUFFER绑定设置读取规则，结果现在又要我绘制VBO1，我又要重复输入上面那几行代码。就是这样一个过程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VBO1,VBO2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>,&amp;VBO1);</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>,&amp;VBO2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时要使用VBO1</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER,VBO1);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in"><span class="keyword">sizeof</span></span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT,GL_FALSE, <span class="number">3</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时要使用VBO2</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER,VBO2);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in"><span class="keyword">sizeof</span></span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT,GL_FALSE, <span class="number">3</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时又要使用VBO1</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER,VBO2);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in"><span class="keyword">sizeof</span></span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT,GL_FALSE, <span class="number">3</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//假如我们又要用VBO2，又来一遍</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER,VBO2);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in"><span class="keyword">sizeof</span></span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT,GL_FALSE, <span class="number">3</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>这才两个VBO，我们就要这样不断的设置，是不是特别麻烦。</p><p>如果有VAO：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VAO1,VAO2,VBO1,VBO2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO1);</span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO2);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO1);</span><br><span class="line">------------------此区域内为VAO1的作用域，在这里面对VBO1的操作都会存储在VAO1里面</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>,&amp;VBO1);</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>,&amp;VBO2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER,VBO1);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in"><span class="keyword">sizeof</span></span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT,GL_FALSE, <span class="number">3</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line">------------------ </span><br><span class="line"><span class="built_in">glBindVertexArray</span>(<span class="number">0</span>); <span class="comment">//解绑VAO1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO2);</span><br><span class="line">------------------此区域内为VAO2的作用域，在这里面对VBO2的操作都会存储在VAO1里面</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER,VBO2);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in"><span class="keyword">sizeof</span></span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT,GL_FALSE, <span class="number">3</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>); </span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line">------------------</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(<span class="number">0</span>); <span class="comment">//解绑VAO2</span></span><br></pre></td></tr></table></figure><p>完成上面的操作后：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此时要使用VBO1</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO1);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时要使用VBO2</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO2);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时又要使用VBO1</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO1);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//假如我们又要用VBO2，又来一遍</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO2);</span><br></pre></td></tr></table></figure><hr><p>是不是感觉瞬间方便很多了。可以吧VAO理解为记忆了一个VBO的操作，并且想用只要绑定相应的VAO就能用了，不用再重新进行一遍VBO的操作。</p><hr><p>好的，现在我们利用VAO和VBO画一个三角形~那是不可能的，因为还有个最最重要的东西，着色器，也是GPU的核心，不过我们只需要完成两个最基础的着色器，就能绘制我们想要的东西，分别是顶点着色器，还有片段着色器，因为这两个是必须品咯，其他着色器都可以不要，但这两个是绘制图形的基础，顶点着色器接收我们输入的顶点数据，也就是之前用VBO往GL_ARRAY_BUFFER里面输的东西，片段着色器就是用来给三角形上色的。因为C++又不能直接识别着色器语言，我们只能用opengl编译着色器语言，然后使用它。</p><p>首先是设置两个着色器，用字符串来写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顶点着色器</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *vertexShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line"><span class="string">&quot;layout (location = 0) in vec3 aPos;\n&quot;</span></span><br><span class="line"><span class="string">&quot;void main()\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line"><span class="string">&quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#125;\0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * fragmentShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line"><span class="string">&quot;out vec4 FragColor;\n&quot;</span></span><br><span class="line"><span class="string">&quot;void main()\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line"><span class="string">&quot;   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#125;\0&quot;</span>;</span><br></pre></td></tr></table></figure><p>还记得上面的<kbd>glEnableVertexAttribArray(0);</kbd>吗，再看看着色器源码里面的<kbd>layout (location = 0)</kbd>,这两个0有什么关系呢，先来看一幅图：<br><img src="https://learnopengl-cn.github.io/img/01/04/vertex_array_objects.png"></p><p>VAO里面可不止能存一个VBO中的一种信息，VBO里面除了顶点数据，可能还包括颜色和纹理数据等等，我们刚刚是将顶点数据存在了类似图中的VAO1的<kbd>attribute pointer 0</kbd>里面，所以0是我们所需要的信息的位置，glEnableVertexAttribArray(0);是将VBO这系列操作放在0，而layout (location = 0)是告诉顶点着色器传进来的顶点信息是在VAO的0的位置。片段着色器就不多说了，相信learnOpenGL里面已经讲到我们需要理解的地步了，接下来使用着色器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> vertexShader;  <span class="comment">//输出一个图像到屏幕，至少需要顶点着色器与片段着色器</span></span><br><span class="line">vertexShader = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER); <span class="comment">//创建顶点着色器</span></span><br><span class="line"><span class="built_in">glShaderSource</span>(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>); <span class="comment">//绑定着色器源码 </span></span><br><span class="line"><span class="built_in">glCompileShader</span>(vertexShader); <span class="comment">//编译着色器源码</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> fragmentShader; <span class="comment">//同上 片段着色器</span></span><br><span class="line">fragmentShader = <span class="built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);</span><br><span class="line"><span class="built_in">glShaderSource</span>(fragmentShader,<span class="number">1</span>,&amp;fragmentShaderSource,<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">glCompileShader</span>(fragmentShader);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> shaderProgram;</span><br><span class="line">shaderProgram = <span class="built_in">glCreateProgram</span>(); <span class="comment">// 创建着色器程序</span></span><br><span class="line"><span class="built_in">glAttachShader</span>(shaderProgram, vertexShader); <span class="comment">//将两个着色器丢进程序里</span></span><br><span class="line"><span class="built_in">glAttachShader</span>(shaderProgram, fragmentShader);</span><br><span class="line"><span class="built_in">glLinkProgram</span>(shaderProgram); <span class="comment">//并且链接两个着色器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">glDeleteShader</span>(vertexShader); <span class="comment">//因为已经把着色器对象链接到程序对象里了，已经不需要了，就可以删除了</span></span><br><span class="line"><span class="built_in">glDeleteShader</span>(fragmentShader);</span><br></pre></td></tr></table></figure><p>之后在渲染循环里使用<kbd>glUseProgram(shaderProgram);</kbd>就能使用我们创建的着色器程序绘制图像了。</p><p>附上源码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GLEW_STATIC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow * window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow * window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line"><span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.3f</span>,</span><br><span class="line"> <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.3f</span>,</span><br><span class="line"> <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.3f</span>,</span><br><span class="line"> <span class="number">0.8f</span>,  <span class="number">0.8f</span>, <span class="number">0.3f</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *vertexShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line"><span class="string">&quot;layout (location = 0) in vec3 aPos;\n&quot;</span></span><br><span class="line"><span class="string">&quot;void main()\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line"><span class="string">&quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#125;\0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * fragmentShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line"><span class="string">&quot;out vec4 FragColor;\n&quot;</span></span><br><span class="line"><span class="string">&quot;void main()\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line"><span class="string">&quot;   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#125;\0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">glfwInit</span>(); <span class="comment">//初始化glfw</span></span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>); <span class="comment">//版本号</span></span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>); <span class="comment">//代表glfw3.3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); <span class="comment">//MAC 系统</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建窗口</span></span><br><span class="line">GLFWwindow * window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;demo&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//判断是否创建成功</span></span><br><span class="line"><span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">glfwTerminate</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">glfwMakeContextCurrent</span>(window); <span class="comment">//设置当前线程上下文 意思就是在切换下一个状态之前，进行的所有操作都是对 window这个对象进行的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化glad , glad是用来管理opengl的函数指针的，所以启用opengl任何函数之前需要初始化glad</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始渲染之前先告诉opengl渲染窗口的尺寸大小，以及坐标</span></span><br><span class="line"><span class="comment">//注意，opengl坐标范围为-1到1 ,与屏幕坐标之间存在映射关系</span></span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">600</span>); </span><br><span class="line"><span class="comment">//注册该函数，告诉opengl每次window调整大小时都调用该函数</span></span><br><span class="line"><span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback); </span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VBO,VAO;</span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO); <span class="comment">//创建一个VBO</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER,VBO);<span class="comment">//绑定这个VBO，在下一次绑定之前，所有的操作都是对这个VBO进行</span></span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in"><span class="keyword">sizeof</span></span>(vertices), vertices, GL_STATIC_DRAW); <span class="comment">//现在已经将vertices这个数据传递到了显存，而上面的VBO对象管理这些顶点数据</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT,GL_FALSE, <span class="number">3</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>); <span class="comment">//告诉OPENGL如何处理顶点数据</span></span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>); <span class="comment">//解绑VAO</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> vertexShader;  <span class="comment">//输出一个图像到屏幕，至少需要顶点着色器与片段着色器</span></span><br><span class="line">vertexShader = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER); <span class="comment">//创建顶点着色器</span></span><br><span class="line"><span class="built_in">glShaderSource</span>(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>); <span class="comment">//绑定着色器源码 </span></span><br><span class="line"><span class="built_in">glCompileShader</span>(vertexShader); <span class="comment">//编译着色器源码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> success;</span><br><span class="line"><span class="keyword">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line"><span class="built_in">glGetShaderiv</span>(vertexShader, GL_COMPILE_STATUS, &amp;success); <span class="comment">//判断着色器是否创建成功</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!success)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">glGetShaderInfoLog</span>(vertexShader,<span class="number">512</span>,<span class="literal">NULL</span>,infoLog);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl; <span class="comment">//打印错误信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> fragmentShader; <span class="comment">//同上 片段着色器</span></span><br><span class="line">fragmentShader = <span class="built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);</span><br><span class="line"><span class="built_in">glShaderSource</span>(fragmentShader,<span class="number">1</span>,&amp;fragmentShaderSource,<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">glCompileShader</span>(fragmentShader);</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> shaderProgram;</span><br><span class="line">shaderProgram = <span class="built_in">glCreateProgram</span>(); <span class="comment">// 创建着色器程序</span></span><br><span class="line"><span class="built_in">glAttachShader</span>(shaderProgram, vertexShader); <span class="comment">//将两个着色器丢进程序里</span></span><br><span class="line"><span class="built_in">glAttachShader</span>(shaderProgram, fragmentShader);</span><br><span class="line"><span class="built_in">glLinkProgram</span>(shaderProgram); <span class="comment">//并且链接两个着色器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">glDeleteShader</span>(vertexShader); <span class="comment">//因为已经把着色器对象链接到程序对象里了，已经不需要了，就可以删除了</span></span><br><span class="line"><span class="built_in">glDeleteShader</span>(fragmentShader);</span><br><span class="line"></span><br><span class="line"><span class="comment">//至此顶点数据已经全部传入GPU,以及告诉了GPU如何在顶点和片段着色器中处理数据</span></span><br><span class="line"><span class="comment">//但OPENGL还必须知道如何解释内存中的顶点数据，以及如何将顶点数据链接到顶点着色器的属性上</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//开始渲染循环</span></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window)) <span class="comment">// 检查glfw是否被要求退出</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">processInput</span>(window);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glUseProgram</span>(shaderProgram); <span class="comment">//使用该函数后，每个着色器调用和渲染都会使用这个程序对象</span></span><br><span class="line"><span class="comment">//glPolygonMode(GL_FRONT_AND_BACK, GL_LINE); //线框模式</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glfwSwapBuffers</span>(window); <span class="comment">//输出颜色缓冲</span></span><br><span class="line"><span class="built_in">glfwPollEvents</span>(); <span class="comment">//监视事件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放内存</span></span><br><span class="line"><span class="built_in">glfwTerminate</span>(); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow * window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> <span class="comment">//随用户调整窗口大小而变化视口大小</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow * window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line"><span class="built_in">glfwSetWindowShouldClose</span>(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，恭喜你，第一个三角形就完成了。</p><hr><p>到了最后，我们了说一下EBO，其实实质上，EBO和VBO是一个东西，不过从功能上还是将两者区分了出来，只不过是换了个名字，VBO存的是数据，EBO存的也是数据，不过是调用数据的索引数据，比如说我们要画一个4边型，但我们绘制的是GL_TRIANGLES，所以我们用两个三角形组成一个四边形，也就是这样：</p><img src="https://learnopengl.com/img/getting-started/hellotriangle2.png">但是如果我们用VAO直接绘制，其实是有两个点重复绘制了的，也就是左上角和右下角，这两点是重复绘制了的，我们不希望这种重复绘制的事情发生，这时我们就可以用到索引缓冲对象EBO，其实看我不用EBO和用EBO要建立的两个数组，一下就能明白EBO是用来干嘛的了：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不用EBO，VBO数组必须这样设</span></span><br><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="comment">// first triangle</span></span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// top right</span></span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// bottom right</span></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// top left </span></span><br><span class="line">    <span class="comment">// second triangle</span></span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// bottom right</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// bottom left</span></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// top left</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//明显有重复点需要绘制</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">//而使用EBO，VBO我们则可以这样设置</span></span><br><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">//右上角</span></span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">//右下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">//左下角</span></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">//左上角 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//很明显，去除了重复点</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> indices[] = &#123; </span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>,   <span class="comment">// 第一个三角形</span></span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>    <span class="comment">// 第二个三角形</span></span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><p>也就是用索引的方式去调用每个每个顶点来绘制。<br>直接上源码吧：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GLEW_STATIC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow * window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow * window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line"> <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">//右上角</span></span><br><span class="line"> <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">//右下角</span></span><br><span class="line"><span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">//左下角</span></span><br><span class="line"><span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">//左上角 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//很明显，去除了重复点</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> indices[] = &#123;</span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>,   <span class="comment">// 第一个三角形</span></span><br><span class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>    <span class="comment">// 第二个三角形</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *vertexShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line"><span class="string">&quot;layout (location = 0) in vec3 aPos;\n&quot;</span></span><br><span class="line"><span class="string">&quot;void main()\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line"><span class="string">&quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#125;\0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * fragmentShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line"><span class="string">&quot;out vec4 FragColor;\n&quot;</span></span><br><span class="line"><span class="string">&quot;void main()\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line"><span class="string">&quot;   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#125;\0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">glfwInit</span>(); <span class="comment">//初始化glfw</span></span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>); <span class="comment">//版本号</span></span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>); <span class="comment">//代表glfw3.3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); <span class="comment">//MAC 系统</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建窗口</span></span><br><span class="line">GLFWwindow * window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;demo&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//判断是否创建成功</span></span><br><span class="line"><span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">glfwTerminate</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">glfwMakeContextCurrent</span>(window); <span class="comment">//设置当前线程上下文 意思就是在切换下一个状态之前，进行的所有操作都是对 window这个对象进行的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化glad , glad是用来管理opengl的函数指针的，所以启用opengl任何函数之前需要初始化glad</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始渲染之前先告诉opengl渲染窗口的尺寸大小，以及坐标</span></span><br><span class="line"><span class="comment">//注意，opengl坐标范围为-1到1 ,与屏幕坐标之间存在映射关系</span></span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">600</span>);</span><br><span class="line"><span class="comment">//注册该函数，告诉opengl每次window调整大小时都调用该函数</span></span><br><span class="line"><span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VBO, VAO ,EBO;</span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO); <span class="comment">//创建一个VBO</span></span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;EBO);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);<span class="comment">//绑定这个VBO，在下一次绑定之前，所有的操作都是对这个VBO进行</span></span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in"><span class="keyword">sizeof</span></span>(vertices), vertices, GL_STATIC_DRAW); <span class="comment">//现在已经将vertices这个数据传递到了显存，而上面的VBO对象管理这些顶点数据</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>); <span class="comment">//告诉OPENGL如何处理顶点数据</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, EBO); <span class="comment">//绑定EBO</span></span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="built_in"><span class="keyword">sizeof</span></span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(<span class="number">0</span>); <span class="comment">//解绑VAO</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> vertexShader;  <span class="comment">//输出一个图像到屏幕，至少需要顶点着色器与片段着色器</span></span><br><span class="line">vertexShader = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER); <span class="comment">//创建顶点着色器</span></span><br><span class="line"><span class="built_in">glShaderSource</span>(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>); <span class="comment">//绑定着色器源码 </span></span><br><span class="line"><span class="built_in">glCompileShader</span>(vertexShader); <span class="comment">//编译着色器源码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> success;</span><br><span class="line"><span class="keyword">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line"><span class="built_in">glGetShaderiv</span>(vertexShader, GL_COMPILE_STATUS, &amp;success); <span class="comment">//判断着色器是否创建成功</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!success)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">glGetShaderInfoLog</span>(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl; <span class="comment">//打印错误信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> fragmentShader; <span class="comment">//同上 片段着色器</span></span><br><span class="line">fragmentShader = <span class="built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);</span><br><span class="line"><span class="built_in">glShaderSource</span>(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">glCompileShader</span>(fragmentShader);</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> shaderProgram;</span><br><span class="line">shaderProgram = <span class="built_in">glCreateProgram</span>(); <span class="comment">// 创建着色器程序</span></span><br><span class="line"><span class="built_in">glAttachShader</span>(shaderProgram, vertexShader); <span class="comment">//将两个着色器丢进程序里</span></span><br><span class="line"><span class="built_in">glAttachShader</span>(shaderProgram, fragmentShader);</span><br><span class="line"><span class="built_in">glLinkProgram</span>(shaderProgram); <span class="comment">//并且链接两个着色器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">glDeleteShader</span>(vertexShader); <span class="comment">//因为已经把着色器对象链接到程序对象里了，已经不需要了，就可以删除了</span></span><br><span class="line"><span class="built_in">glDeleteShader</span>(fragmentShader);</span><br><span class="line"></span><br><span class="line"><span class="comment">//至此顶点数据已经全部传入GPU,以及告诉了GPU如何在顶点和片段着色器中处理数据</span></span><br><span class="line"><span class="comment">//但OPENGL还必须知道如何解释内存中的顶点数据，以及如何将顶点数据链接到顶点着色器的属性上</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//开始渲染循环</span></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window)) <span class="comment">// 检查glfw是否被要求退出</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">processInput</span>(window);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glUseProgram</span>(shaderProgram); <span class="comment">//使用该函数后，每个着色器调用和渲染都会使用这个程序对象</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="comment">//glDrawArrays(GL_TRIANGLES, 0, 3);</span></span><br><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glfwSwapBuffers</span>(window); <span class="comment">//输出颜色缓冲</span></span><br><span class="line"><span class="built_in">glfwPollEvents</span>(); <span class="comment">//监视事件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放内存</span></span><br><span class="line"><span class="built_in">glfwTerminate</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow * window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> <span class="comment">//随用户调整窗口大小而变化视口大小</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow * window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line"><span class="built_in">glfwSetWindowShouldClose</span>(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>只是多了点EBO的部分，绘制函数改了一个罢了。<br>到这里，我相信你已经对VAO,VBO,EBO有初步的了解了，文章非常长，看到这里也非常不容易哈。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;OpenGL-二-绘制一个及多个三角形&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#OpenGL-二-绘制一个及多个三角形&quot;&gt;¶&lt;/a&gt;OpenGL(二) 绘制一个及多个三角形&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;&lt;font size=2 color=</summary>
      
    
    
    
    <category term="OPENGL" scheme="http://example.com/categories/OPENGL/"/>
    
    
    <category term="OPENGL学习" scheme="http://example.com/tags/OPENGL%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL(一) 渲染循环创建窗口</title>
    <link href="http://example.com/2021/03/30/OpenGL-window/"/>
    <id>http://example.com/2021/03/30/OpenGL-window/</id>
    <published>2021-03-30T08:49:48.270Z</published>
    <updated>2021-03-30T12:57:33.618Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OpenGL-一-渲染循环创建窗口"><a class="header-anchor" href="#OpenGL-一-渲染循环创建窗口">¶</a>OpenGL(一) 渲染循环创建窗口</h2><p><kbd><font size=2 color=red>注：本文仅供自己以及OPENGL初学者共同学习进步，并无实际教学意义，不过会对自己学习中遇到的关键点加上个人解释。应该会对初学者有所帮助，如有错误请指正！</font></kbd></p><p>上次我们已经配置好了<a href="openglconf.md">glfw + glad环境</a>,接下来就是我们实践使用的时候了。</p><hr><p>首先，我们先将要使用的头文件加进来，注意，这里先后顺序不能错：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>然后我们开始进入<kbd>main()</kbd>函数,初始化<kbd>glfw</kbd>,并且声明版本号：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">glfwInit</span>(); <span class="comment">//初始化glfw</span></span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>); <span class="comment">//版本号</span></span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>); <span class="comment">//代表glfw3.3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我这里使用的是3.3版本。<br>然后我们用<kbd>glfwCreateWindow()</kbd>函数创建一个窗口对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">glfwInit</span>(); <span class="comment">//初始化glfw</span></span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>); <span class="comment">//版本号</span></span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>); <span class="comment">//代表glfw3.3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建窗口</span></span><br><span class="line">GLFWwindow * window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//判断是否创建成功</span></span><br><span class="line"><span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">glfwTerminate</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window); <span class="comment">//设置当前线程上下文 意思就是在切换下一个状态之前，进行的所有操作都是对 window这个对象进行的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在源码注释里，<kbd>GLFWwindow</kbd>是&quot;brief Opaque window object&quot;，也就是简易窗口对象的意思。<br><kbd>glfwCreateWindow()</kbd>函数显而易见，第一个参数是宽度，第二个参数是高度，第三个是title，也就是窗口名称，后面两个参数现在用不到。当窗口创建失败时，<kbd>window</kbd>指针会指向NULL，我们可以利用这个来判断窗口是否创建成功。</p><p><kbd>glfwTerminate()</kbd>是释放资源的函数，当一切结束的时候，我们就要用到这个函数。<br><kbd>glfwMakeContextCurrent(window)</kbd>就如注释所说，OPENGL是讲状态的，只要我们不在当前线程设置其他上下文，它就会一直绑定当前设置的<kbd>window</kbd>窗口，之后的所有操作，就都是在这个<kbd>window</kbd>里进行.</p><hr><p>接下来我们初始化<kbd>glad</kbd>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">glfwInit</span>(); <span class="comment">//初始化glfw</span></span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>); <span class="comment">//版本号</span></span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>); <span class="comment">//代表glfw3.3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建窗口</span></span><br><span class="line">GLFWwindow * window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//判断是否创建成功</span></span><br><span class="line"><span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">glfwTerminate</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window); <span class="comment">//设置当前线程上下文 意思就是在切换下一个状态之前，进行的所有操作都是对 window这个对象进行的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始渲染之前先告诉opengl渲染窗口的尺寸大小，以及坐标</span></span><br><span class="line"><span class="comment">//注意，opengl坐标范围为-1到1 ,与屏幕坐标之间存 映射关系</span></span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">600</span>); </span><br><span class="line"><span class="comment">//注册该函数，告诉opengl每次window调整大小时都调用该函数</span></span><br><span class="line"><span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>glad是用来管理opengl的函数指针的，所以启用opengl任何函数之前需要初始化glad<br><kbd>glViewport()</kbd>是设置视口的，具体作用大概就是设置窗口的起始坐标，以及告诉opengl我们要渲染的窗口大小为800x600.<br><kbd>glfwSetFramebufferSizeCallback()</kbd>目的是为了当我们拖动窗口，造成窗口大小变化时，能够及时改变渲染的窗口尺寸,里面传入了我们自己设置的函数，可以看到函数内;我们在实时更改视口。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow * window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> <span class="comment">//随用户调整窗口大小而变化视口大小</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该准备的准备完了，可以开始渲染循环了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window)) <span class="comment">// 检查glfw是否被要求退出</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">glfwSwapBuffers</span>(window); <span class="comment">//交换前后缓冲</span></span><br><span class="line"><span class="built_in">glfwPollEvents</span>(); <span class="comment">//监视事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果跟着前面打没有打错的话，至此一个完整的黑色背景窗口就能出现了。</p><hr><p>来解释一下<kbd>glfwSwapBuffers()</kbd>,因为OPENGL是双缓冲，那么双缓冲的作用是什么呢？假如是单缓冲，由于屏幕上的像素绘制是由左到右，从上到下一个一个绘制的，如果缓冲量过大，那么可能会出现图像闪烁，但是如果是双缓冲，它是由前缓冲全部绘制好，然后再跟后缓冲互换，然后前后工作交替进行，这样子就解决了闪烁问题。所以也能理解这个函数为什么叫这么个名字了吧。</p><p>那么现在我们想给窗口背景改个色，该怎么弄呢，我们需要设置一个颜色缓冲。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br></pre></td></tr></table></figure><p><kbd>glClearColor()</kbd>是设置清空屏幕所使用的颜色，意思就是使用这个函数后，之后每次清屏，默认颜色都是我们这个函数所设置的颜色。然后<kbd>glClear()</kbd>就是清除颜色缓冲，也就是清屏，那么我们为什么每次循环都要<kbd>glClear()</kbd>呢，因为有些人可能认为，我都画上去了，为什么要清除屏幕，再绘制一次呢，因为在渲染循环里，你是一个在不断绘制图像的过程，如果不清屏，那么每次画的图像就会叠加，导致跟我们预想的绘制内容会出现很大差别，比如你只是要画一只鸭子，但你如果不使用<kbd>glClear()</kbd>,那可能就是成千上万只鸭子绘制在同一个地方，内容不断叠加。</p><p>最后我们再加入一个退出事件的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow * window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line"><span class="built_in">glfwSetWindowShouldClose</span>(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到一旦检测到我们按下ESC键，那么就会利用<kbd>glfwSetWindowShouldClose()</kbd>函数，传入true,使window窗口关闭，可以看到我们循环的条件是<kbd>while (!glfwWindowShouldClose(window))</kbd>。</p><p>接下来是完整源码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow * window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow * window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">glfwInit</span>(); <span class="comment">//初始化glfw</span></span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>); <span class="comment">//版本号</span></span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>); <span class="comment">//代表glfw3.3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建窗口</span></span><br><span class="line">GLFWwindow * window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//判断是否创建成功</span></span><br><span class="line"><span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">glfwTerminate</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window); <span class="comment">//设置当前线程上下文 意思就是在切换下一个状态之前，进行的所有操作都是对 window这个对象进行的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始渲染之前先告诉opengl渲染窗口的尺寸大小，以及坐标</span></span><br><span class="line"><span class="comment">//注意，opengl坐标范围为-1到1 ,与屏幕坐标之间存 映射关系</span></span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">600</span>); </span><br><span class="line"><span class="comment">//注册该函数，告诉opengl每次window调整大小时都调用该函数</span></span><br><span class="line"><span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window)) <span class="comment">// 检查glfw是否被要求退出</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">processInput</span>(window);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glfwSwapBuffers</span>(window); <span class="comment">//交换前后缓冲</span></span><br><span class="line"><span class="built_in">glfwPollEvents</span>(); <span class="comment">//监视事件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放内存</span></span><br><span class="line"><span class="built_in">glfwTerminate</span>(); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow * window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> <span class="comment">//随用户调整窗口大小而变化视口大小</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow * window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line"><span class="built_in">glfwSetWindowShouldClose</span>(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><img src="https://learnopengl-cn.github.io/img/01/03/hellowindow2.png">  <p>这样，一个基本完整的窗口就完成啦。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;OpenGL-一-渲染循环创建窗口&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#OpenGL-一-渲染循环创建窗口&quot;&gt;¶&lt;/a&gt;OpenGL(一) 渲染循环创建窗口&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;&lt;font size=2 color=red&gt;注：</summary>
      
    
    
    
    <category term="OPENGL" scheme="http://example.com/categories/OPENGL/"/>
    
    
    <category term="OPENGL学习" scheme="http://example.com/tags/OPENGL%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 74.搜索二维矩阵</title>
    <link href="http://example.com/2021/03/30/leetcode74/"/>
    <id>http://example.com/2021/03/30/leetcode74/</id>
    <published>2021-03-30T05:21:59.002Z</published>
    <updated>2021-03-30T08:49:06.404Z</updated>
    
    <content type="html"><![CDATA[<h2 id="74-搜索二维矩阵"><a class="header-anchor" href="#74-搜索二维矩阵">¶</a>74. 搜索二维矩阵</h2><p>编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p><p>-每行中的整数从左到右按升序排列。<br>-每行的第一个整数大于前一行的最后一个整数.</p><p>示例一：<br><img src="https://assets.leetcode.com/uploads/2020/10/05/mat.jpg"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>],[<span class="number">10</span>,<span class="number">11</span>,<span class="number">16</span>,<span class="number">20</span>],[<span class="number">23</span>,<span class="number">30</span>,<span class="number">34</span>,<span class="number">60</span>]], target = <span class="number">3</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>示例二：<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/mat2.jpg"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>],[<span class="number">10</span>,<span class="number">11</span>,<span class="number">16</span>,<span class="number">20</span>],[<span class="number">23</span>,<span class="number">30</span>,<span class="number">34</span>,<span class="number">60</span>]], target = <span class="number">13</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>m == matrix.length</li><li>n == matrix[i].length</li><li>1 &lt;= m, n &lt;= 100</li><li>-104 &lt;= matrix[i][j], target &lt;= 104</li></ul><hr><p>使用二分法，然后剪枝，对于每一行使用二分法，当target比当前行数尾的数还大时，直接去下一行搜寻。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(target &gt; matrix[i][n - <span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = left + ((right - left) / <span class="number">2</span>);</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][mid] == target)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][mid] &gt; target)&#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][mid] &lt; target)&#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;74-搜索二维矩阵&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#74-搜索二维矩阵&quot;&gt;¶&lt;/a&gt;74. 搜索二维矩阵&lt;/h2&gt;
&lt;p&gt;编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：&lt;/p&gt;
&lt;p&gt;-每行</summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 190.颠倒二进制位</title>
    <link href="http://example.com/2021/03/29/leetcode190/"/>
    <id>http://example.com/2021/03/29/leetcode190/</id>
    <published>2021-03-29T03:03:08.181Z</published>
    <updated>2021-03-29T09:26:18.321Z</updated>
    
    <content type="html"><![CDATA[<h2 id="190-颠倒二进制位"><a class="header-anchor" href="#190-颠倒二进制位">¶</a>190.颠倒二进制位</h2><p>颠倒给定的 32 位无符号整数的二进制位。</p><p>提示：</p><p>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。<br>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。</p><p>进阶:<br>如果多次调用这个函数，你将如何优化你的算法？</p><p>示例一：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">00000010100101000001111010011100</span></span><br><span class="line">输出: <span class="number">00111001011110000010100101000000</span></span><br><span class="line">解释: 输入的二进制串 <span class="number">00000010100101000001111010011100</span> 表示无符号整数 <span class="number">43261596</span>，</span><br><span class="line">     因此返回 <span class="number">964176192</span>，其二进制表示形式为 <span class="number">00111001011110000010100101000000</span>。</span><br></pre></td></tr></table></figure><p>示例二：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="number">11111111111111111111111111111101</span></span><br><span class="line">输出：<span class="number">10111111111111111111111111111111</span></span><br><span class="line">解释：输入的二进制串 <span class="number">11111111111111111111111111111101</span> 表示无符号整数 <span class="number">4294967293</span>，</span><br><span class="line">     因此返回 <span class="number">3221225471</span> 其二进制表示形式为 <span class="number">10111111111111111111111111111111</span> 。</span><br></pre></td></tr></table></figure><p>示例一：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">00000010100101000001111010011100</span></span><br><span class="line">输出：<span class="number">964176192</span> (<span class="number">00111001011110000010100101000000</span>)</span><br><span class="line">解释：输入的二进制串 <span class="number">00000010100101000001111010011100</span> 表示无符号整数 <span class="number">43261596</span>，</span><br><span class="line">     因此返回 <span class="number">964176192</span>，其二进制表示形式为 <span class="number">00111001011110000010100101000000</span>。</span><br></pre></td></tr></table></figure><p>示例二：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">11111111111111111111111111111101</span></span><br><span class="line">输出：<span class="number">3221225471</span> (<span class="number">10111111111111111111111111111111</span>)</span><br><span class="line">解释：输入的二进制串 <span class="number">11111111111111111111111111111101</span> 表示无符号整数 <span class="number">4294967293</span>，</span><br><span class="line">     因此返回 <span class="number">3221225471</span> 其二进制表示形式为 <span class="number">10111111111111111111111111111111</span> 。</span><br></pre></td></tr></table></figure><p>提示：</p><p>输入是一个长度为 32 的二进制字符串</p><hr><p>边取余边累加即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">32</span> ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = sum * <span class="number">2</span> + n % <span class="number">2</span>;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum = sum * <span class="number">2</span> + n % <span class="number">2</span>;</span><br><span class="line">n &gt;&gt;= <span class="number">1</span>; <span class="comment">//等价于 n = n / 2;</span></span><br></pre></td></tr></table></figure><p>这行如果看不懂可以看作十进制倒转的过程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum = sum * <span class="number">10</span> + n % <span class="number">10</span>;</span><br><span class="line">n = n / <span class="number">10</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;190-颠倒二进制位&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#190-颠倒二进制位&quot;&gt;¶&lt;/a&gt;190.颠倒二进制位&lt;/h2&gt;
&lt;p&gt;颠倒给定的 32 位无符号整数的二进制位。&lt;/p&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;p&gt;请注意，在某些语言（如 </summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 第243场周赛 创新奇智&amp;力扣</title>
    <link href="http://example.com/2021/03/28/lcweek243/"/>
    <id>http://example.com/2021/03/28/lcweek243/</id>
    <published>2021-03-28T04:50:43.042Z</published>
    <updated>2021-03-28T05:36:22.461Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-第243场周赛-创新奇智-力扣"><a class="header-anchor" href="#Leetcode-第243场周赛-创新奇智-力扣">¶</a>Leetcode 第243场周赛 创新奇智&amp;力扣</h2><p>本次差点全AC了，还是差一点火候。</p><h3 id="第一题-字符串中不同整数的数目"><a class="header-anchor" href="#第一题-字符串中不同整数的数目">¶</a>第一题-字符串中不同整数的数目</h3><p>给你一个字符串 word ，该字符串由数字和小写英文字母组成。</p><p>请你用空格替换每个不是数字的字符。例如，“a123bc34d8ef34” 将会变成 &quot; 123  34 8  34&quot; 。注意，剩下的这些整数间至少要用一个空格隔开：“123”、“34”、“8” 和 “34” 。</p><p>返回对 word 完成替换后形成的 不同 整数的数目。</p><p>如果两个整数的 不含前导零 的十进制表示不同，则认为这两个整数也不同。</p><p>示例一：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：word = <span class="string">&quot;a123bc34d8ef34&quot;</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：不同的整数有 <span class="string">&quot;123&quot;</span>、<span class="string">&quot;34&quot;</span> 和 <span class="string">&quot;8&quot;</span> 。注意，<span class="string">&quot;34&quot;</span> 只计数一次。</span><br></pre></td></tr></table></figure><p>示例二</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：word = <span class="string">&quot;leet1234code234&quot;</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure><p>示例三</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：word = <span class="string">&quot;a1b01c001&quot;</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：<span class="string">&quot;1&quot;</span>、<span class="string">&quot;01&quot;</span> 和 <span class="string">&quot;001&quot;</span> 视为同一个整数的十进制表示，因为在比较十进制值时会忽略前导零的存在。</span><br></pre></td></tr></table></figure><p>提示：<br>1 &lt;= word.length &lt;= 1000<br>word 由数字和小写英文字母组成</p><hr><p>该题只需要考虑两个东西，第一是提取数字，第二是去重。<br>利用vector提取数字，set去重</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numDifferentIntegers</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = word.<span class="built_in">length</span>();</span><br><span class="line">set&lt;string&gt; s;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (word[i] &gt;= <span class="string">&#x27;0&#x27;</span>&amp;&amp;word[i] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;<span class="keyword">char</span>&gt; vc;</span><br><span class="line"><span class="keyword">while</span> (i &lt; n &amp;&amp; (word[i] &gt;= <span class="string">&#x27;0&#x27;</span>&amp;&amp;word[i] &lt;= <span class="string">&#x27;9&#x27;</span>))</span><br><span class="line">&#123;</span><br><span class="line">vc.<span class="built_in">push_back</span>(word[i++]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (vc.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; vc[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">vc.<span class="built_in">erase</span>(vc.<span class="built_in">begin</span>());</span><br><span class="line">&#125;</span><br><span class="line">string tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : vc)</span><br><span class="line">tmp += x;</span><br><span class="line">s.<span class="built_in">insert</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> s.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="第二题-还原排列的最少操作步数"><a class="header-anchor" href="#第二题-还原排列的最少操作步数">¶</a>第二题-还原排列的最少操作步数</h2><p>给你一个偶数 n​​​​​​ ，已知存在一个长度为 n 的排列 perm ，其中 perm[i] == i​（下标 从 0 开始 计数）。</p><p>一步操作中，你将创建一个新数组 arr ，对于每个 i ：</p><p>如果 i % 2 == 0 ，那么 arr[i] = perm[i / 2]<br>如果 i % 2 == 1 ，那么 arr[i] = perm[n / 2 + (i - 1) / 2]<br>然后将 arr​​ 赋值​​给 perm 。</p><p>要想使 perm 回到排列初始值，至少需要执行多少步操作？返回最小的 非零 操作步数。</p><p>示例一：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：最初，perm = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">第 <span class="number">1</span> 步操作后，perm = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">所以，仅需执行 <span class="number">1</span> 步操作</span><br></pre></td></tr></table></figure><p>示例二:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：最初，perm = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">第 <span class="number">1</span> 步操作后，perm = [<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">第 <span class="number">2</span> 步操作后，perm = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">所以，仅需执行 <span class="number">2</span> 步操作</span><br></pre></td></tr></table></figure><p>示例三:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span></span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure><p>提示：<br>2 &lt;= n &lt;= 1000<br>n​​​​​​ 是一个偶数</p><hr><p>我们只用考虑arr数组是否对应prem[i] = i 即可，否则则操作步数+1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reinitializePermutation</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">prem</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">prem[i] = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (j&lt;n)</span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">0</span>)arr[i] = prem[i/<span class="number">2</span>];</span><br><span class="line"><span class="keyword">else</span> arr[i] = prem[n / <span class="number">2</span> + (i <span class="number">-1</span>)/ <span class="number">2</span> ];</span><br><span class="line">&#125;</span><br><span class="line">prem = arr;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (prem[j] != j)</span><br><span class="line">&#123;</span><br><span class="line">cnt++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (j == n)<span class="keyword">return</span> cnt+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="第三题-替换字符串中的括号内容"><a class="header-anchor" href="#第三题-替换字符串中的括号内容">¶</a>第三题-替换字符串中的括号内容</h2><p>给你一个字符串 s ，它包含一些括号对，每个括号中包含一个 非空 的键。</p><p>比方说，字符串 “(name)is(age)yearsold” 中，有 两个 括号对，分别包含键 “name” 和 “age” 。<br>你知道许多键对应的值，这些关系由二维字符串数组 knowledge 表示，其中 knowledge[i] = [keyi, valuei] ，表示键 keyi 对应的值为 valuei 。</p><p>你需要替换 所有 的括号对。当你替换一个括号对，且它包含的键为 keyi 时，你需要：</p><p>将 keyi 和括号用对应的值 valuei 替换。<br>如果从 knowledge 中无法得知某个键对应的值，你需要将 keyi 和括号用问号 “?” 替换（不需要引号）。<br>knowledge 中每个键最多只会出现一次。s 中不会有嵌套的括号。</p><p>请你返回替换 所有 括号对后的结果字符串。</p><p>示例一：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;(name)is(age)yearsold&quot;</span>, knowledge = [[<span class="string">&quot;name&quot;</span>,<span class="string">&quot;bob&quot;</span>],[<span class="string">&quot;age&quot;</span>,<span class="string">&quot;two&quot;</span>]]</span><br><span class="line">输出：<span class="string">&quot;bobistwoyearsold&quot;</span></span><br><span class="line">解释：</span><br><span class="line">键 <span class="string">&quot;name&quot;</span> 对应的值为 <span class="string">&quot;bob&quot;</span> ，所以将 <span class="string">&quot;(name)&quot;</span> 替换为 <span class="string">&quot;bob&quot;</span> 。</span><br><span class="line">键 <span class="string">&quot;age&quot;</span> 对应的值为 <span class="string">&quot;two&quot;</span> ，所以将 <span class="string">&quot;(age)&quot;</span> 替换为 <span class="string">&quot;two&quot;</span> 。</span><br></pre></td></tr></table></figure><p>示例二：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;hi(name)&quot;</span>, knowledge = [[<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>]]</span><br><span class="line">输出：<span class="string">&quot;hi?&quot;</span></span><br><span class="line">解释：由于不知道键 <span class="string">&quot;name&quot;</span> 对应的值，所以用 <span class="string">&quot;?&quot;</span> 替换 <span class="string">&quot;(name)&quot;</span> 。</span><br></pre></td></tr></table></figure><p>示例三：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;(a)(a)(a)aaa&quot;</span>, knowledge = [[<span class="string">&quot;a&quot;</span>,<span class="string">&quot;yes&quot;</span>]]</span><br><span class="line">输出：<span class="string">&quot;yesyesyesaaa&quot;</span></span><br><span class="line">解释：相同的键在 s 中可能会出现多次。</span><br><span class="line">键 <span class="string">&quot;a&quot;</span> 对应的值为 <span class="string">&quot;yes&quot;</span> ，所以将所有的 <span class="string">&quot;(a)&quot;</span> 替换为 <span class="string">&quot;yes&quot;</span> 。</span><br><span class="line">注意，不在括号里的 <span class="string">&quot;a&quot;</span> 不需要被替换。</span><br></pre></td></tr></table></figure><hr><p>看到找对应值的题，首先想到了map,然后题意告诉了我们并不需要保持map有序，所以使用unordered_map,将knowledge的值提取出来放入map,然后判断括号内的内容，找到了则替换成unordered_map[key],没找到则替换成‘？’.然后使用一个字符串保存所有结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">evaluate</span><span class="params">(string s, vector&lt;vector&lt;string&gt;&gt;&amp; knowledge)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;string,string&gt; maps;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(vector&lt;string&gt; x : knowledge)</span><br><span class="line">        &#123;</span><br><span class="line">            maps[x[<span class="number">0</span>]] = x[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ssize = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ssize ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                string tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">while</span>(s[i]!=<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp += s[i++];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(maps.<span class="built_in">find</span>(tmp)!=maps.<span class="built_in">end</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    res+=maps[tmp];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    res+=<span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res+=s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="第四题-好因子的最大数目"><a class="header-anchor" href="#第四题-好因子的最大数目">¶</a>第四题-好因子的最大数目</h2><p>时间不够没写出来，但看上去只需要维持一个素数表，利用空间换取时间，然后做到因数拆分就行了，对其因数加以判断就行了，需要注意的应该就是值太大要利用快速幂取模。</p><p>附上<a href="https://leetcode-cn.com/problems/maximize-number-of-nice-divisors/solution/c-python3-jian-sheng-zi-zheng-shu-chai-f-0980/">大佬</a>题解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxNiceDivisors</span><span class="params">(<span class="keyword">int</span> primeFactors)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> n = primeFactors;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> tmp = n / <span class="number">3</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">f</span>(<span class="number">3</span>, tmp) % <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">f</span>(<span class="number">3</span>, tmp<span class="number">-1</span>) * <span class="number">4</span> % <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">f</span>(<span class="number">3</span>, tmp) * <span class="number">2</span> % <span class="number">1000000007</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">f</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> n)</span>   </span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res *= a;</span><br><span class="line">                res %= <span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            a *= a;</span><br><span class="line">            a %= <span class="number">1000000007</span>;</span><br><span class="line">            n /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Leetcode-第243场周赛-创新奇智-力扣&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#Leetcode-第243场周赛-创新奇智-力扣&quot;&gt;¶&lt;/a&gt;Leetcode 第243场周赛 创新奇智&amp;amp;力扣&lt;/h2&gt;
&lt;p&gt;本次差点全A</summary>
      
    
    
    
    <category term="竞赛" scheme="http://example.com/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="Leetcode周赛复现" scheme="http://example.com/tags/Leetcode%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 173.二叉搜索树迭代器</title>
    <link href="http://example.com/2021/03/28/leetcode173/"/>
    <id>http://example.com/2021/03/28/leetcode173/</id>
    <published>2021-03-28T04:29:17.196Z</published>
    <updated>2021-03-28T04:48:05.421Z</updated>
    
    <content type="html"><![CDATA[<h2 id="173-二叉搜索树迭代器"><a class="header-anchor" href="#173-二叉搜索树迭代器">¶</a>173. 二叉搜索树迭代器</h2><p>实现一个二叉搜索树迭代器类BSTIterator ，表示一个按中序遍历二叉搜索树（BST）的迭代器：<br><kbd>BSTIterator(TreeNode root)</kbd> 初始化 BSTIterator 类的一个对象。BST 的根节点 root 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。<br><kbd>boolean hasNext()</kbd> 如果向指针右侧遍历存在数字，则返回 true ；否则返回 false 。<br><kbd>int next()</kbd>将指针向右移动，然后返回指针处的数字。<br>注意，指针初始化为一个不存在于 BST 中的数字，所以对 next() 的首次调用将返回 BST 中的最小元素。</p><p>你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 的中序遍历中至少存在一个下一个数字。</p><img src="https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png">  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[<span class="string">&quot;BSTIterator&quot;</span>, <span class="string">&quot;next&quot;</span>, <span class="string">&quot;next&quot;</span>, <span class="string">&quot;hasNext&quot;</span>, <span class="string">&quot;next&quot;</span>, <span class="string">&quot;hasNext&quot;</span>, <span class="string">&quot;next&quot;</span>, <span class="string">&quot;hasNext&quot;</span>, <span class="string">&quot;next&quot;</span>, <span class="string">&quot;hasNext&quot;</span>]</span><br><span class="line">[[[<span class="number">7</span>, <span class="number">3</span>, <span class="number">15</span>, null, null, <span class="number">9</span>, <span class="number">20</span>]], [], [], [], [], [], [], [], [], []]</span><br><span class="line">输出</span><br><span class="line">[null, <span class="number">3</span>, <span class="number">7</span>, <span class="literal">true</span>, <span class="number">9</span>, <span class="literal">true</span>, <span class="number">15</span>, <span class="literal">true</span>, <span class="number">20</span>, <span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">BSTIterator bSTIterator = <span class="keyword">new</span> <span class="built_in">BSTIterator</span>([<span class="number">7</span>, <span class="number">3</span>, <span class="number">15</span>, null, null, <span class="number">9</span>, <span class="number">20</span>]);</span><br><span class="line">bSTIterator.<span class="built_in">next</span>();    <span class="comment">// 返回 3</span></span><br><span class="line">bSTIterator.<span class="built_in">next</span>();    <span class="comment">// 返回 7</span></span><br><span class="line">bSTIterator.<span class="built_in">hasNext</span>(); <span class="comment">// 返回 True</span></span><br><span class="line">bSTIterator.<span class="built_in">next</span>();    <span class="comment">// 返回 9</span></span><br><span class="line">bSTIterator.<span class="built_in">hasNext</span>(); <span class="comment">// 返回 True</span></span><br><span class="line">bSTIterator.<span class="built_in">next</span>();    <span class="comment">// 返回 15</span></span><br><span class="line">bSTIterator.<span class="built_in">hasNext</span>(); <span class="comment">// 返回 True</span></span><br><span class="line">bSTIterator.<span class="built_in">next</span>();    <span class="comment">// 返回 20</span></span><br><span class="line">bSTIterator.<span class="built_in">hasNext</span>(); <span class="comment">// 返回 False</span></span><br></pre></td></tr></table></figure><p>提示：</p><p>树中节点的数目在范围 [1, 10^5] 内<br>0 &lt;= Node.val &lt;= 10^6<br>最多调用 10^5 次 hasNext 和 next 操作</p><hr><p>利用栈来实现迭代写法，因为是中序遍历，所以遍历顺序为<kbd>左-&gt;头-&gt;右</kbd></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode * cur;</span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BSTIterator</span>(TreeNode* root):<span class="built_in">cur</span>(root) &#123;</span><br><span class="line">        ans = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>) <span class="comment">//将cur指针不断指向当前节点的左子树</span></span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(cur);</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = s.<span class="built_in">top</span>(); <span class="comment">//得到最后一个左子树的结点</span></span><br><span class="line">        s.<span class="built_in">pop</span>(); <span class="comment">//弹出该结点</span></span><br><span class="line">        ans = cur-&gt;val;  <span class="comment">//得到父节点的值</span></span><br><span class="line">        cur = cur-&gt;right; <span class="comment">//符合 左-&gt;父节点-&gt;右</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!s.<span class="built_in">empty</span>() || cur != <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your BSTIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * BSTIterator* obj = new BSTIterator(root);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;next();</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;hasNext();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;173-二叉搜索树迭代器&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#173-二叉搜索树迭代器&quot;&gt;¶&lt;/a&gt;173. 二叉搜索树迭代器&lt;/h2&gt;
&lt;p&gt;实现一个二叉搜索树迭代器类BSTIterator ，表示一个按中序遍历二叉搜索树（BST）</summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>VS2017-OPENGL配置glfw+glad</title>
    <link href="http://example.com/2021/03/27/openglconf/"/>
    <id>http://example.com/2021/03/27/openglconf/</id>
    <published>2021-03-27T07:21:54.769Z</published>
    <updated>2021-03-27T08:32:05.566Z</updated>
    
    <content type="html"><![CDATA[<h2 id="VS2017-OPENGL配置glfw-glad"><a class="header-anchor" href="#VS2017-OPENGL配置glfw-glad">¶</a>VS2017-OPENGL配置glfw+glad</h2><p>之前配置的是glfw+glew,可是glad是目前比较新的，比glew更好用，所以这次配置一下glfw+glad的开发环境。(注：必须下载32位的哦)</p><hr><p>首先要去下载 <kbd>glfw</kbd> 与 <kbd>glad</kbd>，直接去官网下载就好了，glfw我们选择3.3版本的，glad下载的时候需要自己根据需求来选择,按照下图选择即可：<br><img src="https://note.youdao.com/yws/api/personal/file/WEB90ff75442785befb1ec5a4db95533f21?method=download&shareKey=9600c3ddbe6006b944057677ce1a4ca2"><br>选择完后往下翻点击generate生成下载链接，下载该zip就行了。放在自己熟悉的文件夹哦。</p><hr><p>然后打开VS，新建一个空项目，右键项目，点击属性-&gt;C/C+±&gt;附加包含目录，根据图片编辑附加包含目录：<br><img src="https://note.youdao.com/yws/api/personal/file/WEB1ce313627917875a74e043ce3939b78b?method=download&shareKey=0550ab7cdd41018536d58840eb5920aa"></p><hr><p>在上面的界面选择文件，打开之前下载的glfw文件夹，添加路径<kbd>…\glfw-3.3.2.bin.WIN32\include</kbd><br>然后我们再添加glad的路径,同样<kbd>…glad\include</kbd></p><hr><p>然后点击C/C++下面的<kbd>链接器</kbd>，点开<kbd>常规</kbd>，配置<kbd>附加库目录</kbd>:</p><img src="https://note.youdao.com/yws/api/personal/file/WEBa5c1a8f646a538c0d72be99042859656?method=download&shareKey=626ed05ecd16a80c79cce0ce95e892e7">  将<kbd>...\glfw-3.3.2.bin.WIN32\lib-vc2017</kbd>添加进去即可。<hr><p>最后点击<kbd>链接器</kbd>，点开<kbd>输入</kbd>:</p><img src="https://note.youdao.com/yws/api/personal/file/WEBf5d2b78d4938ca2f784c208a8e2bef20?method=download&shareKey=ba49dac7ec8ea2aaa6bd354e78f6db67">  然后输入： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">opengl32.lib</span><br><span class="line">glfw3.lib</span><br></pre></td></tr></table></figure><hr><p>点击确定后，打开存放glad的文件夹，找到src目录，复制里面的<kbd>glad.c</kbd>,将其放到该项目的源文件夹就全部完成了。</p><hr><p>下面来验证一下是否能够使用glfw+glad创建一个窗口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GLEW_STATIC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">glfwInit</span>();</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line">GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">glfwTerminate</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"><span class="built_in">glfwPollEvents</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">glfwTerminate</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果创建成功，则证明环境配置完成，如果遇到了</p><pre><code class="language-cpp">无法解析的外部符号 _glfwInit,该符号在函数 _main 中被引用</code></pre><p>这类报错，则证明glfw配置过程中出错，建议仔细检查。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;VS2017-OPENGL配置glfw-glad&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#VS2017-OPENGL配置glfw-glad&quot;&gt;¶&lt;/a&gt;VS2017-OPENGL配置glfw+glad&lt;/h2&gt;
&lt;p&gt;之前配置的是glfw</summary>
      
    
    
    
    <category term="OPENGL" scheme="http://example.com/categories/OPENGL/"/>
    
    
    <category term="环境配置" scheme="http://example.com/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 61.旋转链表</title>
    <link href="http://example.com/2021/03/27/leetcode61/"/>
    <id>http://example.com/2021/03/27/leetcode61/</id>
    <published>2021-03-27T04:42:17.133Z</published>
    <updated>2021-03-27T04:53:26.138Z</updated>
    
    <content type="html"><![CDATA[<h2 id="61-旋转链表"><a class="header-anchor" href="#61-旋转链表">¶</a>61. 旋转链表</h2><p>给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。</p><p>示例 1：<br><img src="https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], k = <span class="number">2</span>  </span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]  </span><br></pre></td></tr></table></figure><p>示例 2：<br><img src="https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], k = <span class="number">4</span>  </span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>提示：</p><p>链表中节点的数目在范围 [0, 500] 内<br>-100 &lt;= Node.val &lt;= 100<br>0 &lt;= k &lt;= 2 * 10^9</p><hr><p>对于这题我们可以直接先将链表连成环，然后断开旋转后的头尾结点就行了。</p><p>比如 1-&gt;2-&gt;3-&gt;4-&gt;5  我们将 5连上1 ，然后再将3,4断开，这样我们就得到了一个旋转后的链表。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">        ListNode * p = head;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        k=k%len;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>)<span class="keyword">return</span> head;<span class="comment">//如果不移动 直接返回表头</span></span><br><span class="line"></span><br><span class="line">        ListNode * q = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len - k - <span class="number">1</span> ; i++)&#123;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        p-&gt;next = head;</span><br><span class="line">        ListNode * newHead = q-&gt;next;</span><br><span class="line">        q-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;61-旋转链表&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#61-旋转链表&quot;&gt;¶&lt;/a&gt;61. 旋转链表&lt;/h2&gt;
&lt;p&gt;给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;br&gt;
&lt;i</summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 83.删除排序链表中的重复元素</title>
    <link href="http://example.com/2021/03/26/leetcode83/"/>
    <id>http://example.com/2021/03/26/leetcode83/</id>
    <published>2021-03-26T15:36:09.625Z</published>
    <updated>2021-03-26T15:37:42.698Z</updated>
    
    <content type="html"><![CDATA[<h2 id="83-删除排序链表中的重复元素"><a class="header-anchor" href="#83-删除排序链表中的重复元素">¶</a>83.删除排序链表中的重复元素</h2><h4 class="css-10c1h40-Title eugt34i1" data-cypress="QuestionTitle"><span style="font-size: 16px;"><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></span></h4><p><span style="font-size: 16px;">存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中&nbsp;没有重复出现&nbsp;的数字。</span></p><p><span style="font-size: 16px;">返回同样按升序排列的结果链表。</span></p><p><span style="font-size: 16px;">示例 1：</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p><span style="font-size: 16px;">示例 2：</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p><span style="font-size: 16px;">提示：</span></p><p><span style="font-size: 16px;">链表中节点数目在范围 [0, 300] 内</span><br /><span style="font-size: 16px;">-100 &lt;= Node.val &lt;= 100</span><br /><span style="font-size: 16px;">题目数据保证链表已经按升序排列</span></p><hr><p><span style="font-size: 16px;">跟昨天的题没啥区别，照样建新表。</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)<span class="keyword">return</span> head;</span><br><span class="line">        ListNode * newhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        newhead-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; maps;</span><br><span class="line">        ListNode * pre = head;</span><br><span class="line">        <span class="keyword">while</span>(pre != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            maps[pre-&gt;val]++;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pre = newhead;</span><br><span class="line">        ListNode * cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>( cur != <span class="literal">nullptr</span> &amp;&amp; maps[cur-&gt;val] &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode * node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(cur-&gt;val);</span><br><span class="line">                pre-&gt;next = node;</span><br><span class="line">                pre = pre-&gt;next;</span><br><span class="line">                node-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;83-删除排序链表中的重复元素&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#83-删除排序链表中的重复元素&quot;&gt;¶&lt;/a&gt;83.删除排序链表中的重复元素&lt;/h2&gt;
&lt;h4 class=&quot;css-10c1h40-Title eugt34i1&quot; d</summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 82.删除排序链表中的重复元素 II</title>
    <link href="http://example.com/2021/03/26/leetcode82/"/>
    <id>http://example.com/2021/03/26/leetcode82/</id>
    <published>2021-03-26T15:34:10.975Z</published>
    <updated>2021-03-26T15:35:59.171Z</updated>
    
    <content type="html"><![CDATA[<h2 id="82-删除排序链表中的重复元素-II"><a class="header-anchor" href="#82-删除排序链表中的重复元素-II">¶</a>82.删除排序链表中的重复元素 II</h2><h4 class="css-10c1h40-Title eugt34i1" data-cypress="QuestionTitle"><span style="font-size: 16px;"><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II</a></span></h4><p><span style="font-size: 16px;">存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中&nbsp;没有重复出现&nbsp;的数字。</span></p><p><span style="font-size: 16px;">返回同样按升序排列的结果链表。</span></p><p><span style="font-size: 16px;">示例 1：</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p><span style="font-size: 16px;">示例 2：</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p><span style="font-size: 16px;">提示：</span></p><p><span style="font-size: 16px;">链表中节点数目在范围 [0, 300] 内</span><br /><span style="font-size: 16px;">-100 &lt;= Node.val &lt;= 100</span><br /><span style="font-size: 16px;">题目数据保证链表已经按升序排列</span></p><hr><p><span style="font-size: 16px;">用哈希表保存出现的数值，将出现次数未超过一的值，建立结点赋给新链表。</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)<span class="keyword">return</span> head;</span><br><span class="line">        ListNode * newhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        newhead-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; maps;</span><br><span class="line">        ListNode * pre = head;</span><br><span class="line">        <span class="keyword">while</span>(pre != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            maps[pre-&gt;val]++;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pre = newhead;</span><br><span class="line">        ListNode * cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>( cur != <span class="literal">nullptr</span> &amp;&amp; maps[cur-&gt;val] &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode * node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(cur-&gt;val);</span><br><span class="line">                pre-&gt;next = node;</span><br><span class="line">                pre = pre-&gt;next;</span><br><span class="line">                node-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;82-删除排序链表中的重复元素-II&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#82-删除排序链表中的重复元素-II&quot;&gt;¶&lt;/a&gt;82.删除排序链表中的重复元素 II&lt;/h2&gt;
&lt;h4 class=&quot;css-10c1h40-Title eu</summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 456.132 模式</title>
    <link href="http://example.com/2021/03/26/leetcode456/"/>
    <id>http://example.com/2021/03/26/leetcode456/</id>
    <published>2021-03-26T15:10:36.906Z</published>
    <updated>2021-03-26T15:13:10.721Z</updated>
    
    <content type="html"><![CDATA[<h2 id="456-132-模式"><a class="header-anchor" href="#456-132-模式">¶</a>456.132 模式</h2><h4 class="css-10c1h40-Title eugt34i1" data-cypress="QuestionTitle"><span style="font-size: 16px;"><a href="https://leetcode-cn.com/problems/132-pattern/">456. 132 模式</a></span></h4><p><span style="font-size: 16px;">给你一个整数数组 nums ，数组中共有 n 个整数。132 模式的子序列 由三个整数 nums[i]、nums[j] 和 nums[k] 组成，并同时满足：i &lt; j &lt; k 和 nums[i] &lt; nums[k] &lt; nums[j] 。</span></p><p><span style="font-size: 16px;">如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false 。</span></p><p><span style="font-size: 16px;">&nbsp;</span></p><p><span style="font-size: 16px;">进阶：很容易想到时间复杂度为 O(n^2) 的解决方案，你可以设计一个时间复杂度为 O(n logn) 或 O(n) 的解决方案吗？</span></p><hr><p><span style="font-size: 16px;">示例 1：</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：序列中不存在 <span class="number">132</span> 模式的子序列。</span><br></pre></td></tr></table></figure><p><span style="font-size: 16px;">示例 2：</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：序列中有 <span class="number">1</span> 个 <span class="number">132</span> 模式的子序列： [<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>] 。</span><br></pre></td></tr></table></figure><p><span style="font-size: 16px;">示例 3：</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：序列中有 <span class="number">3</span> 个 <span class="number">132</span> 模式的的子序列：[<span class="number">-1</span>, <span class="number">3</span>, <span class="number">2</span>]、[<span class="number">-1</span>, <span class="number">3</span>, <span class="number">0</span>] 和 [<span class="number">-1</span>, <span class="number">2</span>, <span class="number">0</span>] 。</span><br></pre></td></tr></table></figure><p><span style="font-size: 16px;">提示：</span></p><p><span style="font-size: 16px;">n == nums.length</span><br /><span style="font-size: 16px;">1 &lt;= n &lt;= 104</span><br /><span style="font-size: 16px;">-109 &lt;= nums[i] &lt;= 109</span></p><p>&nbsp;</p><p><span style="font-size: 16px;">一开始用的是暴力法，O(n&sup2;)，勉强能接受..就是从做往右搜，以132中的3为基础，往左搜1，往右搜2，就行了。</span></p><p><span style="font-size: 16px;">代码：</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find132pattern</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> minn = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n<span class="number">-1</span> ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            minn = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= i - <span class="number">1</span> ; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(minn &gt; nums[j])minn = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt; n ; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &gt; minn &amp;&amp; nums[j] &lt; nums[i])<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p><span style="font-size: 16px;">后面又看到大神的单调栈思路，然后写了个单调栈方法，从右往左搜，利用单调栈的特性，同时找到2与3，只需要往左找1就行了。复杂度O(n)。</span></p><p><span style="font-size: 16px;">maxn维护3前面最大的数2。只要往左找到一个比maxn更小的数，就证明找到了132。</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find132pattern</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> maxn = INT_MIN;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span> ; i &gt;= <span class="number">0</span> ; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(maxn &gt; nums[i])<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()&amp;&amp;s.<span class="built_in">top</span>()&lt;nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                maxn = <span class="built_in">max</span>(s.<span class="built_in">top</span>(),maxn);</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;456-132-模式&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#456-132-模式&quot;&gt;¶&lt;/a&gt;456.132 模式&lt;/h2&gt;
&lt;h4 class=&quot;css-10c1h40-Title eugt34i1&quot; data-cypress=&quot;Qu</summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 341.扁平化嵌套列表迭代器</title>
    <link href="http://example.com/2021/03/26/leetcode341/"/>
    <id>http://example.com/2021/03/26/leetcode341/</id>
    <published>2021-03-26T15:07:54.443Z</published>
    <updated>2021-03-26T15:09:53.735Z</updated>
    
    <content type="html"><![CDATA[<h2 id="341-扁平化嵌套列表迭代器"><a class="header-anchor" href="#341-扁平化嵌套列表迭代器">¶</a>341. 扁平化嵌套列表迭代器</h2><h4 class="css-10c1h40-Title eugt34i1" data-cypress="QuestionTitle"><span style="font-size: 16px;"><a href="https://leetcode-cn.com/problems/flatten-nested-list-iterator/">341. 扁平化嵌套列表迭代器</a></span></h4><p><span style="font-size: 16px;">给你一个嵌套的整型列表。请你设计一个迭代器，使其能够遍历这个整型列表中的所有整数。</span></p><p><span style="font-size: 16px;">列表中的每一项或者为一个整数，或者是另一个列表。其中列表的元素也可能是整数或是其他列表。</span></p><hr><p><span style="font-size: 16px;">示例 1:</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [[<span class="number">1</span>,<span class="number">1</span>],<span class="number">2</span>,[<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">解释: 通过重复调用 next 直到 hasNext 返回 <span class="literal">false</span>，next 返回的元素的顺序应该是: [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]。</span><br></pre></td></tr></table></figure><p><span style="font-size: 16px;">示例 2:</span></p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,[<span class="number">4</span>,[<span class="number">6</span>]]]</span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">解释: 通过重复调用 next 直到 hasNext 返回 <span class="literal">false</span>，next 返回的元素的顺序应该是: [<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>]。</span><br></pre></td></tr></table></figure><hr><p><span style="font-size: 16px;">递归就行了。</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the interface that allows for creating nested lists.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class NestedInteger &#123;</span></span><br><span class="line"><span class="comment"> *   public:</span></span><br><span class="line"><span class="comment"> *     // Return true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line"><span class="comment"> *     bool isInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a nested list</span></span><br><span class="line"><span class="comment"> *     int getInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a single integer</span></span><br><span class="line"><span class="comment"> *     const vector&lt;NestedInteger&gt; &amp;getList() const;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator cur;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> vector&lt;NestedInteger&gt; &amp;nestedList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;nest : nestedList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nest.<span class="built_in">isInteger</span>()) &#123;</span><br><span class="line">                v.<span class="built_in">push_back</span>(nest.<span class="built_in">getInteger</span>());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(nest.<span class="built_in">getList</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NestedIterator</span>(vector&lt;NestedInteger&gt; &amp;nestedList) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(nestedList);</span><br><span class="line">        cur = v.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *cur++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cur != v.<span class="built_in">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NestedIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NestedIterator i(nestedList);</span></span><br><span class="line"><span class="comment"> * while (i.hasNext()) cout &lt;&lt; i.next();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;341-扁平化嵌套列表迭代器&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#341-扁平化嵌套列表迭代器&quot;&gt;¶&lt;/a&gt;341. 扁平化嵌套列表迭代器&lt;/h2&gt;
&lt;h4 class=&quot;css-10c1h40-Title eugt34i1&quot; dat</summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 191.位1的个数</title>
    <link href="http://example.com/2021/03/26/Leetcode191/"/>
    <id>http://example.com/2021/03/26/Leetcode191/</id>
    <published>2021-03-26T15:03:22.899Z</published>
    <updated>2021-03-26T15:06:36.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="191-位1的个数"><a class="header-anchor" href="#191-位1的个数">¶</a>191. 位1的个数</h2><p><span style="font-size: 16px;">编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。</span></p><p><span style="font-size: 16px;">提示：</span></p><p><span style="font-size: 16px;">请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</span><br /><span style="font-size: 16px;">在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的&nbsp;示例 3&nbsp;中，输入表示有符号整数 -3。</span><br /><span style="font-size: 16px;"></span></p><hr><p><span style="font-size: 16px;">示例 1：</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="number">00000000000000000000000000001011</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：输入的二进制串 <span class="number">00000000000000000000000000001011</span> 中，共有三位为 <span class="string">&#x27;1&#x27;</span>。</span><br></pre></td></tr></table></figure><p><span style="font-size: 16px;">示例 2：</span></p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="number">00000000000000000000000010000000</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：输入的二进制串 <span class="number">00000000000000000000000010000000</span> 中，共有一位为 <span class="string">&#x27;1&#x27;</span>。</span><br></pre></td></tr></table></figure><p><span style="font-size: 16px;">示例 3：</span></p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="number">11111111111111111111111111111101</span></span><br><span class="line">输出：<span class="number">31</span></span><br><span class="line">解释：输入的二进制串 <span class="number">11111111111111111111111111111101</span> 中，共有 <span class="number">31</span> 位为 <span class="string">&#x27;1&#x27;</span>。</span><br></pre></td></tr></table></figure><p><span style="font-size: 16px;">提示：</span></p><p><span style="font-size: 16px;">输入必须是长度为 32 的 二进制串 。</span><br /><span style="font-size: 16px;"></span></p><p><span style="font-size: 16px;">进阶：</span></p><p><span style="font-size: 16px;">如果多次调用这个函数，你将如何优化你的算法？</span></p><hr><p><span style="font-size: 16px;">利用位运算，判断当前数的最后一位是否为1，如果为1，则直接加入cnt,并且当前数右移一位。</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n&amp;<span class="number">1</span>)</span><br><span class="line">                cnt++;</span><br><span class="line">            n = n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;191-位1的个数&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#191-位1的个数&quot;&gt;¶&lt;/a&gt;191. 位1的个数&lt;/h2&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 16px;&quot;&gt;编写一个函数，输入是一个无符号整数（以二进制串</summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode每日一题 73.矩阵置零</title>
    <link href="http://example.com/2021/03/26/leetcode73/"/>
    <id>http://example.com/2021/03/26/leetcode73/</id>
    <published>2021-03-26T14:42:11.018Z</published>
    <updated>2021-03-26T15:03:06.791Z</updated>
    
    <content type="html"><![CDATA[<h2 id="73-矩阵置零"><a class="header-anchor" href="#73-矩阵置零">¶</a>73.矩阵置零</h2><h4 class="css-10c1h40-Title eugt34i1" data-cypress="QuestionTitle"><span style="font-size: 16px;"><a href="https://leetcode-cn.com/problems/set-matrix-zeroes/">73. 矩阵置零</a></span></h4><div class="content__1Y2H"><div class="notranslate"><p><span style="font-size: 16px;">给定一个&nbsp;<code><em>m</em>&nbsp;x&nbsp;<em>n</em></code>&nbsp;的矩阵，如果一个元素为&nbsp;0&nbsp;，则将其所在行和列的所有元素都设为&nbsp;0&nbsp;。请使用&nbsp;<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>&nbsp;算法。</span></p><p><span style="font-size: 16px;">进阶：</span></p><ul><li><span style="font-size: 16px;">一个直观的解决方案是使用 &nbsp;<code>O(<em>m</em><em>n</em>)</code>&nbsp;的额外空间，但这并不是一个好的解决方案。</span></li><li><span style="font-size: 16px;">一个简单的改进方案是使用&nbsp;<code>O(<em>m</em>&nbsp;+&nbsp;<em>n</em>)</code>&nbsp;的额外空间，但这仍然不是最好的解决方案。</span></li><li><span style="font-size: 16px;">你能想出一个仅使用常量空间的解决方案吗？</span></li></ul><p><span style="font-size: 16px;">&nbsp;</span></p><p><span style="font-size: 16px;">示例 1：</span></p><span style="font-size: 16px;"><img src="https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg" alt="" /></span><pre><span style="font-size: 16px;">输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]输出：[[1,0,1],[0,0,0],[1,0,1]]</span></pre><p><span style="font-size: 16px;">示例 2：</span></p><span style="font-size: 16px;"><img src="https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg" alt="" /></span><pre><span style="font-size: 16px;">输入：matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]</span></pre><p><span style="font-size: 16px;">提示：</span></p><ul><li><span style="font-size: 16px;"><code>m == matrix.length</code></span></li><li><span style="font-size: 16px;"><code>n == matrix[0].length</code></span></li><li><span style="font-size: 16px;"><code>1 &lt;= m, n &lt;= 200</code></span></li><li><span style="font-size: 16px;"><code>-231&nbsp;&lt;= matrix[i][j] &lt;= 231&nbsp;- 1</code></span></li></ul><p>&nbsp;</p><p><span style="font-size: 16px;">普通解法，就是利用O(m+n)空间复杂度来解决问题，建立两个数组，一个row,一个col,分别保存要置零的行与要置零的列,遍历数组，获取相应的零的位置即可。</span></p><p><span style="font-size: 16px;">代码如下：</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> r[<span class="number">201</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> c[<span class="number">201</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; m ; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                r[i] = <span class="number">1</span>;</span><br><span class="line">                c[j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(r[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; m ; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(c[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    matrix[j][i] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><p><span style="font-size: 16px;">还有一种方法就是消耗最小的空间来解决问题，不创建任何数组，就利用它本身来解决问题，那么如何去解决呢。</span></p><p><span style="font-size: 16px;">首先，我们思考之前是不是都用两个数组来保存要置零的行和列，说到底就是我们需要知道哪一行需要置零，哪一列需要置零，那么我们是不是可以将置零信息保存在第0行与第0列呢。</span></p><p><span style="font-size: 16px;"><img src="https://img2020.cnblogs.com/blog/1582514/202103/1582514-20210326223554068-1329953760.png" alt="" loading="lazy" /></span></p><hr><p><span style="font-size: 16px;">最后遍历二维数组的时候，只需要遍历首行与首列，讲遇到的零的一列和一行全部置零就可以了，这个问题考虑完了，还有一个问题，就是首行与首列如果有零怎么办，我们选择用两个变量去保存首行首列是否需要置零的情况。比如，遍历首行，遇到一个零，那么我们知道，首行最后一定是要置零的，列同理，那么我们是不是应该考虑一下先后顺序，比如如果我们先将首行置零了，那接下来我们就无法根据上面的方法去判断哪一行和哪一列需要置零了，因为置零信息全部保存在起始行起始列。所以我们做事的顺序应该是：1.判断首行首列是否需要置零 2.遍历数组将需要置零的行列信息保存在首行首列（注意，遍历数组一定是不能包含首行首列的哦） 3.将蓝色区域置零 4.将粉色区域根据情况看是否置零</span></p><hr><p><span style="font-size: 16px;">这样我们就全部完成了。</span></p><p><span style="font-size: 16px;">代码如下：</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> row_z = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> col_z = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i++)</span><br><span class="line">            <span class="keyword">if</span>(matrix[<span class="number">0</span>][i] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    row_z = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    col_z = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; m ; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)</span><br><span class="line">                matrix[<span class="number">0</span>][j] = matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; m ; i++)</span><br><span class="line">            <span class="keyword">if</span>(matrix[<span class="number">0</span>][i] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; n ; j++)</span><br><span class="line">                    matrix[j][i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; i++)</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; m ; j++)</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(row_z)<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i++) matrix[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(col_z)<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++) matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;73-矩阵置零&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#73-矩阵置零&quot;&gt;¶&lt;/a&gt;73.矩阵置零&lt;/h2&gt;
&lt;h4 class=&quot;css-10c1h40-Title eugt34i1&quot; data-cypress=&quot;QuestionTit</summary>
      
    
    
    
    <category term="每日打卡" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"/>
    
    
    <category term="Leetcode题解" scheme="http://example.com/tags/Leetcode%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>graphics pipeline - 图形管线</title>
    <link href="http://example.com/2021/03/26/graphics1/"/>
    <id>http://example.com/2021/03/26/graphics1/</id>
    <published>2021-03-26T11:18:01.301Z</published>
    <updated>2021-03-26T11:19:39.576Z</updated>
    
    <content type="html"><![CDATA[<h2 id="graphics-pipeline-图形管线"><a class="header-anchor" href="#graphics-pipeline-图形管线">¶</a>graphics pipeline - 图形管线</h2><p>标准图形系统的实施流程通常称为图形管线。&rdquo;管线&ldquo;一词在这里指从数学模型到生成屏幕上像素的过程，它包含多个步骤。在经典的体系结构中，这些步骤是按序执行的，即一个阶段的结果输出给下一个阶段，前面阶段随即开始处理新的多边形。</p><hr><p>管线简化示意图：</p><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210117225547738-1443334944.png" alt="" loading="lazy" /></p><hr><p>在许多情况下，管线的实现细节并非关注点，这时可以把它看成一个黑盒，通过黑盒，场景几何模型被转换为场景多边形的光栅透视投影（这里暂时忽略平行投影情况）图像。</p><hr><p>纹理映射与近似</p><p>　　图形管线中的一个标准模块是纹理映射(texture map)，纹理映射通过查表的方式将纹理图像的颜色映射到一个或多个多边形上。这个过程就像在表面上刻写图案或是将一张花纹纸粘贴到物体上，扫描到系统中的图像，相机拍摄的照片，或者绘图软件制作的图像都是纹理图像，<span style="background-color: #ffff00;">你可以把纹理图案想象成一张有图案的橡胶片，而纹理坐标描述了为了使这张橡胶片能够准确覆盖物体的某些部位，以及橡胶片是如何进行拉伸和变形的</span>。</p><hr><p>个人理解：</p><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210117230232056-878760406.png" alt="" loading="lazy" /></p><hr><p>如上图，就是通过纹理坐标将纹理图案进行一系列拉伸和变形准确覆盖到物体上的对应位置。</p><hr><p>通过纹理映射来指定图像上每个点的颜色仅仅是纹理映射的众多应用之一。例如，一个物体的外观部分取决于表面的法向量，计算光从表面的反射时就涉及法向量，由于表面通常采用多边形网格表示，所以通常在各多边形的顶点处计算表面的法向量，多边形内部各点的法向量则通过插值获得，从而使该物体表面呈现平滑的外观效果。</p><hr><p>上述提到，管线结构能够让我们并行处理很多任务，管线上的每一阶段针对一部分数据执行某个任务，然后将处理结果传送给下一阶段，接着这一阶段立即开始处理下一部分数据，如果管线设计合理，则大大提高处理能力。当然，随着管线所含阶段数的增多，从输入数据到生成最终结果所需的时间总量也将增加。对于交互性要求很高的系统来说，这种滞后或者潜在滞后可能会造成严重影响。</p><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210117231156283-1550082328.png" alt="" loading="lazy" /></p><hr><p>图形管线包括4个主要部分：顶点几何处理和变换，三角形处理（光栅化）和片段（fragment)生成、纹理映射和光照以及用来组装最终图像的片段组合操作。</p><p>在这个更大的管线里，应用程序提供显示所需的数据，而图形管线则生成最终的图像，但在此期间用户可能会输入信息对应用程序进行控制（例如对所显示的图像有所影响），还有从图形管线中返回的信息，他们组合起来，用于计算下一帧画面。</p><hr><p>持续补充。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;graphics-pipeline-图形管线&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#graphics-pipeline-图形管线&quot;&gt;¶&lt;/a&gt;graphics pipeline - 图形管线&lt;/h2&gt;
&lt;p&gt;标准图形系统的实施流程通常称</summary>
      
    
    
    
    <category term="图形学" scheme="http://example.com/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="概念知识" scheme="http://example.com/tags/%E6%A6%82%E5%BF%B5%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Eigen:Matrix and Vector arithmetic</title>
    <link href="http://example.com/2021/03/26/Eigen2/"/>
    <id>http://example.com/2021/03/26/Eigen2/</id>
    <published>2021-03-26T11:12:15.866Z</published>
    <updated>2021-03-26T11:16:57.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Eigen-Matrix-and-Vector-arithmetic"><a class="header-anchor" href="#Eigen-Matrix-and-Vector-arithmetic">¶</a>Eigen:Matrix and Vector arithmetic</h2><p>Eigen库 有重载关于Matrix与Vector的计算符，这样我们可以很方便的得到矩阵运算后的结果。</p><p>一些基本运算符：+,-,*,/,+=,-=,*=,/=</p><hr><p>普通的矩阵加减法运算：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Matrix2d a;</span><br><span class="line">a &lt;&lt; <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line"><span class="number">3</span>, <span class="number">4</span>;</span><br><span class="line"><span class="function">MatrixXd <span class="title">b</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">b &lt;&lt; <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line"><span class="number">1</span>, <span class="number">4</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;a + b =\n&quot;</span> &lt;&lt; a + b &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;a - b =\n&quot;</span> &lt;&lt; a - b &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Doing a += b;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">a += b;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Now a =\n&quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line"><span class="function">Vector3d <span class="title">v</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">Vector3d <span class="title">w</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;-v + w - v =\n&quot;</span> &lt;&lt; -v + w - v &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>Output:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a + b =</span><br><span class="line"><span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="number">8</span></span><br><span class="line">a - b =</span><br><span class="line"><span class="number">-1</span> <span class="number">-1</span></span><br><span class="line"> <span class="number">2</span>  <span class="number">0</span></span><br><span class="line">Doing a += b;</span><br><span class="line">Now a =</span><br><span class="line"><span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="number">8</span></span><br><span class="line">-v + w - v =</span><br><span class="line"><span class="number">-1</span></span><br><span class="line"><span class="number">-4</span></span><br><span class="line"><span class="number">-6</span></span><br></pre></td></tr></table></figure><hr><p>乘法运算：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Matrix2d a;</span><br><span class="line">a &lt;&lt; <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line"><span class="number">3</span>, <span class="number">4</span>;</span><br><span class="line"><span class="function">Vector3d <span class="title">v</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;a * 2.5 =\n&quot;</span> &lt;&lt; a * <span class="number">2.5</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;0.1 * v =\n&quot;</span> &lt;&lt; <span class="number">0.1</span> * v &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Doing v = 2;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">v = <span class="number">2</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Now v =\n&quot;</span> &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>Output:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a * <span class="number">2.5</span> =</span><br><span class="line"><span class="number">2.5</span>   <span class="number">5</span></span><br><span class="line"><span class="number">7.5</span>  <span class="number">10</span></span><br><span class="line"><span class="number">0.1</span> * v =</span><br><span class="line"><span class="number">0.1</span></span><br><span class="line"><span class="number">0.2</span></span><br><span class="line"><span class="number">0.3</span></span><br><span class="line">Doing v *= <span class="number">2</span>;</span><br><span class="line">Now v =</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><hr><p>除此之外，Eigen库关于运算还有个很人性化的地方<br />比如，VectorXf a(50),b(50),c(50),d(50);<br />...<br />a = 3 * b + 4 * c + 5 * d;<br />会自动编译为：<br />for(int i = 0 ; i &lt; 50 ; i++){<br />a[i] = 3*b[i] + 4*c[i] + 5*d[i];<br />}</p><hr><p>注意：如果你看了上面一段关于表达式模板的内容，担心做m=m*m会引起别名问题，暂时放心。Eigen将矩阵乘法作为一种特殊情况处理，并注意在这里引入一个临时的，所以它将把m=m*m编译为：</p><div class="cnblogs_code"><pre>temp = m*<span style="color: #000000;">m;m </span>= temp;</pre></div><hr><p>然后是一些特殊的计算函数，十分便利：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span>() <span class="comment">//矩阵内元素和</span></span><br><span class="line"><span class="built_in">prod</span>() <span class="comment">//元素积</span></span><br><span class="line"><span class="built_in">mean</span>() <span class="comment">//元素平均</span></span><br><span class="line"><span class="built_in">minCoeff</span>() <span class="comment">//最小元素</span></span><br><span class="line"><span class="built_in">maxCoeff</span>() <span class="comment">//最大元素</span></span><br><span class="line"><span class="built_in">trace</span>() <span class="comment">//对角线和</span></span><br><span class="line"><span class="built_in">transpose</span>() <span class="comment">//转置</span></span><br><span class="line"><span class="built_in">conjugate</span>() <span class="comment">//共轭</span></span><br><span class="line"><span class="built_in">adjoint</span>() <span class="comment">//共轭转置</span></span><br></pre></td></tr></table></figure><hr><p>普通计算函数示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Eigen::Matrix2d mat;</span><br><span class="line">mat &lt;&lt; <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line"><span class="number">3</span>, <span class="number">4</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Here is mat.sum():       &quot;</span> &lt;&lt; mat.<span class="built_in">sum</span>()       &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Here is mat.prod():      &quot;</span> &lt;&lt; mat.<span class="built_in">prod</span>()      &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Here is mat.mean():      &quot;</span> &lt;&lt; mat.<span class="built_in">mean</span>()      &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Here is mat.minCoeff():  &quot;</span> &lt;&lt; mat.<span class="built_in">minCoeff</span>()  &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Here is mat.maxCoeff():  &quot;</span> &lt;&lt; mat.<span class="built_in">maxCoeff</span>()  &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Here is mat.trace():     &quot;</span> &lt;&lt; mat.<span class="built_in">trace</span>()     &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Here is mat.<span class="built_in">sum</span>():       <span class="number">10</span></span><br><span class="line">Here is mat.<span class="built_in">prod</span>():      <span class="number">24</span></span><br><span class="line">Here is mat.<span class="built_in">mean</span>():      <span class="number">2.5</span></span><br><span class="line">Here is mat.<span class="built_in">minCoeff</span>():  <span class="number">1</span></span><br><span class="line">Here is mat.<span class="built_in">maxCoeff</span>():  <span class="number">4</span></span><br><span class="line">Here is mat.<span class="built_in">trace</span>():     <span class="number">5</span></span><br></pre></td></tr></table></figure><hr><p>并且minCoeff()与maxCoeff()能够得到相应元素的下标，可使用如下方法实现：</p><p>int i,j;</p><p>minCoeff(&amp;i,&amp;j);</p><p>maxCoeff(&amp;i,&amp;j);</p><p>得到的i,j就是相应元素的横纵坐标。</p><hr><p>转置，共轭，共轭转置示例代码：</p><div class="cnblogs_code"><pre>MatrixXcf a = MatrixXcf::Random(<span style="color: #800080;">2</span>,<span style="color: #800080;">2</span>); <span style="color: #008000;">//</span><span style="color: #008000;">随机2x2矩阵</span>cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">Here is the matrix a\n</span><span style="color: #800000;">"</span> &lt;&lt; a &lt;&lt;<span style="color: #000000;"> endl;<p>cout </span>&lt;&lt; <span style="color: #800000;">“</span><span style="color: #800000;">Here is the matrix a^T\n</span><span style="color: #800000;">”</span> &lt;&lt; a.transpose() &lt;&lt;<span style="color: #000000;"> endl;</p><p>cout </span>&lt;&lt; <span style="color: #800000;">“</span><span style="color: #800000;">Here is the conjugate of a\n</span><span style="color: #800000;">”</span> &lt;&lt; a.conjugate() &lt;&lt;<span style="color: #000000;"> endl;</p><p>cout </span>&lt;&lt; <span style="color: #800000;">“</span><span style="color: #800000;">Here is the matrix a^*\n</span><span style="color: #800000;">”</span> &lt;&lt; a.adjoint() &lt;&lt; endl;</pre></p></div><hr><p>Output:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Here is the matrix a</span><br><span class="line">    (<span class="number">-1</span>,<span class="number">-0.737</span>) (<span class="number">0.0655</span>,<span class="number">-0.562</span>)</span><br><span class="line">(<span class="number">0.511</span>,<span class="number">-0.0827</span>)  (<span class="number">-0.906</span>,<span class="number">0.358</span>)</span><br><span class="line">Here is the matrix a^T</span><br><span class="line">    (<span class="number">-1</span>,<span class="number">-0.737</span>) (<span class="number">0.511</span>,<span class="number">-0.0827</span>)</span><br><span class="line">(<span class="number">0.0655</span>,<span class="number">-0.562</span>)  (<span class="number">-0.906</span>,<span class="number">0.358</span>)</span><br><span class="line">Here is the conjugate of a</span><br><span class="line">     (<span class="number">-1</span>,<span class="number">0.737</span>)  (<span class="number">0.0655</span>,<span class="number">0.562</span>)</span><br><span class="line"> (<span class="number">0.511</span>,<span class="number">0.0827</span>) (<span class="number">-0.906</span>,<span class="number">-0.358</span>)</span><br><span class="line">Here is the matrix a^*</span><br><span class="line">     (<span class="number">-1</span>,<span class="number">0.737</span>)  (<span class="number">0.511</span>,<span class="number">0.0827</span>)</span><br><span class="line"> (<span class="number">0.0655</span>,<span class="number">0.562</span>) (<span class="number">-0.906</span>,<span class="number">-0.358</span>)</span><br></pre></td></tr></table></figure><p>注意：<span style="background-color: #00ffff;">至于基本的算术运算符，transpose()和 adjoint()只是返回一个代理对象，而不进行实际的转置。如果你做b = a.transpose()，那么在将结果写入b的同时就会对transpose进行评估。如果执行a = a.transpose()，那么在转置的评估完成之前，Eigen就开始将结果写入a中。因此，指令a = a.transpose()并不像人们所期望的那样，用它的转置替换a。</span></p><hr><p>还有两个函数差点忘记说了，分别是dot()与cross()，一个是计算点积，一个是计算叉积，非常实用的两个函数！</p><hr><p>补充两个编译时容易出现的错误：（官方文档详细说明）</p><p><a class="el" title="Namespace containing all symbols from the Eigen library." href="http://eigen.tuxfamily.org/dox/namespaceEigen.html">Eigen</a>&nbsp;checks the validity of the operations that you perform. When possible, it checks them at compile time, producing compilation errors. These error messages can be long and ugly, but&nbsp;<a class="el" title="Namespace containing all symbols from the Eigen library." href="http://eigen.tuxfamily.org/dox/namespaceEigen.html">Eigen</a>&nbsp;writes the important message in UPPERCASE_LETTERS_SO_IT_STANDS_OUT. For example:（Eigen会检查你所执行的操作的有效性，在可能的情况下，它会在编译时检查它们，产生编译错误。在可能的情况下，它在编译时检查它们，产生编译错误。这些错误信息可能又长又丑，但Eigen会把重要的信息用UPPERCASE_LETTERS_SO_IT_STANDS_OUT写出来，如下：）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Matrix3f m;</span><br><span class="line">Vector4f v;</span><br><span class="line">v = m*v; <span class="comment">// Compile-time error: YOU_MIXED_MATRICES_OF_DIFFERENT_SIZES</span></span><br></pre></td></tr></table></figure><div class="line"><span class="comment">Of course, in many cases, for example when checking dynamic sizes, the check cannot be performed at compile time.&nbsp;<a class="el" title="Namespace containing all symbols from the Eigen library." href="http://eigen.tuxfamily.org/dox/namespaceEigen.html">Eigen</a>then uses runtime assertions. This means that the program will abort with an error message when executing an illegal operation if it is run in "debug mode", and it will probably crash if assertions are turned off（当然，在很多情况下，比如检查动态大小时，不能在编译时进行检查。Eigen就会使用运行时断点。这意味着，如果在 "debug模式 "下运行，程序在执行非法操作时，会以错误信息中止，如果断点被关闭，程序很可能会崩溃）.</span></div><div class="line">&nbsp;</div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MatrixXf <span class="title">m</span><span class="params">(<span class="number">3</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">VectorXf <span class="title">v</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">v = m * v; <span class="comment">// Run-time assertion failure here: &quot;invalid matrix product&quot;</span></span><br></pre></td></tr></table></figure><p><span class="comment">解释：第一个就是两种不同类型的矩阵相乘会出现SIZE报错，这是理所当然的，第二个就是检查动态大小时，不能在编译时进行检查！</span></p></div><hr><p>有些内容暂时用不到，以后补充。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Eigen-Matrix-and-Vector-arithmetic&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#Eigen-Matrix-and-Vector-arithmetic&quot;&gt;¶&lt;/a&gt;Eigen:Matrix and Vector</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="Eigen" scheme="http://example.com/tags/Eigen/"/>
    
  </entry>
  
  <entry>
    <title>Eigen:The Matrix Class</title>
    <link href="http://example.com/2021/03/26/Eigen1/"/>
    <id>http://example.com/2021/03/26/Eigen1/</id>
    <published>2021-03-26T11:05:43.527Z</published>
    <updated>2021-03-26T11:11:24.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="The-Matrix-Class"><a class="header-anchor" href="#The-Matrix-Class">¶</a>The Matrix Class</h2><p>Eigen库 矩阵类的使用：</p><p>（本文根据官方文档加上自己的一些理解修改制成）</p><hr><p>首先关于Matrix的定义：&nbsp; Matrix&lt;typename scalar, int RowsAtCompileTime, int ColsAtCompileTime&gt; 这是常用的模板，一般为三个参数，也就是Matrix&lt;矩阵变量类型，行数，列数&gt;.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">　　　　　　　　　　　 Matrix&lt;<span class="keyword">typename</span> Scalar, <span class="comment">//标量类型</span></span><br><span class="line"></span><br><span class="line">　　　　　　　　　　　　　    <span class="keyword">int</span> RowsAtCompileTime, <span class="comment">//行数</span></span><br><span class="line"></span><br><span class="line">　　　　　　　　　　　　　　  <span class="keyword">int</span> ColsAtCompileTime,<span class="comment">//列数</span></span><br><span class="line"></span><br><span class="line"> 　　　　　　　　　　　　　　 <span class="keyword">int</span> Options = <span class="number">0</span>,<span class="comment">//位域</span></span><br><span class="line"></span><br><span class="line">　　　　　　　　　　　　      <span class="keyword">int</span> MaxRowsAtCompileTime = RowsAtCompileTime,<span class="comment">//最大行数</span></span><br><span class="line"></span><br><span class="line">　　　　　　　　　　　　　　  <span class="keyword">int</span> MaxColsAtCompileTime = ColsAtCompileTime&gt; <span class="comment">//最大列数</span></span><br></pre></td></tr></table></figure><p><em>使用Eigen库定义一个矩阵: Matrix&lt;int,2,2&gt; 这是一个int类型的2x2矩阵</em></p><p><em>　　　　　　　　　　　　Matrix&lt;float,3,3&gt;这是一个float类型的3x3矩阵</em></p><hr><p><em>Eigen库中简化了部分以上定义的过程，一般用于固定尺寸的矩阵的定义。</em></p><p><em>例如：&nbsp; Matrix2f,Matrix3f,Matrix4f&nbsp; float类型的2x2,3x3,4x4的矩阵(可见结尾部分为f）</em></p><p><em>&nbsp; &nbsp; &nbsp;同理Matrix2d,Matrix3d,Matrix4d,Matrix2i,Matrix3i,Matrix4i,只需要看最后结尾的字母，即可明白变量类型(double,int)</em></p><p>Eigen还有个常用的概念，向量，向量是矩阵中的特殊情况，表现为有一行或一列，也就是行向量和列向量，最常见的情况是只有一列，表现方式有：</p><p>　　　　　　　　　　　&nbsp; typedef Matrix&lt;float, 3, 1&gt; Vector3f;&nbsp; //列向量</p><p>　　　　　　　　　　　&nbsp; typedef Matrix&lt;int, 1, 2&gt; RowVector2i; //行向量</p><hr><p>接下来说明它们各自的赋值方式以及特殊情况：</p><p>静态矩阵下有如下的初始化方式:&nbsp; Vector2i myvector(1,2);&nbsp; 表示初始化一个列向量为<img src="https://img2020.cnblogs.com/blog/1582514/202012/1582514-20201230135221369-1383356973.png" alt="" loading="lazy" />&nbsp;或者 Vector2f myvector(1.0,2.0); 表示初始化一个列向量为<img src="https://img2020.cnblogs.com/blog/1582514/202012/1582514-20201230135913953-1373528500.png" alt="" loading="lazy" /></p><hr><p>向量能这样初始化，但Matrix就不行了，比如Matrix3f a(3,3)虽然编译能够通过，不会报错，但是这样的传递参数是无效的， 在官方文档有解释：In order to offer a uniform API across fixed-size and dynamic-size matrices, it is legal to use these constructors on fixed-size matrices, even if passing the sizes is useless in this case. 意思是：为了在固定大小和动态大小的矩阵上提供统一的API，在固定大小的矩阵上使用这些构造函数是合法的，即使在这种情况下传递大小是无用的。</p><hr><p>所以只能使用规定的输入方法： Matrix3f a;</p><p>　　　　　　　　　　　　　　 a&lt;&lt;1,2,3,</p><p>　　　　　　　　　　　　　　&nbsp; &nbsp; &nbsp; &nbsp;4,5,6,</p><p>　　　　　　　　　　　　　　　　7,8,9;</p><hr><p>说完静态矩阵，接下来说动态矩阵：typedef Matrix &lt;double,Dynamic,Dynamic&gt; MatrixXd;</p><p>看如下对比即可明白：</p><p>一般Matrix4f mymatrix; 等价于 float mymatrix[16];<br />一般MatrixXf mymatrix(rows,columns); 等价于 float *mymatrix = new float[rows*columns];</p><hr><p>所以有 MatrixXf a(2,2) 即定义一个2x2的矩阵，而且Eigen库有访问矩阵中值的特定方式。</p><p>如<img src="https://img2020.cnblogs.com/blog/1582514/202012/1582514-20201230140825999-966352070.png" alt="" loading="lazy" />，&nbsp;</p><hr><p>访问第一行第一个元素 即 a(0,1) ,也可 a(0,1) = x 为第一行第一个元素赋值。</p><p>如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">MatrixXd <span class="title">m</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="built_in">m</span>(<span class="number">0</span>,<span class="number">0</span>) = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">m</span>(<span class="number">1</span>,<span class="number">0</span>) = <span class="number">2.5</span>;</span><br><span class="line"><span class="built_in">m</span>(<span class="number">0</span>,<span class="number">1</span>) = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">m</span>(<span class="number">1</span>,<span class="number">1</span>) = <span class="built_in">m</span>(<span class="number">1</span>,<span class="number">0</span>) + <span class="built_in">m</span>(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Here is the matrix m:\n&quot;</span> &lt;&lt; m &lt;&lt; std::endl;</span><br><span class="line"><span class="function">VectorXd <span class="title">v</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="built_in">v</span>(<span class="number">0</span>) = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">v</span>(<span class="number">1</span>) = <span class="built_in">v</span>(<span class="number">0</span>) - <span class="number">1</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Here is the vector v:\n&quot;</span> &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Here is the matrix m:</span><br><span class="line">  <span class="number">3</span>  <span class="number">-1</span></span><br><span class="line"><span class="number">2.5</span> <span class="number">1.5</span></span><br><span class="line">Here is the vector v:</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>像这类动态分配大小的矩阵，有 resize()方法，可以重新定义大小，这篇代码写的很清楚：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">MatrixXd <span class="title">m</span><span class="params">(<span class="number">2</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">m.<span class="built_in">resize</span>(<span class="number">4</span>,<span class="number">3</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;The matrix m is of size &quot;</span></span><br><span class="line">&lt;&lt; m.<span class="built_in">rows</span>() &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; m.<span class="built_in">cols</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;It has &quot;</span> &lt;&lt; m.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; coefficients&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="function">VectorXd <span class="title">v</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">v.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;The vector v is of size &quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;As a matrix, v is of size &quot;</span></span><br><span class="line">&lt;&lt; v.<span class="built_in">rows</span>() &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; v.<span class="built_in">cols</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The matrix m is of size <span class="number">4</span>x3</span><br><span class="line">It has <span class="number">12</span> coefficients</span><br><span class="line">The vector v is of size <span class="number">5</span></span><br><span class="line">As a matrix, v is of size <span class="number">5</span>x1</span><br></pre></td></tr></table></figure><hr><p>&nbsp;然后说明一下固定尺寸与动态尺寸的选择问题，也就是什么时候静态分配最好，什么时候动态分配最好。</p><p>&nbsp;对于非常小的尺寸，尽可能使用Fixed（一般定义为小于等于16），这种情况下使用Fixed尺寸性能更加优越,因为它可以让Eigen避免动态内存分配和展开循环，对于较大尺寸的话就使用dynamic尺寸，</p><p>&nbsp;当然，使用固定大小的局限性在于，只有在编译时知道大小时才有可能。另外，对于足够大的尺寸，比如说大于或等于32的尺寸，使用固定尺寸的性能优势就变得微不足道了。更糟糕的是，如果试图在函数中使用固定大小创建一个非常大&nbsp; &nbsp;的矩阵，可能会导致堆栈溢出，因为Eigen会尝试将数组作为一个局部变量自动分配，而这通常是在堆栈中完成的。最后，根据不同的情况，当使用动态大小时，Eigen还可以更积极地尝试矢量化（使用SIMD指令）。</p><hr><p>&nbsp;最后解释一下上面说过的可选参数模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Matrix&lt;<span class="keyword">typename</span> Scalar,</span><br><span class="line">　　　　　　<span class="keyword">int</span> RowsAtCompileTime,</span><br><span class="line">　　　　　　<span class="keyword">int</span> ColsAtCompileTime,</span><br><span class="line">　　　　　　<span class="keyword">int</span> Options = <span class="number">0</span>,</span><br><span class="line">　　　　　　<span class="keyword">int</span> MaxRowsAtCompileTime = RowsAtCompileTime,</span><br><span class="line">　　　　　　<span class="keyword">int</span> MaxColsAtCompileTime = ColsAtCompileTime&gt;</span><br></pre></td></tr></table></figure><p>从参数的定义名即可看出来其大概意思。</p><p>分析：Matrix&lt;float,Dynamic,Dynamic,0,3,4&gt;&nbsp; 一个不知道大小，但最大行数为3，最大列数为4的矩阵。<br />从官方文档对于Matrix Optional template parameters 的定义来看，这是一个确定了上限的固定内存矩阵，如果在编译时不知道矩阵的确切大小，但在编译时可以知道一个固定的上限，这样做可以避免动态内存分配。</p><p>第三个参数是什么意思呢，在我看来是一个优先级的参数，比如一个矩阵是行优先还是列优先就是使用这个参数，0一般是默认值，不设置任何优先。</p><p>比如：Matrix&lt;float,3,3,RowMajor&gt; 就是一个行优先的矩阵。</p><hr><p>补充Eigen便利类型定义：</p><p><a class="el" title="Namespace containing all symbols from the Eigen library." href="http://eigen.tuxfamily.org/dox/namespaceEigen.html">Eigen</a>&nbsp;defines the following&nbsp;<a class="el" title="The matrix class, also used for vectors and row-vectors." href="http://eigen.tuxfamily.org/dox/classEigen_1_1Matrix.html">Matrix</a>&nbsp;typedefs:</p><ul><li>MatrixNt for Matrix&lt;type, N, N&gt;. For example, MatrixXi for Matrix&lt;int, Dynamic, Dynamic&gt;.</li><li>VectorNt for Matrix&lt;type, N, 1&gt;. For example, Vector2f for Matrix&lt;float, 2, 1&gt;.</li><li>RowVectorNt for Matrix&lt;type, 1, N&gt;. For example, RowVector3d for Matrix&lt;double, 1, 3&gt;.</li></ul><p>Where:</p><ul><li>N can be any one of&nbsp;<code>2</code>,&nbsp;<code>3</code>,&nbsp;<code>4</code>, or&nbsp;<code>X</code>&nbsp;(meaning&nbsp;<code>Dynamic</code>).</li><li>t can be any one of&nbsp;<code>i</code>&nbsp;(meaning int),&nbsp;<code>f</code>&nbsp;(meaning float),&nbsp;<code>d</code>&nbsp;(meaning double),&nbsp;<code>cf</code>&nbsp;(meaning complex&lt;float&gt;), or&nbsp;<code>cd</code>(meaning complex&lt;double&gt;). The fact that typedefs are only defined for these five types doesn't mean that they are the only supported scalar types. For example, all standard integer types are supported, see&nbsp;<a class="el" href="http://eigen.tuxfamily.org/dox/TopicScalarTypes.html">Scalar types</a>.</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;The-Matrix-Class&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#The-Matrix-Class&quot;&gt;¶&lt;/a&gt;The Matrix Class&lt;/h2&gt;
&lt;p&gt;Eigen库 矩阵类的使用：&lt;/p&gt;
&lt;p&gt;（本文根据官方文档加上自</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="Eigen" scheme="http://example.com/tags/Eigen/"/>
    
  </entry>
  
  <entry>
    <title>线性代数及其应用(二)</title>
    <link href="http://example.com/2021/03/26/lial2/"/>
    <id>http://example.com/2021/03/26/lial2/</id>
    <published>2021-03-26T11:00:38.711Z</published>
    <updated>2021-03-26T11:05:08.478Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线性代数及其应用-二"><a class="header-anchor" href="#线性代数及其应用-二">¶</a>线性代数及其应用(二)</h2><p>向量方程</p><p>线性方程组的重要性质都可用向量概念与符号来描述。</p><p><strong>R</strong><sup>2</sup>中的向量:</p><p>　　仅含一列的矩阵称为列向量，或简称向量，包含两个元素的向量如下：</p><p>　　<img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114203419813-1752537434.png" alt="" loading="lazy" /><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114203438965-2116671834.png" alt="" loading="lazy" /><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114203521345-1191418457.png" alt="" loading="lazy" /></p><hr><p>&nbsp;　&nbsp; 其中w<sub>1</sub>和w<sub>2</sub>是任意实数，所有两个元素的向量集记为<strong>R</strong><sup>2</sup>，<strong>R</strong>表示向量中的元素是实数，而指数2表示每个向量包含两个元素.&nbsp;</p><p>　　给定<strong>R</strong><sup>2</sup>中两个向量u和v，它们的和u+v是把u和v对应元素相加所得的向量，如</p><p>　　<img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114203944587-551626870.png" alt="" loading="lazy" /></p><hr><div class="cnblogs_code"><pre><span style="color: #000000;">\begin{bmatrix}</span><span style="color: #800080;">1</span><span style="color: #000000;">\\ </span>-<span style="color: #800080;">2</span><span style="color: #000000;">\\\end{bmatrix}</span>+<span style="color: #000000;">\begin{bmatrix}</span><span style="color: #800080;">2</span><span style="color: #000000;">\\ </span><span style="color: #800080;">5</span><span style="color: #000000;">\\\end{bmatrix}</span>=<span style="color: #000000;">\begin{bmatrix}</span><span style="color: #800080;">1</span>+<span style="color: #800080;">2</span><span style="color: #000000;">\\ </span>-<span style="color: #800080;">2</span>+<span style="color: #800080;">5</span><span style="color: #000000;">\\\end{bmatrix}</span>=<span style="color: #000000;">\begin{bmatrix}</span><span style="color: #800080;">3</span><span style="color: #000000;">\\ </span><span style="color: #800080;">3</span><span style="color: #000000;">\\\end{bmatrix}</span></pre></div><hr><p>　　给定向量u和实数c,u与c的标量乘法（或数乘）是把u的每个元素乘以c,所得向量记为cu，例如：</p><p>　　若<img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114204144474-273683973.png" alt="" loading="lazy" />;, c = 5,则</p><hr><p>&nbsp; &nbsp; &nbsp; &nbsp;<img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114204235817-645942824.png" alt="" loading="lazy" /></p><hr><div class="cnblogs_code"><pre>cu = <span style="color: #800080;">5</span><span style="color: #000000;">\begin{bmatrix}</span><span style="color: #800080;">3</span><span style="color: #000000;">\\ </span>-<span style="color: #800080;">1</span><span style="color: #000000;">\\\end{bmatrix}</span>=<span style="color: #000000;">\begin{bmatrix}</span><span style="color: #800080;">15</span><span style="color: #000000;">\\ </span>-<span style="color: #800080;">5</span><span style="color: #000000;">\\\end{bmatrix}</span></pre></div><hr><p><strong>&nbsp;R</strong><sup>2</sup>的几何表示</p><p>　　考虑平面上的直角坐标系，因为平面上每个点由实数的有序对确定，所以可把几何点(a,b) 与列向量<img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114204443579-1598459939.png" alt="" loading="lazy" />等同，因此我们可把R<sup>2</sup>看作平面上所有点的集合</p><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114204712781-911184167.png" alt="" loading="lazy" />&nbsp;&nbsp;<hr><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114204820571-445091784.png" alt="" loading="lazy" /></p></p><hr><p>&nbsp;　　两个向量的和的几何意义</p><p>　　<img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114205154150-1250560095.png" alt="" loading="lazy" /></p><hr><p>　　<strong>R</strong><sup>3</sup>中的向量</p><p>　　<img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114205719156-1126824442.png" alt="" loading="lazy" /></p><hr><p>　　<strong>R</strong><sup>n</sup>中的代数性质 （对<strong>R</strong><sup>n</sup>中一切向量u,v,w以及标量c和d）：</p><p>　　1. u + v = v + u</p><p>　　2.(u+v)+w = u+(v+w)</p><p>　　3.(u+0)=0+u=u</p><p>　　4.u+(-u) = -u+u =0</p><p>　　5.c(u+v)=cu+cv</p><p>　　6.(c+d)u=cu+du</p><p>　　7.c(du)=(cd)u</p><p>　　8.1u=u</p><hr><p>　　线性代数的一个主要思想是研究可以表示为某一个固定向量集合{v<sub>1</sub>,v<sub>2</sub>,....v<sub>p</sub>}的线性组合的所有向量</p><p>　　Span{v} 与 Span{u,v}的几何解释</p><p>　　设v是<strong>R</strong><sup>3</sup>中的向量，那么Span{v}就是v的所有标量倍数的集合，也就是<strong>R</strong><sup>3</sup>中通过v和0的直线上所有点的集合</p><p>　　</p><p>&nbsp;　　<img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114210420986-390914887.png" alt="" loading="lazy" /></p><hr><p>　　　若u和v是<strong>R</strong><sup>3</sup>中的非零向量，v不是u的倍数，则Span{u,v}是<strong>R</strong><sup>3</sup>中包含u,v和0的平面，特别地，Span{u,v}包含<strong>R</strong><sup>3</sup>中通过u与0的直线，也包含通过v与0的直线，反正就是确定了一个平面。</p><p>　　　　</p><p>&nbsp;　　<img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210114210841656-276500780.png" alt="" loading="lazy" /></p><hr><p>&nbsp;　　蓝色范围在概念上无限扩充。</p><p>&nbsp;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;线性代数及其应用-二&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#线性代数及其应用-二&quot;&gt;¶&lt;/a&gt;线性代数及其应用(二)&lt;/h2&gt;
&lt;p&gt;向量方程&lt;/p&gt;
&lt;p&gt;线性方程组的重要性质都可用向量概念与符号来描述。&lt;/p&gt;
&lt;p&gt;&lt;strong</summary>
      
    
    
    
    <category term="数学" scheme="http://example.com/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="线性代数" scheme="http://example.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>线性代数及其应用(一)</title>
    <link href="http://example.com/2021/03/26/lial1/"/>
    <id>http://example.com/2021/03/26/lial1/</id>
    <published>2021-03-26T10:58:34.458Z</published>
    <updated>2021-03-26T11:00:26.140Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线性代数及其应用-一"><a class="header-anchor" href="#线性代数及其应用-一">¶</a>线性代数及其应用(一)</h2><p>线性方程组：</p><p>包含变量x<sub>1</sub>,x<sub>2</sub>，&hellip;&hellip;，x<sub>n</sub>的线性方程是形如</p><p>　　　　　　　　　　a<sub>1</sub>x<sub>2</sub> +a<sub>2</sub>x<sub>2</sub>+...+a<sub>3</sub>x<sub>3</sub>&nbsp; = b&nbsp;</p><p>的方程，其中b与系数a<sub>1&nbsp; &nbsp;</sub>，a<sub>2&nbsp;</sub>&nbsp;，&hellip;&hellip; ，a<sub>n是实数或者复数，通常是已知数，下标n可以是任意正整数。</sub><sub><br /></sub></p><hr><p>线性方程组的解有下列三种情况：</p><p>①无解</p><p>②有唯一解</p><p>③有无穷多解</p><hr><p>若一个线性方程组有一个解或无穷多个解，则称它是相容的，若它无解，则称它是不相容的。</p><hr><p>初等行变换：</p><p>①（倍加变换）把某一行换成它本身与另一行的倍数的和</p><p>②（对换变换）把两行对换</p><p>③（倍乘对换）把某一行的所有元素乘以同一个非零数</p><hr><p>行变换可以施与任何矩阵，不仅仅是对于线性方程组的增广矩阵，若其中一个矩阵可以经过一系列初等行变换变换成另外一个矩阵，则我们称这两个矩阵是等价的。</p><p>若两个线性方程组的增广矩阵是行等价的，则它们具有相同的解集。</p><hr><p>行简化与阶梯形矩阵</p><p>定义：一个矩阵称为阶梯形（或行阶梯形），则它有已下三个性质：</p><p>①每一非零行都在每一零行之上</p><p>②某一行的先导元素所在的列位于前一行先导元素的右边</p><p>③某一先导元素所在列下方元素都是零</p><p>一个矩阵称为简化阶梯形，则它满足以下性质：</p><p>①每一非零行的先导元素是1</p><p>②每一先导元素1是该元素所在列的唯一非零元素</p><hr><p>通常将矩阵变换成简化阶梯形矩阵的过程称为高斯消元法。（计算机程序通常选择一列中绝对值最大的元素作为主元，可以减少舍入误差）</p><p>但某些条件下高斯消元法不适用，使用的是部分主元法（列主元高斯消元法）</p><hr><p>原因：</p><p>&nbsp;</p><p><img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210111155846873-924934418.png" alt="" loading="lazy" /></p><hr><p>&nbsp;<img src="https://img2020.cnblogs.com/blog/1582514/202101/1582514-20210111155905395-20983245.png" alt="" loading="lazy" /></p><hr><p>&nbsp;图片来自：<a href="https://www.zhihu.com/question/33862337">https://www.zhihu.com/question/33862337</a></p><hr><p>部分主元法思想：在进行第k(k=1,2,3...n-1)步消元时，从第k列的a<sub>kk</sub>及其以下的各元素中选取绝对值最大的元素，然后通过行变换将它交换到主元素a<sub>kk</sub>的位置上，再进行消元。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;线性代数及其应用-一&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#线性代数及其应用-一&quot;&gt;¶&lt;/a&gt;线性代数及其应用(一)&lt;/h2&gt;
&lt;p&gt;线性方程组：&lt;/p&gt;
&lt;p&gt;包含变量x&lt;sub&gt;1&lt;/sub&gt;,x&lt;sub&gt;2&lt;/sub&gt;，&amp;hell</summary>
      
    
    
    
    <category term="数学" scheme="http://example.com/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="线性代数" scheme="http://example.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
</feed>
